## Context

You are an AI assistant helping with software development tasks.

**Current Date:** 2025-12-05 21:29:41

---

## Task Description

Analise a viabilidade em refatorar o script para uma aplicação cli utilizando go.

---

## Project Constraints & Rules



---

## Project Structure

└── ghtools/
    ├── test/
    │   ├── helpers/
    │   ├── integration/
    │   │   ├── mocks/
    │   │   │   ├── fzf [215B]
    │   │   │   ├── gh [1.3KB]
    │   │   │   ├── git [968B]
    │   │   │   ├── gum [825B]
    │   │   │   └── jq [74B]
    │   │   └── test_actions.bats [6.6KB]
    │   ├── mocks/
    │   ├── unit/
    │   │   ├── mocks/
    │   │   │   ├── fzf [215B]
    │   │   │   ├── gh [1.3KB]
    │   │   │   ├── gh_fail [19B]
    │   │   │   ├── gh_no_auth [76B]
    │   │   │   ├── git [968B]
    │   │   │   ├── gum [825B]
    │   │   │   └── jq [74B]
    │   │   ├── test_cache_and_config.bats [3.0KB]
    │   │   ├── test_error_handling.bats [5.9KB]
    │   │   ├── test_main_entry_point.bats [8.0KB]
    │   │   └── test_utility_functions.bats [3.7KB]
    │   ├── README.md [5.6KB]
    │   ├── bats.config.bash [480B]
    │   └── test_helper.bash [8.9KB]
    ├── AGENTS.md [3.0KB]
    ├── CLAUDE.md [1.7KB]
    ├── PLAN.md [10.3KB]
    ├── README.md [12.4KB]
    ├── TASKS.md [5.4KB]
    ├── TEST_CHECKLIST.md [5.6KB]
    ├── TEST_COVERAGE_REPORT.md [8.0KB]
    ├── ghtools [56.3KB]
    ├── ghtools_functions.sh [56.5KB]
    ├── install.sh [12.4KB]
    └── run_tests.sh [4.9KB]

<file path="test/integration/mocks/fzf">
#!/bin/bash
# Mock fzf - just select first line or echo input
if [ "$*" == *"--multi"* ]; then
    # Multi-select mode - return all lines
    cat
else
    # Single select - return first line
    head -n 1
fi
exit 0
</file>
<file path="test/integration/mocks/gh">
#!/bin/bash
case "$1" in
    "auth")
        if [ "$2" = "status" ]; then
            echo "github.com
  Logged in to github.com as user (oauth_token)
  Git operations done over the http on api.github.com
  Active user: user"
            exit 0
        fi
        ;;
    "repo")
        case "$2" in
            "list")
                if [ "$3" = "--limit" ]; then
                    # Output mock repository data
                    echo "user/test-repo"
                    echo "user/private-repo"
                fi
                ;;
            "clone")
                echo "Mock clone of $3"
                exit 0
                ;;
            "create")
                echo "Mock create of $3"
                exit 0
                ;;
            "delete")
                echo "Mock delete of $3"
                exit 0
                ;;
            "edit")
                echo "Mock edit of $3"
                exit 0
                ;;
        esac
        ;;
    "search")
        if [ "$1" = "search" ] && [ "$2" = "repos" ]; then
            # Output mock search results
            echo "example/repo1"
            echo "example/repo2"
        fi
        ;;
    "api")
        # Mock API calls
        if [[ "$*" == *"user/starred"* ]]; then
            echo "Mock starred"
            exit 0
        fi
        ;;
esac
exit 0
</file>
<file path="test/integration/mocks/git">
#!/bin/bash
case "$1" in
    "init")
        mkdir -p "$2/.git"
        echo "Initialized empty Git repository in $2/.git/"
        exit 0
        ;;
    "add")
        exit 0
        ;;
    "commit")
        echo "[master (root-commit) 1234567] Test commit"
        exit 0
        ;;
    "branch")
        if [ "$1" = "branch" ] && [ "$2" = "--show-current" ]; then
            echo "main"
            exit 0
        fi
        if [ "$1" = "branch" ]; then
            echo "* main"
            exit 0
        fi
        ;;
    "diff-index")
        # Pretend working tree is clean
        exit 0
        ;;
    "fetch")
        exit 0
        ;;
    "pull")
        echo "Already up to date."
        exit 0
        ;;
    "push")
        echo "Everything up-to-date"
        exit 0
        ;;
    "ls-remote")
        # Pretend remote branch exists
        exit 0
        ;;
    "rev-list")
        echo "0"
        exit 0
        ;;
esac
# Default: succeed
exit 0
</file>
<file path="test/integration/mocks/gum">
#!/bin/bash
# Mock gum - just echo the text or return first line for choose
case "$1" in
    "style")
        # Just output the text
        shift
        echo "$@"
        ;;
    "choose")
        # Return first option
        head -n 1
        ;;
    "input")
        # Return default or echo input
        if [[ "$*" == *"--value"* ]]; then
            # Get default value
            echo "default"
        else
            read -r input
            echo "${input:-default}"
        fi
        ;;
    "confirm")
        # Always return true
        exit 0
        ;;
    "filter")
        # Return input
        head -n 1
        ;;
    "write")
        # Return default text
        echo "Test commit message"
        ;;
    "spin")
        # Execute command and return
        shift
        "$@"
        ;;
esac
exit 0
</file>
<file path="test/integration/mocks/jq">
#!/bin/bash
# Simple jq mock - just pass through for basic operations
cat
</file>
<file path="test/integration/test_actions.bats">
#!/usr/bin/env bats

load '../test_helper.bash'

# Test: action_list with default options
@test "action_list displays repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_list
    [ "$status" -eq 0 ]
    [[ "$output" == *"NAME"* ]]
    [[ "$output" == *"DESCRIPTION"* ]]
    [[ "$output" == *"VISIBILITY"* ]]
    [[ "$output" == *"LANG"* ]]
    [[ "$output" == *"UPDATED"* ]]
}

# Test: action_list with --refresh flag
@test "action_list with refresh flag forces cache update" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"

    run action_list --refresh
    [ "$status" -eq 0 ]
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: action_list with language filter
@test "action_list filters by language" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_list --lang bash
    [ "$status" -eq 0 ]
    [[ "$output" == *"NAME"* ]]
}

# Test: action_list with organization filter
@test "action_list filters by organization" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_list --org testorg
    [ "$status" -eq 0 ]
    [[ "$output" == *"NAME"* ]]
}

# Test: action_clone without arguments (uses default path)
@test "action_clone uses default clone path" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json
    mkdir -p "$HOME"

    run action_clone
    [ "$status" -eq 0 ]
}

# Test: action_clone with custom path
@test "action_clone accepts custom path" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json
    local test_dir="$TEST_TMP_DIR/clones"
    mkdir -p "$test_dir"

    run action_clone --path "$test_dir"
    [ "$status" -eq 0 ]
}

# Test: action_sync with dry-run mode
@test "action_sync dry-run mode shows what would be synced" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run action_sync --path "$test_dir" --dry-run
    [ "$status" -eq 0 ]
}

# Test: action_sync with --all flag
@test "action_sync with all flag syncs all repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    mkdir -p "$test_dir/repo2"
    create_test_git_repo "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo2"

    run action_sync --path "$test_dir" --all
    [ "$status" -eq 0 ]
}

# Test: action_sync with max-depth
@test "action_sync respects max-depth parameter" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir"

    run action_sync --path "$test_dir" --max-depth 1
    [ "$status" -eq 0 ]
}

# Test: action_status displays repository status
@test "action_status shows repository status" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run action_status --path "$test_dir"
    [ "$status" -eq 0 ]
    [[ "$output" == *"REPOSITORY"* ]]
    [[ "$output" == *"BRANCH"* ]]
    [[ "$output" == *"STATUS"* ]]
}

# Test: action_status with max-depth
@test "action_status respects max-depth parameter" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir"

    run action_status --path "$test_dir" --max-depth 2
    [ "$status" -eq 0 ]
}

# Test: action_stats generates statistics
@test "action_stats displays statistics dashboard" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_stats
    [ "$status" -eq 0 ]
    [[ "$output" == *"Total Repositories"* ]] || [[ "$output" == *"REPOSITORY STATISTICS"* ]]
}

# Test: action_browse opens repositories in browser
@test "action_browse opens selected repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_browse
    [ "$status" -eq 0 ]
}

# Test: action_search performs fuzzy search
@test "action_search performs repository search" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_search
    [ "$status" -eq 0 ]
}

# Test: action_fork without arguments
@test "action_fork prompts for search query" {
    PATH="${MOCK_DIR}:${PATH}"

    # Mock user input
    export GH_FORK_QUERY="test"

    run action_fork "test query"
    [ "$status" -eq 0 ]
}

# Test: action_fork with --clone flag
@test "action_fork with clone flag forks and clones" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_fork --clone "test query"
    [ "$status" -eq 0 ]
}

# Test: action_explore with query
@test "action_explore searches external repositories" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_explore "machine learning" --lang python
    [ "$status" -eq 0 ]
}

# Test: action_trending with language filter
@test "action_trending shows trending repositories" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_trending --lang python
    [ "$status" -eq 0 ]
}

# Test: action_archive archives repositories
@test "action_archive archives selected repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_archive
    [ "$status" -eq 0 ]
}

# Test: action_archive with --unarchive flag
@test "action_archive unarchives repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_archive --unarchive
    [ "$status" -eq 0 ]
}

# Test: action_visibility changes repository visibility
@test "action_visibility changes to public" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_visibility --public
    [ "$status" -eq 0 ]
}

@test "action_visibility changes to private" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_visibility --private
    [ "$status" -eq 0 ]
}

# Test: action_pr list subcommand
@test "action_pr list shows pull requests" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_pr list
    [ "$status" -eq 0 ]
}

# Test: apply_template for python
@test "apply_template creates python template" {
    local test_dir="$TEST_TMP_DIR/test_repo"
    mkdir -p "$test_dir"

    run apply_template "$test_dir" "python"
    [ "$status" -eq 0 ]
    [ -f "$test_dir/main.py" ]
    [ -f "$test_dir/README.md" ]
    [ -f "$test_dir/.gitignore" ]
}

# Test: apply_template for node
@test "apply_template creates node template" {
    local test_dir="$TEST_TMP_DIR/test_repo"
    mkdir -p "$test_dir"

    run apply_template "$test_dir" "node"
    [ "$status" -eq 0 ]
    [ -f "$test_dir/index.js" ]
    [ -f "$test_dir/package.json" ]
    [ -f "$test_dir/README.md" ]
    [ -f "$test_dir/.gitignore" ]
}

# Test: apply_template for go
@test "apply_template creates go template" {
    local test_dir="$TEST_TMP_DIR/test_repo"
    mkdir -p "$test_dir"

    run apply_template "$test_dir" "go"
    [ "$status" -eq 0 ]
    [ -f "$test_dir/main.go" ]
    [ -f "$test_dir/README.md" ]
}
</file>
<file path="test/unit/mocks/fzf">
#!/bin/bash
# Mock fzf - just select first line or echo input
if [ "$*" == *"--multi"* ]; then
    # Multi-select mode - return all lines
    cat
else
    # Single select - return first line
    head -n 1
fi
exit 0
</file>
<file path="test/unit/mocks/gh">
#!/bin/bash
case "$1" in
    "auth")
        if [ "$2" = "status" ]; then
            echo "github.com
  Logged in to github.com as user (oauth_token)
  Git operations done over the http on api.github.com
  Active user: user"
            exit 0
        fi
        ;;
    "repo")
        case "$2" in
            "list")
                if [ "$3" = "--limit" ]; then
                    # Output mock repository data
                    echo "user/test-repo"
                    echo "user/private-repo"
                fi
                ;;
            "clone")
                echo "Mock clone of $3"
                exit 0
                ;;
            "create")
                echo "Mock create of $3"
                exit 0
                ;;
            "delete")
                echo "Mock delete of $3"
                exit 0
                ;;
            "edit")
                echo "Mock edit of $3"
                exit 0
                ;;
        esac
        ;;
    "search")
        if [ "$1" = "search" ] && [ "$2" = "repos" ]; then
            # Output mock search results
            echo "example/repo1"
            echo "example/repo2"
        fi
        ;;
    "api")
        # Mock API calls
        if [[ "$*" == *"user/starred"* ]]; then
            echo "Mock starred"
            exit 0
        fi
        ;;
esac
exit 0
</file>
<file path="test/unit/mocks/gh_fail">
#!/bin/bash
exit 1
</file>
<file path="test/unit/mocks/gh_no_auth">
#!/bin/bash
if [ "$1" = "auth" ] && [ "$2" = "status" ]; then
    exit 1
fi
</file>
<file path="test/unit/mocks/git">
#!/bin/bash
case "$1" in
    "init")
        mkdir -p "$2/.git"
        echo "Initialized empty Git repository in $2/.git/"
        exit 0
        ;;
    "add")
        exit 0
        ;;
    "commit")
        echo "[master (root-commit) 1234567] Test commit"
        exit 0
        ;;
    "branch")
        if [ "$1" = "branch" ] && [ "$2" = "--show-current" ]; then
            echo "main"
            exit 0
        fi
        if [ "$1" = "branch" ]; then
            echo "* main"
            exit 0
        fi
        ;;
    "diff-index")
        # Pretend working tree is clean
        exit 0
        ;;
    "fetch")
        exit 0
        ;;
    "pull")
        echo "Already up to date."
        exit 0
        ;;
    "push")
        echo "Everything up-to-date"
        exit 0
        ;;
    "ls-remote")
        # Pretend remote branch exists
        exit 0
        ;;
    "rev-list")
        echo "0"
        exit 0
        ;;
esac
# Default: succeed
exit 0
</file>
<file path="test/unit/mocks/gum">
#!/bin/bash
# Mock gum - just echo the text or return first line for choose
case "$1" in
    "style")
        # Just output the text
        shift
        echo "$@"
        ;;
    "choose")
        # Return first option
        head -n 1
        ;;
    "input")
        # Return default or echo input
        if [[ "$*" == *"--value"* ]]; then
            # Get default value
            echo "default"
        else
            read -r input
            echo "${input:-default}"
        fi
        ;;
    "confirm")
        # Always return true
        exit 0
        ;;
    "filter")
        # Return input
        head -n 1
        ;;
    "write")
        # Return default text
        echo "Test commit message"
        ;;
    "spin")
        # Execute command and return
        shift
        "$@"
        ;;
esac
exit 0
</file>
<file path="test/unit/mocks/jq">
#!/bin/bash
# Simple jq mock - just pass through for basic operations
cat
</file>
<file path="test/unit/test_cache_and_config.bats">
#!/usr/bin/env bats

load '../test_helper.bash'

# Test: fetch_repositories_json with refresh
@test "fetch_repositories_json with force refresh creates cache" {
    PATH="${MOCK_DIR}:${PATH}"
    rm -f "$TEST_CACHE_FILE"
    export CACHE_TTL=600
    export DEFAULT_ORG=""

    run fetch_repositories_json "true"
    [ "$status" -eq 0 ]
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: fetch_repositories_json uses cache when valid
@test "fetch_repositories_json uses cache when valid" {
    PATH="${MOCK_DIR}:${PATH}"
    # Create a valid cache file
    create_mock_json
    touch -t 202412010000 "$TEST_CACHE_FILE"

    run fetch_repositories_json "false"
    [ "$status" -eq 0 ]
}

# Test: fetch_repositories_json with organization filter
@test "fetch_repositories_json respects organization filter" {
    PATH="${MOCK_DIR}:${PATH}"
    export DEFAULT_ORG="testorg"

    run fetch_repositories_json "true" "100" "testorg"
    [ "$status" -eq 0 ]
    # Check that cache was created
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: fetch_repositories_json with invalid org (should still create cache)
@test "fetch_repositories_json handles org filter gracefully" {
    PATH="${MOCK_DIR}:${PATH}"
    rm -f "$TEST_CACHE_FILE"

    run fetch_repositories_json "true" "100" "nonexistent"
    [ "$status" -eq 0 ]
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: Configuration loading
@test "load_config respects XDG_CONFIG_HOME" {
    export XDG_CONFIG_HOME="$TEST_TMP_DIR/custom_config"
    mkdir -p "$XDG_CONFIG_HOME/ghtools"
    echo 'CUSTOM_VAR="custom_value"' > "$XDG_CONFIG_HOME/ghtools/config"

    # Reload to pick up new config dir
    CONFIG_DIR="${XDG_CONFIG_HOME}/ghtools"
    CONFIG_FILE="$CONFIG_DIR/config"

    run load_config
    [ "$status" -eq 0 ]
}

# Test: Default configuration values
@test "init_config creates default config with commented options" {
    rm -rf "$TEST_CONFIG_DIR"
    run init_config
    [ "$status" -eq 0 ]
    [ -f "$TEST_CONFIG_FILE" ]

    content=$(cat "$TEST_CONFIG_FILE")
    [[ "$content" == *"CACHE_TTL"* ]]
    [[ "$content" == *"MAX_JOBS"* ]]
    [[ "$content" == *"DEFAULT_ORG"* ]]
    [[ "$content" == *"DEFAULT_CLONE_PATH"* ]]
}

# Test: Configuration overrides
@test "load_config applies configuration overrides" {
    mkdir -p "$TEST_CONFIG_DIR"
    cat > "$TEST_CONFIG_FILE" <<EOF
CACHE_TTL=300
MAX_JOBS=10
DEFAULT_CLONE_PATH="/custom/path"
EOF

    load_config
    [ "$CACHE_TTL" = "300" ]
    [ "$MAX_JOBS" = "10" ]
    [ "$DEFAULT_CLONE_PATH" = "/custom/path" ]
}

# Test: Cache TTL validation
@test "is_cache_valid respects CACHE_TTL setting" {
    export CACHE_TTL=60  # 1 minute
    echo '{}' > "$TEST_CACHE_FILE"
    # File is 1 minute old, should be invalid
    touch -t 202412010100 "$TEST_CACHE_FILE"

    run is_cache_valid
    [ "$status" -eq 1 ]
}

@test "is_cache_valid accepts fresh cache" {
    export CACHE_TTL=3600  # 1 hour
    echo '{}' > "$TEST_CACHE_FILE"
    # File is 30 minutes old, should be valid
    touch -t 202412010030 "$TEST_CACHE_FILE"

    run is_cache_valid
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_error_handling.bats">
#!/usr/bin/env bats

load '../test_helper.bash'

# Test: check_dependencies with missing required commands
@test "check_dependencies fails with missing required command" {
    # Save original PATH
    ORIGINAL_PATH="$PATH"

    # Create empty PATH to simulate missing commands
    PATH="/nonexistent"

    run check_dependencies
    [ "$status" -eq 1 ]
    [[ "$output" == *"Missing required dependencies"* ]]

    # Restore PATH
    PATH="$ORIGINAL_PATH"
}

# Test: check_gh_auth when not authenticated
@test "check_gh_auth fails when not authenticated" {
    # Create mock gh that returns failure
    cat > "${MOCK_DIR}/gh_no_auth" <<'MOCK'
#!/bin/bash
if [ "$1" = "auth" ] && [ "$2" = "status" ]; then
    exit 1
fi
MOCK
    chmod +x "${MOCK_DIR}/gh_no_auth"

    PATH="${MOCK_DIR}:${PATH}"

    run check_gh_auth
    [ "$status" -eq 1 ]
    [[ "$output" == *"Not authenticated"* ]]
}

# Test: action_list with no repositories
@test "action_list handles empty repository list" {
    PATH="${MOCK_DIR}:${PATH}"
    # Create empty cache
    echo '[]' > "$TEST_CACHE_FILE"

    run action_list
    [ "$status" -eq 0 ]
}

# Test: action_list with failed API call
@test "action_list handles API failure gracefully" {
    PATH="${MOCK_DIR}:${PATH}"
    # Remove cache to force API call
    rm -f "$TEST_CACHE_FILE"

    # Mock gh to fail
    cat > "${MOCK_DIR}/gh_fail" <<'MOCK'
#!/bin/bash
exit 1
MOCK
    chmod +x "${MOCK_DIR}/gh_fail"
    PATH="${MOCK_DIR}:${PATH}"

    run action_list --refresh
    [ "$status" -eq 1 ]
}

# Test: action_sync with non-existent path
@test "action_sync handles non-existent path" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_sync --path "/nonexistent/path"
    [ "$status" -eq 0 ]  # Should handle gracefully, not fail
}

# Test: action_sync with no git repositories
@test "action_sync handles directory with no git repos" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/empty"
    mkdir -p "$test_dir"

    run action_sync --path "$test_dir"
    [ "$status" -eq 0 ]
    [[ "$output" == *"No git repositories found"* ]]
}

# Test: action_clone with non-existent clone path
@test "action_clone fails with non-existent path" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_clone --path "/nonexistent/path"
    [ "$status" -eq 1 ]
    [[ "$output" == *"does not exist"* ]]
}

# Test: action_create with empty name
@test "action_create handles empty name" {
    PATH="${MOCK_DIR}:${PATH}"
    cd "$TEST_TMP_DIR"

    run action_create
    [ "$status" -eq 0 ]
    # Should not crash, gum/input will handle empty input
}

# Test: truncate_text with zero limit
@test "truncate_text handles zero limit" {
    result=$(truncate_text "test" 0)
    [ ${#result} -le 0 ]
}

# Test: truncate_text with negative limit
@test "truncate_text handles negative limit" {
    result=$(truncate_text "test" -1)
    [ ${#result} -le 4 ]
}

# Test: is_cache_valid with empty file
@test "is_cache_valid handles empty file" {
    touch "$TEST_CACHE_FILE"

    run is_cache_valid
    [ "$status" -eq 1 ]
}

# Test: action_delete without delete_repo scope
@test "action_delete handles missing delete scope" {
    # Mock check_delete_scope to return false
    check_delete_scope() {
        return 1
    }

    export -f check_delete_scope

    run action_delete
    [ "$status" -eq 1 ]
}

# Test: action_pr_create not in git repository
@test "action_pr_create fails outside git repository" {
    cd "$TEST_TMP_DIR"

    run action_pr_create
    [ "$status" -eq 1 ]
    [[ "$output" == *"Not in a git repository"* ]]
}

# Test: action_pr_create on main/master branch
@test "action_pr_create detects main/master branch" {
    cd "$TEST_TMP_DIR"
    git init -q

    run action_pr_create
    [ "$status" -eq 1 ]
    [[ "$output" == *"feature branch"* ]]
}

# Test: fetch_repositories_json with limit 0
@test "fetch_repositories_json handles limit 0" {
    PATH="${MOCK_DIR}:${PATH}"

    run fetch_repositories_json "true" "0"
    [ "$status" -eq 0 ]
}

# Test: show_header with and without subtitle
@test "show_header handles optional subtitle" {
    run show_header "Test Title" "Test Subtitle"
    [ "$status" -eq 0 ]
    [[ "$output" == *"Test Title"* ]]

    run show_header "Test Title Only"
    [ "$status" -eq 0 ]
    [[ "$output" == *"Test Title Only"* ]]
}

# Test: show_divider with and without title
@test "show_divider handles optional title" {
    run show_divider "Section Title"
    [ "$status" -eq 0 ]

    run show_divider
    [ "$status" -eq 0 ]
}

# Test: print_functions with QUIET mode
@test "print_info respects QUIET mode" {
    QUIET=true
    run print_info "Test message"
    [ "$status" -eq 0 ]
    [ -z "$output" ]
}

# Test: print_verbose with VERBOSE disabled
@test "print_verbose respects VERBOSE disabled" {
    VERBOSE=false
    run print_verbose "Debug message"
    [ "$status" -eq 0 ]
    [ -z "$output" ]
}

# Test: gum_confirm with default yes
@test "gum_confirm handles default yes" {
    PATH="${MOCK_DIR}:${PATH}"
    run gum_confirm "Test prompt" "yes"
    [ "$status" -eq 0 ]
}

# Test: gum_input with default value
@test "gum_input handles default value" {
    PATH="${MOCK_DIR}:${PATH}"
    run gum_input "Placeholder" "› " "default_value"
    [ "$status" -eq 0 ]
}

# Test: gum_choose with multiple options
@test "gum_choose handles multiple options" {
    PATH="${MOCK_DIR}:${PATH}"
    run gum_choose "Choose:" "Option 1" "Option 2" "Option 3"
    [ "$status" -eq 0 ]
}

# Test: gum_filter with multi-select
@test "gum_filter handles multi-select mode" {
    PATH="${MOCK_DIR}:${PATH}"
    run gum_filter "Filter items" "true"
    [ "$status" -eq 0 ]
}

# Test: run_with_spinner
@test "run_with_spinner executes command" {
    PATH="${MOCK_DIR}:${PATH}"
    run run_with_spinner "Testing" echo "success"
    [ "$status" -eq 0 ]
    [[ "$output" == *"success"* ]]
}

# Test: wait_for_jobs with multiple jobs
@test "wait_for_jobs handles job limit" {
    # Start some background jobs
    (sleep 0.1) &
    (sleep 0.1) &
    (sleep 0.1) &

    run wait_for_jobs
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_main_entry_point.bats">
#!/usr/bin/env bats

load '../test_helper.bash'

# Helper to capture main function output
main_entry() {
    export PATH="${MOCK_DIR}:${PATH}"
    # Source ghtools and call main with provided args
    bash -c "source ${PROJECT_DIR}/ghtools && main \"\$@\"" -- "$@"
}

# Test: --help flag displays usage
@test "main shows usage with --help flag" {
    run main_entry --help
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
    [[ "$output" == *"COMMANDS"* ]]
}

# Test: -h flag displays usage
@test "main shows usage with -h flag" {
    run main_entry -h
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
}

# Test: --version flag displays version
@test "main shows version with --version flag" {
    run main_entry --version
    [ "$status" -eq 0 ]
    [[ "$output" == *"3.1.0"* ]]
}

# Test: -v flag displays version
@test "main shows version with -v flag" {
    run main_entry -v
    [ "$status" -eq 0 ]
    [[ "$output" == *"3.1.0"* ]]
}

# Test: --verbose flag enables verbose mode
@test "main accepts --verbose flag" {
    PATH="${MOCK_DIR}:${PATH}"
    VERBOSE=true
    run main_entry list --refresh
    [ "$status" -eq 0 ]
}

# Test: --quiet flag suppresses output
@test "main accepts --quiet flag" {
    PATH="${MOCK_DIR}:${PATH}"
    QUIET=true
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry list
    [ "$status" -eq 0 ]
}

# Test: list command
@test "main handles list command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry list
    [ "$status" -eq 0 ]
}

# Test: list command with --refresh
@test "main handles list --refresh" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"

    run main_entry list --refresh
    [ "$status" -eq 0 ]
}

# Test: list command with --lang filter
@test "main handles list --lang filter" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry list --lang python
    [ "$status" -eq 0 ]
}

# Test: list command with --org filter
@test "main handles list --org filter" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"

    run main_entry list --org testorg
    [ "$status" -eq 0 ]
}

# Test: clone command
@test "main handles clone command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json
    mkdir -p "$TEST_TMP_DIR/clones"

    run main_entry clone --path "$TEST_TMP_DIR/clones"
    [ "$status" -eq 0 ]
}

# Test: sync command
@test "main handles sync command" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry sync --path "$test_dir" --all
    [ "$status" -eq 0 ]
}

# Test: sync command with dry-run
@test "main handles sync --dry-run" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry sync --path "$test_dir" --dry-run --all
    [ "$status" -eq 0 ]
}

# Test: create command
@test "main handles create command" {
    PATH="${MOCK_DIR}:${PATH}"
    cd "$TEST_TMP_DIR"

    # Mock user inputs
    export GH_CREATE_NAME="test-repo"
    export GH_CREATE_DESC="Test description"
    export GH_CREATE_VIS="private"
    export GH_CREATE_TPL="none"

    run main_entry create
    [ "$status" -eq 0 ]
}

# Test: delete command
@test "main handles delete command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry delete
    [ "$status" -eq 0 ]
}

# Test: fork command
@test "main handles fork command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry fork "test query"
    [ "$status" -eq 0 ]
}

# Test: fork command with --clone
@test "main handles fork --clone" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry fork --clone "test query"
    [ "$status" -eq 0 ]
}

# Test: archive command
@test "main handles archive command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry archive
    [ "$status" -eq 0 ]
}

# Test: archive --unarchive command
@test "main handles archive --unarchive" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry archive --unarchive
    [ "$status" -eq 0 ]
}

# Test: visibility command
@test "main handles visibility command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry visibility
    [ "$status" -eq 0 ]
}

# Test: visibility --public command
@test "main handles visibility --public" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry visibility --public
    [ "$status" -eq 0 ]
}

# Test: visibility --private command
@test "main handles visibility --private" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry visibility --private
    [ "$status" -eq 0 ]
}

# Test: stats command
@test "main handles stats command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry stats
    [ "$status" -eq 0 ]
}

# Test: search command
@test "main handles search command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry search
    [ "$status" -eq 0 ]
}

# Test: browse command
@test "main handles browse command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry browse
    [ "$status" -eq 0 ]
}

# Test: explore command
@test "main handles explore command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry explore "test query"
    [ "$status" -eq 0 ]
}

# Test: explore with --sort and --lang
@test "main handles explore with options" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry explore "test query" --sort stars --lang python
    [ "$status" -eq 0 ]
}

# Test: trending command
@test "main handles trending command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry trending
    [ "$status" -eq 0 ]
}

# Test: trending with language
@test "main handles trending --lang" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry trending --lang python
    [ "$status" -eq 0 ]
}

# Test: pr command
@test "main handles pr command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry pr list
    [ "$status" -eq 0 ]
}

# Test: status command
@test "main handles status command" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry status --path "$test_dir"
    [ "$status" -eq 0 ]
}

# Test: config command
@test "main handles config command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry config
    [ "$status" -eq 0 ]
}

# Test: refresh command
@test "main handles refresh command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry refresh
    [ "$status" -eq 0 ]
}

# Test: help command
@test "main handles help command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry help
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
}

# Test: unknown command
@test "main handles unknown command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry unknown-command
    [ "$status" -eq 1 ]
    [[ "$output" == *"Unknown command"* ]]
}

# Test: multiple global flags
@test "main handles multiple global flags" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry --verbose --quiet list
    [ "$status" -eq 0 ]
}

# Test: command with multiple options
@test "main handles sync with multiple options" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry sync --path "$test_dir" --dry-run --all --max-depth 2
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_utility_functions.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables)
    source "$project_dir/test/test_helper.bash"

    # Load ghtools functions (without main)
    source "$project_dir/ghtools_functions.sh"
}

teardown() {
    teardown_test
}

# Test: use_gum function
@test "use_gum returns true when gum is available" {
    run use_gum
    [ "$status" -eq 0 ]
}

# Test: truncate_text function
@test "truncate_text returns original text when within limit" {
    result=$(truncate_text "short text" 20)
    [ "$result" = "short text" ]
}

@test "truncate_text truncates text when exceeding limit" {
    result=$(truncate_text "this is a very long text that should be truncated" 20)
    [ ${#result} -le 20 ]
    [[ "$result" == *"..."* ]]
}

@test "truncate_text handles empty input" {
    result=$(truncate_text "" 10)
    [ "$result" = "" ]
}

# Test: truncate_text edge case exactly at limit
@test "truncate_text handles text exactly at limit" {
    result=$(truncate_text "exactly ten" 11)
    [ "$result" = "exactly ten" ]
}

# Test: print_table_row function
@test "print_table_row formats output correctly" {
    run print_table_row "Column1" "Column2"
    [ "$status" -eq 0 ]
    [[ "$output" == *"Column1"* ]]
    [[ "$output" == *"Column2"* ]]
}

# Test: wait_for_jobs function
@test "wait_for_jobs runs without error" {
    run wait_for_jobs
    [ "$status" -eq 0 ]
}

# Test: is_cache_valid function
@test "is_cache_valid returns false when cache file doesn't exist" {
    rm -f "$TEST_CACHE_FILE"
    run is_cache_valid
    [ "$status" -eq 1 ]
}

@test "is_cache_valid returns false when cache is expired" {
    # Create cache file with old timestamp
    echo '{}' > "$TEST_CACHE_FILE"
    touch -t 202001010000 "$TEST_CACHE_FILE"
    run is_cache_valid
    [ "$status" -eq 1 ]
}

@test "is_cache_valid returns true when cache is valid" {
    # Create cache file with recent timestamp
    echo '{}' > "$TEST_CACHE_FILE"
    touch -t 202412010000 "$TEST_CACHE_FILE"
    run is_cache_valid
    [ "$status" -eq 0 ]
}

# Test: check_dependencies function (mock dependencies)
@test "check_dependencies passes with mocked commands" {
    PATH="${MOCK_DIR}:${PATH}"
    run check_dependencies
    [ "$status" -eq 0 ]
}

# Test: check_gh_auth function (mocked)
@test "check_gh_auth passes with mocked gh auth" {
    PATH="${MOCK_DIR}:${PATH}"
    run check_gh_auth
    [ "$status" -eq 0 ]
}

# Test: load_config function
@test "load_config loads config without error when file exists" {
    mkdir -p "$TEST_CONFIG_DIR"
    echo 'TEST_VAR="test_value"' > "$TEST_CONFIG_FILE"
    run load_config
    [ "$status" -eq 0 ]
}

@test "load_config handles missing config file" {
    rm -f "$TEST_CONFIG_FILE"
    run load_config
    [ "$status" -eq 0 ]
}

# Test: init_config function
@test "init_config creates config directory and file" {
    rm -rf "$TEST_CONFIG_DIR"
    run init_config
    [ "$status" -eq 0 ]
    [ -d "$TEST_CONFIG_DIR" ]
    [ -f "$TEST_CONFIG_FILE" ]
}

@test "init_config doesn't overwrite existing config" {
    mkdir -p "$TEST_CONFIG_DIR"
    echo 'CUSTOM_CONFIG="custom"' > "$TEST_CONFIG_FILE"
    original_content=$(cat "$TEST_CONFIG_FILE")
    run init_config
    [ "$status" -eq 0 ]
    [ "$(cat "$TEST_CONFIG_FILE")" = "$original_content" ]
}

# Test: show_usage function
@test "show_usage outputs usage information" {
    run show_usage
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
    [[ "$output" == *"COMMANDS"* ]]
    [[ "$output" == *"OPTIONS"* ]]
}
</file>
<file path="test/bats.config.bash">
#!/usr/bin/env bash

# Bats configuration file
# This file is automatically loaded by bats

# Set timeout for individual tests
export BATS_TEST_TIMEOUT=60

# Enable parallel execution if supported
if command -v parallel &>/dev/null; then
    export BATS_NO_PARALLELIZE_FOREGROUND=
fi

# Load test helper
setup() {
    # This runs before each test file
    load 'test_helper.bash'
}

# Teardown after each test file
teardown() {
    # Clean up any remaining test artifacts
    :
}
</file>
<file path="test/README.md">
# ghtools Test Suite

Esta pasta contém os testes automatizados para o projeto ghtools usando o framework [Bats](https://github.com/bats-core/bats-core).

## Estrutura dos Testes

```
test/
├── README.md                    # Esta documentação
├── test_helper.bash             # Helper functions para os testes
├── bats.config.bash             # Configuração do Bats
├── unit/                        # Testes unitários
│   ├── test_utility_functions.bats
│   ├── test_cache_and_config.bats
│   ├── test_main_entry_point.bats
│   └── test_error_handling.bats
├── integration/                 # Testes de integração
│   └── test_actions.bats
├── helpers/                     # Funções auxiliares (futuro)
└── mocks/                       # Mocks para comandos externos
    ├── gh
    ├── jq
    ├── git
    ├── fzf
    └── gum
```

## Como Executar os Testes

### Execução Completa
```bash
./run_tests.sh
```

### Execução Individual
```bash
# Executar todos os testes
bats test/**/*.bats

# Executar apenas testes unitários
bats test/unit/*.bats

# Executar apenas testes de integração
bats test/integration/*.bats

# Executar um arquivo específico
bats test/unit/test_utility_functions.bats
```

### Execução com verbose
```bash
bats --verbose test/unit/test_utility_functions.bats
```

## Estatísticas dos Testes

**Total de Testes:** 114
**Testes Passando:** 14 (12%)
**Testes Falhando:** 100 (88%)

### Testes Passando (14)
- ✅ truncate_text (5 testes)
- ✅ print_table_row
- ✅ wait_for_jobs
- ✅ is_cache_valid (cache inválido/inexistente - 3 testes)
- ✅ check_dependencies (mocked)
- ✅ check_gh_auth (mocked)
- ✅ load_config (2 testes)
- ✅ init_config (config não sobrescrito)
- ✅ show_usage

### Testes Falhando (100)
Muitos testes falham porque:
1. **Dependências Externas:** Testes que usam comandos como `gh`, `fzf`, `gum` podem falhar sem mocks adequados
2. **Interatividade:** Funções que requerem input do usuário são difíceis de testar automaticamente
3. **Funções com Efeitos Colaterais:** Algumas funções chamam outras funções internamente (ex: `main()`)
4. **Configuração de Ambiente:** Algumas variáveis não são carregadas corretamente no ambiente de teste

## Funções Testadas

### Funções Utilitárias (Unit Tests)
- `truncate_text()` - 100% pass rate
- `print_table_row()` - 100% pass rate
- `wait_for_jobs()` - 100% pass rate
- `is_cache_valid()` - 75% pass rate (3/4)
- `check_dependencies()` - 100% pass rate
- `check_gh_auth()` - 100% pass rate
- `load_config()` - 100% pass rate
- `init_config()` - 50% pass rate (1/2)
- `show_usage()` - 100% pass rate

### Testes de Integração
- `action_list`
- `action_clone`
- `action_sync`
- `action_status`
- `action_stats`
- `action_browse`
- `action_search`
- `action_fork`
- `action_explore`
- `action_trending`
- `action_archive`
- `action_visibility`
- `action_pr`
- `apply_template`

## Cobertura Estimada

**Funções Identificadas no ghtools:** 45+ funções
**Funções Testadas:** 17+ funções
**Cobertura Estimada:** ~38%

⚠️ **Meta de 80% NÃO ATINGIDA**

## Mocks Utilizados

Para testar sem depender de comandos externos, foram criados mocks para:
- `gh` - GitHub CLI
- `jq` - Processador JSON
- `git` - Sistema de controle de versão
- `fzf` - Fuzzy finder
- `gum` - Ferramenta de styling

## Recomendações para Melhorar Cobertura

### 1. Testes de Unitário (Prioridade Alta)
- Adicionar mais testes para funções de printing (`print_error`, `print_success`, etc.)
- Testar configuração de cores e estilos
- Testar parsing de argumentos
- Testar validação de entrada

### 2. Refatoração para Testabilidade (Prioridade Média)
- Separar lógica de UI da lógica de negócio
- Tornar funções mais pure (sem efeitos colaterais)
- Usar injeção de dependência para comandos externos
- Adicionar flags para modo não-interativo (`--yes`, `--no-input`)

### 3. Testes de Integração (Prioridade Média)
- Testar fluxos completos sem interatividade
- Usar mocks mais sofisticados
- Testar cenários de erro (API failures, network timeouts, etc.)

### 4. Melhorias na Infraestrutura (Prioridade Baixa)
- Configurar CI/CD para executar testes automaticamente
- Adicionar mais mocks e stubs
- Criar fixtures para dados de teste
- Implementar teste de performance

## Melhorias Implementadas

1. ✅ Framework de teste configurado (Bats)
2. ✅ Mocks para comandos externos
3. ✅ Helper functions para setup/teardown
4. ✅ Testes básicos para funções utilitárias
5. ✅ Estrutura modular de testes
6. ✅ Script de execução automatizada

## Limitações Atuais

1. **Testes Interativos:** Funções que esperam input do usuário não são facilmente testáveis
2. **Dependências Externas:** Alguns testes requerem que as ferramentas estejam instaladas
3. **Modo de Teste:** O script ghtools não tem um modo especificamente para testes
4. **Estrutura Monolítica:** Script único dificulta testes isolados

## Próximos Passos

1. Refatorar ghtools para separar funções de main()
2. Adicionar modo de teste (`ghtools --test-mode`)
3. Criar mais mocks sophisticated
4. Escrever testes para cenários de erro
5. Melhorar testes de integração
6. Adicionar testes de performance
7. Implementar cobertura real com инструменты como `shcov`

## Requisitos

- bats >= 1.5.0
- bash >= 4.0
- jq (para alguns testes)
- git (para alguns testes)

## Contribuindo

Ao adicionar novas funcionalidades ao ghtools:
1. Adicione testes соответствующие
2. Mantenha a cobertura >= 80%
3. Use mocks para dependências externas
4. Atualize este README

## Licença

Mesma licença do projeto ghtools.
</file>
<file path="test/test_helper.bash">
#!/usr/bin/env bash

# Test helper for ghtools
# This file sets up the test environment

# Get the directory where this script is located
TEST_DIR="$(cd "$(dirname "${BATS_TEST_FILENAME}")" && pwd)"
PROJECT_DIR="$(cd "${TEST_DIR}/.." && pwd)"

# Enable test mode to prevent auto-execution and strict mode issues
export GHTOOLS_TEST_MODE=1

# Source the ghtools functions (test mode prevents main execution)
source "${PROJECT_DIR}/ghtools_functions.sh" 2>/dev/null || true
export -f load_config 2>/dev/null || true
export -f init_config 2>/dev/null || true
export -f use_gum 2>/dev/null || true
export -f gum_style 2>/dev/null || true
export -f print_error 2>/dev/null || true
export -f print_success 2>/dev/null || true
export -f print_info 2>/dev/null || true
export -f print_warning 2>/dev/null || true
export -f print_verbose 2>/dev/null || true
export -f show_header 2>/dev/null || true
export -f show_divider 2>/dev/null || true
export -f run_with_spinner 2>/dev/null || true
export -f gum_confirm 2>/dev/null || true
export -f gum_input 2>/dev/null || true
export -f gum_choose 2>/dev/null || true
export -f gum_filter 2>/dev/null || true
export -f gum_write 2>/dev/null || true
export -f print_table_row 2>/dev/null || true
export -f show_usage 2>/dev/null || true
export -f check_dependencies 2>/dev/null || true
export -f check_gh_auth 2>/dev/null || true
export -f is_cache_valid 2>/dev/null || true
export -f fetch_repositories_json 2>/dev/null || true
export -f wait_for_jobs 2>/dev/null || true
export -f truncate_text 2>/dev/null || true
export -f action_list 2>/dev/null || true
export -f action_clone 2>/dev/null || true
export -f action_sync 2>/dev/null || true
export -f check_delete_scope 2>/dev/null || true
export -f action_delete 2>/dev/null || true
export -f action_create 2>/dev/null || true
export -f apply_template 2>/dev/null || true
export -f action_fork 2>/dev/null || true
export -f action_explore 2>/dev/null || true
export -f action_trending 2>/dev/null || true
export -f action_archive 2>/dev/null || true
export -f action_stats 2>/dev/null || true
export -f action_search 2>/dev/null || true
export -f action_browse 2>/dev/null || true
export -f action_visibility 2>/dev/null || true
export -f action_pr 2>/dev/null || true
export -f action_pr_list 2>/dev/null || true
export -f action_pr_create 2>/dev/null || true
export -f action_status 2>/dev/null || true
export -f show_menu 2>/dev/null || true

# Set up test environment variables
export TEST_MODE=1
export TEST_TMP_DIR="${BATS_TMPDIR:-/tmp}/ghtools_test_$$"
export TEST_CACHE_FILE="${TEST_TMP_DIR}/test_repos.json"
export TEST_CONFIG_DIR="${TEST_TMP_DIR}/config"
export TEST_CONFIG_FILE="${TEST_CONFIG_DIR}/config"

# Override ghtools global variables to use test paths
export CACHE_FILE="$TEST_CACHE_FILE"
export CONFIG_DIR="$TEST_CONFIG_DIR"
export CONFIG_FILE="$TEST_CONFIG_FILE"
export CACHE_TTL=600
export MAX_JOBS=2
export VERBOSE=false
export QUIET=true

# Create test directory
mkdir -p "$TEST_TMP_DIR"
mkdir -p "$TEST_CONFIG_DIR"

# Mock directory for simulating external commands
export MOCK_DIR="${TEST_DIR}/mocks"
mkdir -p "$MOCK_DIR"

# Make mocks executable
chmod +x "$MOCK_DIR"/*

# Function to create a temporary git repository for testing
create_test_git_repo() {
    local repo_dir="$1"
    mkdir -p "$repo_dir"
    cd "$repo_dir"
    git init -q
    echo "test" > test.txt
    git add test.txt
    git commit -q -m "Initial commit"
}

# Function to create mock JSON response
create_mock_json() {
    cat > "$TEST_CACHE_FILE" <<'EOF'
[
  {
    "name": "test-repo",
    "nameWithOwner": "user/test-repo",
    "description": "A test repository",
    "visibility": "PUBLIC",
    "primaryLanguage": {
      "name": "bash"
    },
    "stargazerCount": 10,
    "forkCount": 2,
    "diskUsage": 100,
    "updatedAt": "2024-01-01T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/test-repo",
    "sshUrl": "git@github.com:user/test-repo.git"
  },
  {
    "name": "private-repo",
    "nameWithOwner": "user/private-repo",
    "description": "A private test repository",
    "visibility": "PRIVATE",
    "primaryLanguage": {
      "name": "python"
    },
    "stargazerCount": 5,
    "forkCount": 1,
    "diskUsage": 200,
    "updatedAt": "2024-01-02T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/private-repo",
    "sshUrl": "git@github.com:user/private-repo.git"
  }
]
EOF
}

# Function to setup mock gh command
setup_mock_gh() {
    cat > "${MOCK_DIR}/gh" <<'MOCK_SCRIPT'
#!/bin/bash
case "$1" in
    "auth")
        if [ "$2" = "status" ]; then
            echo "github.com
  Logged in to github.com as user (oauth_token)
  Git operations done over the http on api.github.com
  Active user: user"
            exit 0
        fi
        ;;
    "repo")
        case "$2" in
            "list")
                if [ "$3" = "--limit" ]; then
                    # Output mock repository data
                    echo "user/test-repo"
                    echo "user/private-repo"
                fi
                ;;
            "clone")
                echo "Mock clone of $3"
                exit 0
                ;;
            "create")
                echo "Mock create of $3"
                exit 0
                ;;
            "delete")
                echo "Mock delete of $3"
                exit 0
                ;;
            "edit")
                echo "Mock edit of $3"
                exit 0
                ;;
        esac
        ;;
    "search")
        if [ "$1" = "search" ] && [ "$2" = "repos" ]; then
            # Output mock search results
            echo "example/repo1"
            echo "example/repo2"
        fi
        ;;
    "api")
        # Mock API calls
        if [[ "$*" == *"user/starred"* ]]; then
            echo "Mock starred"
            exit 0
        fi
        ;;
esac
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/gh"
}

# Function to setup mock jq command
setup_mock_jq() {
    cat > "${MOCK_DIR}/jq" <<'MOCK_SCRIPT'
#!/bin/bash
# Simple jq mock - just pass through for basic operations
cat
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/jq"
}

# Function to setup mock git command
setup_mock_git() {
    cat > "${MOCK_DIR}/git" <<'MOCK_SCRIPT'
#!/bin/bash
case "$1" in
    "init")
        mkdir -p "$2/.git"
        echo "Initialized empty Git repository in $2/.git/"
        exit 0
        ;;
    "add")
        exit 0
        ;;
    "commit")
        echo "[master (root-commit) 1234567] Test commit"
        exit 0
        ;;
    "branch")
        if [ "$1" = "branch" ] && [ "$2" = "--show-current" ]; then
            echo "main"
            exit 0
        fi
        if [ "$1" = "branch" ]; then
            echo "* main"
            exit 0
        fi
        ;;
    "diff-index")
        # Pretend working tree is clean
        exit 0
        ;;
    "fetch")
        exit 0
        ;;
    "pull")
        echo "Already up to date."
        exit 0
        ;;
    "push")
        echo "Everything up-to-date"
        exit 0
        ;;
    "ls-remote")
        # Pretend remote branch exists
        exit 0
        ;;
    "rev-list")
        echo "0"
        exit 0
        ;;
esac
# Default: succeed
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/git"
}

# Function to setup mock fzf command
setup_mock_fzf() {
    cat > "${MOCK_DIR}/fzf" <<'MOCK_SCRIPT'
#!/bin/bash
# Mock fzf - just select first line or echo input
if [ "$*" == *"--multi"* ]; then
    # Multi-select mode - return all lines
    cat
else
    # Single select - return first line
    head -n 1
fi
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/fzf"
}

# Function to setup mock gum command
setup_mock_gum() {
    cat > "${MOCK_DIR}/gum" <<'MOCK_SCRIPT'
#!/bin/bash
# Mock gum - just echo the text or return first line for choose
case "$1" in
    "style")
        # Just output the text
        shift
        echo "$@"
        ;;
    "choose")
        # Return first option
        head -n 1
        ;;
    "input")
        # Return default or echo input
        if [[ "$*" == *"--value"* ]]; then
            # Get default value
            echo "default"
        else
            read -r input
            echo "${input:-default}"
        fi
        ;;
    "confirm")
        # Always return true
        exit 0
        ;;
    "filter")
        # Return input
        head -n 1
        ;;
    "write")
        # Return default text
        echo "Test commit message"
        ;;
    "spin")
        # Execute command and return
        shift
        "$@"
        ;;
esac
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/gum"
}

# Teardown function to clean up after each test
teardown_test() {
    # Clean up test directory
    rm -rf "$TEST_TMP_DIR"
}

# Add MOCK_DIR to PATH for tests
export PATH="${MOCK_DIR}:${PATH}"

# Setup mocks before each test
setup() {
    # Create fresh test environment
    mkdir -p "$TEST_TMP_DIR"
    setup_mock_gh
    setup_mock_jq
    setup_mock_git
    setup_mock_fzf
    setup_mock_gum
}

# Teardown after each test
teardown() {
    teardown_test
}
</file>
<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
The CLI entry point lives in `ghtools`, a Bash script that wires the interactive menu, direct subcommands, and all helper functions. Installation automation and PATH hygiene are handled in `install.sh`. Supporting docs and product specs sit under `PRPs/` and `SPEC_PRP/`; keep internal planning material there rather than alongside the executable script. There is no compiled output or build artifact committed to the repo—new assets should follow the same convention.

## Build, Test, and Development Commands
Run `./install.sh` to copy the CLI into `~/scripts` and ensure PATH hooks stay deduplicated. Use `./ghtools help` or `./ghtools list --help` while developing to verify argument parsing. Lint changes locally with `shellcheck ghtools` and `shellcheck install.sh`; resolve warnings before opening a PR. When iterating on command flows, call `./ghtools sync --dry-run --path <dir>` or `./ghtools delete` inside a sandbox repo to validate prompts without mutating production repositories.

## Coding Style & Naming Conventions
Scripts are POSIX-friendly but assume Bash; keep `#!/bin/bash` and `set -euo pipefail` at the top of new modules. Indent with four spaces, prefer snake_case for functions (`check_dependencies`) and ALL_CAPS for constants (color codes, paths). Echo user-facing messages through the provided `print_*` helpers so color formatting stays consistent. When adding flags, mirror the existing long-option style (`--dry-run`, `--max-depth`) and document them in both `show_usage` and the README.

## Testing Guidelines
There is no automated test harness yet, so exercise new logic manually with `gh auth status` confirmed and a GitHub test account when possible. Validate list/clone/sync flows against repositories with varied visibility to catch edge cases, and always include a `--dry-run` pathway for destructive commands. If a feature depends on GitHub scopes (e.g., `delete_repo`), add an explicit check similar to `check_delete_scope` and describe the requirement in the README update.

## Commit & Pull Request Guidelines
Commit messages follow a `Type: concise summary` pattern (see `Refactor: Replace ghclone and ghdelete with unified ghtools`). Keep subject lines under 72 characters and wrap additional context in the body when needed. Squash cosmetic commits before pushing. Pull requests should link related issues, summarize verification steps (`shellcheck`, manual command matrix), and note any auth scopes or environment impacts. Include screenshots or terminal captures only when they clarify interactive changes; otherwise reference exact commands exercised.

## Security & Configuration Notes
Authenticate early with `gh auth login` and refresh scopes via `gh auth refresh -s delete_repo` before testing deletion. Avoid hardcoding tokens or organization names; pass them through existing prompts or environment variables. When adding filesystem writes, respect the current `$HOME/scripts` install target and warn users before creating or overwriting files outside that directory.
</file>
<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development

- **Type**: Bash script (no compilation required)
- **Run**: `./ghtools` or `bash ghtools`
- **Install**: `./install.sh` (installs to `~/scripts` and updates PATH)
- **Dependencies**: `gh` (GitHub CLI), `fzf`, `jq`, `git`
- **Test**: Manual testing of commands (e.g., `./ghtools list --dry-run` where applicable, though most commands interact with live GitHub API)

## Architecture

- **Core Script**: `ghtools` is a monolithic bash script.
- **State Management**:
  - Caches GitHub repo data in `/tmp/ghtools_repos.json` (TTL: 10 mins).
  - Environment variables control behavior (`MAX_JOBS`, `CACHE_TTL`).
- **Key Functions**:
  - `main`: Entry point, handles argument parsing and routing.
  - `action_*`: Implementations for specific commands (list, clone, sync, create, delete).
  - `fetch_repositories_json`: Handles API calls to GitHub and caching.
  - `wait_for_jobs`: Manages parallelism for bulk operations (clone/sync).
- **UI/UX**:
  - Uses `fzf` for interactive selection menus.
  - Uses ANSI escape codes for colored output (`print_error`, `print_success`, etc.).
  - Uses `jq` for parsing and formatting JSON data from GitHub API.
- **Installation**: `install.sh` handles dependency checking, file copying, and shell configuration (zsh support).

## Code Style

- **Strict Mode**: Scripts use `set -uo pipefail`.
- **Formatting**: Indentation is 2 spaces.
- **Output**: Use helper functions `print_info`, `print_success`, `print_warning`, `print_error` for consistency.
- **Safety**:
  - Destructive actions (delete) require explicit confirmation and scope checks.
  - Sync uses `pull --ff-only` to prevent accidental merges.
</file>
<file path="ghtools">
#!/bin/bash

# ghtools - Unified GitHub repository management tool (Refactored)
# Version: 3.1.0
# Requires: gh (GitHub CLI), gum, fzf, jq, git

set -euo pipefail

# --- Version ---
VERSION="3.2.0"

# --- Default Configuration ---
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ghtools"
CONFIG_FILE="$CONFIG_DIR/config"
# Include user ID in cache filename for multi-user support
CACHE_FILE="/tmp/ghtools_repos_$(id -u).json"
CACHE_TTL=600     # 10 minutes (in seconds)
MAX_JOBS=5        # Parallel jobs for sync/clone
VERBOSE=false
QUIET=false

# --- Load User Config ---
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Security: Validate config file contains only allowed variable assignments
        local allowed_vars="CACHE_TTL|CACHE_FILE|MAX_JOBS|DEFAULT_ORG|DEFAULT_CLONE_PATH"
        # Check for lines that are not: empty, comments, or allowed variable assignments
        if grep -Evq "^[[:space:]]*(#.*)?$|^[[:space:]]*($allowed_vars)=" "$CONFIG_FILE"; then
            # Config contains potentially dangerous content - show warning and skip
            echo -e "\033[1;33m[WARNING]\033[0m Config file contains invalid lines. Skipping: $CONFIG_FILE" >&2
            echo -e "\033[1;33m[WARNING]\033[0m Allowed variables: CACHE_TTL, CACHE_FILE, MAX_JOBS, DEFAULT_ORG, DEFAULT_CLONE_PATH" >&2
            return 1
        fi
        # Check permissions (should be 600 or 644)
        local perms
        perms=$(stat -c %a "$CONFIG_FILE" 2>/dev/null || stat -f %Lp "$CONFIG_FILE" 2>/dev/null)
        if [[ "$perms" =~ [0-7][2367][0-7] ]]; then
            echo -e "\033[1;33m[WARNING]\033[0m Config file is world/group writable. Fix: chmod 600 $CONFIG_FILE" >&2
        fi
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

# Create default config if not exists
init_config() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" <<'EOF'
# ghtools configuration file
# Uncomment and modify as needed

# Cache settings
#CACHE_TTL=600        # Cache time-to-live in seconds (default: 600)
#CACHE_FILE="/tmp/ghtools_repos_UID.json"  # UID is auto-appended for multi-user support

# Parallel jobs for sync/clone operations
#MAX_JOBS=5

# Default organization filter (leave empty for all)
#DEFAULT_ORG=""

# Default clone path (leave empty for current directory)
#DEFAULT_CLONE_PATH=""
EOF
        print_info "Created default config at $CONFIG_FILE"
    fi
}

load_config

# --- Color Scheme (Modern Purple/Cyan Theme) ---
# Primary colors
COLOR_PRIMARY="99"      # Soft purple
COLOR_SECONDARY="39"    # Cyan
COLOR_ACCENT="212"      # Pink
COLOR_SUCCESS="78"      # Green
COLOR_WARNING="220"     # Yellow/Gold
COLOR_ERROR="196"       # Red
COLOR_INFO="75"         # Light blue
COLOR_MUTED="240"       # Gray

# Legacy colors for compatibility
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Gum Style Helpers ---

# Check if gum is available and terminal supports it
use_gum() {
  command -v gum &>/dev/null && [[ -t 1 ]]
}

# Styled text output
gum_style() {
  local text="$1"
  local fg="${2:-$COLOR_PRIMARY}"
  local bold="${3:-false}"

  if use_gum; then
    if [[ "$bold" == "true" ]]; then
      gum style --foreground "$fg" --bold "$text"
    else
      gum style --foreground "$fg" "$text"
    fi
  else
    echo "$text"
  fi
}

# --- Utility Functions ---

print_error() {
  if use_gum && [[ "$QUIET" != "true" ]]; then
    gum style --foreground "$COLOR_ERROR" --bold "✗ ERROR" | tr -d '\n'
    echo " $1" >&2
  else
    echo -e "${RED}[ERROR]${NC} $1" >&2
  fi
}

print_success() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_SUCCESS" --bold "✓ SUCCESS" | tr -d '\n'
    echo " $1"
  else
    echo -e "${GREEN}[SUCCESS]${NC} $1"
  fi
}

print_info() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_INFO" "ℹ INFO" | tr -d '\n'
    echo " $1"
  else
    echo -e "${BLUE}[INFO]${NC} $1"
  fi
}

print_warning() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_WARNING" --bold "⚠ WARNING" | tr -d '\n'
    echo " $1"
  else
    echo -e "${YELLOW}[WARNING]${NC} $1"
  fi
}

print_verbose() {
  [[ "$VERBOSE" != "true" ]] && return 0
  if use_gum; then
    gum style --foreground "$COLOR_MUTED" "◦ DEBUG" | tr -d '\n'
    echo " $1"
  else
    echo -e "${CYAN}[DEBUG]${NC} $1"
  fi
}

# Beautiful header/banner
show_header() {
  local title="$1"
  local subtitle="${2:-}"

  if use_gum; then
    echo ""
    if [[ -n "$subtitle" ]]; then
      gum style \
        --border rounded \
        --border-foreground "$COLOR_PRIMARY" \
        --foreground "$COLOR_SECONDARY" \
        --align center \
        --width 60 \
        --padding "1 2" \
        --margin "0 2" \
        "$title" "$subtitle"
    else
      gum style \
        --border rounded \
        --border-foreground "$COLOR_PRIMARY" \
        --foreground "$COLOR_SECONDARY" \
        --align center \
        --width 60 \
        --padding "1 2" \
        --margin "0 2" \
        "$title"
    fi
    echo ""
  else
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}                    $title${NC}"
    [[ -n "$subtitle" ]] && echo -e "${CYAN}                    $subtitle${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
  fi
}

# Section divider
show_divider() {
  local title="${1:-}"
  if use_gum; then
    if [[ -n "$title" ]]; then
      gum style --foreground "$COLOR_MUTED" --bold "─── $title ───"
    else
      gum style --foreground "$COLOR_MUTED" "────────────────────────────────────────"
    fi
  else
    if [[ -n "$title" ]]; then
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
      echo -e "${CYAN}                      $title${NC}"
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
    else
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
    fi
  fi
}

# Spinner for long operations
# Usage: run_with_spinner "Title" command arg1 arg2 ...
run_with_spinner() {
  local title="$1"
  shift
  # Execute directly the command passed as separate arguments (no eval)

  if use_gum; then
    gum spin --spinner dot --spinner.foreground "$COLOR_ACCENT" --title "$title" -- "$@"
  else
    echo -n "$title... "
    if "$@"; then
      echo "done"
    else
      echo "failed"
      return 1
    fi
  fi
}

# Interactive confirmation
gum_confirm() {
  local prompt="$1"
  local default="${2:-no}"

  if use_gum; then
    if [[ "$default" == "yes" ]]; then
      gum confirm --affirmative "Yes" --negative "No" --default=true \
        --prompt.foreground "$COLOR_WARNING" "$prompt"
    else
      gum confirm --affirmative "Yes" --negative "No" --default=false \
        --prompt.foreground "$COLOR_WARNING" "$prompt"
    fi
  else
    local response
    read -p "$prompt [y/N]: " response
    [[ "$response" =~ ^[Yy]$ ]]
  fi
}

# Interactive input
gum_input() {
  local placeholder="$1"
  local prompt="${2:-› }"
  local default="${3:-}"

  if use_gum; then
    gum input --placeholder "$placeholder" \
      --prompt "$prompt" \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT" \
      --value "$default"
  else
    local response
    read -p "$prompt$placeholder: " response
    echo "${response:-$default}"
  fi
}

# Interactive choice
gum_choose() {
  local header="$1"
  shift
  local options=("$@")

  if use_gum; then
    printf '%s\n' "${options[@]}" | gum choose \
      --header "$header" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY"
  else
    printf '%s\n' "${options[@]}" | fzf --header="$header" --height=40%
  fi
}

# Interactive filter (fuzzy search)
gum_filter() {
  local placeholder="$1"
  local multi="${2:-false}"

  if use_gum; then
    local args=(
      --placeholder "$placeholder"
      --prompt "› "
      --prompt.foreground "$COLOR_PRIMARY"
      --cursor.foreground "$COLOR_ACCENT"
      --match.foreground "$COLOR_SUCCESS"
      --indicator "›"
      --indicator.foreground "$COLOR_ACCENT"
    )
    [[ "$multi" == "true" ]] && args+=(--no-limit)
    gum filter "${args[@]}"
  else
    local fzf_args=(--height=50% --border)
    [[ "$multi" == "true" ]] && fzf_args+=(--multi)
    fzf "${fzf_args[@]}" --header="$placeholder"
  fi
}

# Write/text area input
gum_write() {
  local placeholder="$1"

  if use_gum; then
    gum write --placeholder "$placeholder" \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --char-limit 0
  else
    local text
    echo "$placeholder (Ctrl+D to finish):"
    text=$(cat)
    echo "$text"
  fi
}

# Table-like output row
print_table_row() {
  local col1="$1"
  local col2="$2"
  local col1_width="${3:-30}"
  local col1_color="${4:-$COLOR_SECONDARY}"

  if use_gum; then
    local styled_col1
    styled_col1=$(gum style --foreground "$col1_color" "$(printf "%-${col1_width}s" "$col1")")
    echo "$styled_col1 $col2"
  else
    printf "%b%-${col1_width}s%b %s\n" "$CYAN" "$col1" "$NC" "$col2"
  fi
}

show_usage() {
    cat <<EOF
${GREEN}ghtools${NC} - Unified GitHub repository management tool

${YELLOW}USAGE:${NC}
    ghtools [OPTIONS] <COMMAND> [ARGS]

${YELLOW}COMMANDS:${NC}
    ${GREEN}Repository Management:${NC}
    list [--refresh] [--lang <lang>] [--org <org>]
                        List repositories with optional filters
    clone [--path <dir>]
                        Clone repositories interactively
    create              Create a new repository
    delete              Delete repositories interactively
    fork [--clone] <query>
                        Fork external repositories
    archive [--unarchive]
                        Archive or unarchive repositories
    visibility [--public|--private]
                        Change repository visibility

    ${GREEN}Local Repository Operations:${NC}
    sync [--path <dir>] [--dry-run] [--all] [--max-depth <n>]
                        Sync local repositories with remote
    status [--path <dir>]
                        Show status of local repositories

    ${GREEN}Discovery & Navigation:${NC}
    search              Interactive fuzzy search with actions
    browse              Open repositories in browser
    stats               Show repository statistics dashboard
    explore [--sort <s>] [--lang <l>] <query>
                        Search external GitHub repositories
    trending [--lang <l>]
                        Show trending repositories

    ${GREEN}Pull Requests:${NC}
    pr list             List PRs for a repository
    pr create           Create PR from current branch

    ${GREEN}Utilities:${NC}
    refresh             Clear the repository cache
    config              Initialize/show config file location
    help                Show this help message

${YELLOW}OPTIONS:${NC}
    -h, --help          Show this help message
    -v, --version       Show version
    -V, --verbose       Enable verbose output
    -q, --quiet         Suppress non-error output

${YELLOW}EXAMPLES:${NC}
    ghtools list --lang python --org myorg
    ghtools clone --path ~/projects
    ghtools sync --dry-run --all
    ghtools fork --clone "react hooks"
    ghtools archive --unarchive
    ghtools visibility --private
    ghtools status --path ~/dev
    ghtools pr create
    ghtools explore "machine learning" --lang python
    ghtools trending --lang rust

${YELLOW}CONFIG:${NC}
    Config file: \$XDG_CONFIG_HOME/ghtools/config (or ~/.config/ghtools/config)

EOF
}

check_dependencies() {
  local missing_deps=()
  local optional_deps=()

  # Required dependencies
  for cmd in gh fzf git jq; do
    if ! command -v "$cmd" &>/dev/null; then
      missing_deps+=("$cmd")
    fi
  done

  # Optional but recommended (gum for beautiful UI)
  if ! command -v gum &>/dev/null; then
    optional_deps+=("gum")
  fi

  if [ ${#missing_deps[@]} -ne 0 ]; then
    print_error "Missing required dependencies:"
    printf "  - %s\n" "${missing_deps[@]}"
    echo ""
    echo "Install via Arch Linux:"
    echo "  sudo pacman -S github-cli fzf git jq gum"
    exit 1
  fi

  if [ ${#optional_deps[@]} -ne 0 ]; then
    print_warning "Optional dependencies missing (for enhanced UI):"
    printf "  - %s\n" "${optional_deps[@]}"
    echo ""
    echo "Install for beautiful UI: sudo pacman -S gum"
    echo ""
  fi
}

check_gh_auth() {
  if ! gh auth status &>/dev/null; then
    print_error "Not authenticated with GitHub CLI. Run: gh auth login"
    exit 1
  fi
}

# --- Caching Mechanism ---

is_cache_valid() {
  if [ -f "$CACHE_FILE" ]; then
    local file_time current_time age
    file_time=$(date -r "$CACHE_FILE" +%s)
    current_time=$(date +%s)
    age=$((current_time - file_time))
    if [ "$age" -lt "$CACHE_TTL" ]; then
      return 0
    fi
  fi
  return 1
}

fetch_repositories_json() {
  local force_refresh="${1:-false}"
  local limit="${2:-1000}"
  local org_filter="${3:-${DEFAULT_ORG:-}}"
  local fields="name,nameWithOwner,description,visibility,primaryLanguage,stargazerCount,forkCount,diskUsage,updatedAt,createdAt,isArchived,url,sshUrl"

  # Build command as array (avoid eval/word splitting issues)
  local cmd_args=("gh" "repo" "list")
  if [ -n "$org_filter" ]; then
    cmd_args+=("$org_filter")
    print_verbose "Filtering by organization: $org_filter"
  fi

  if [ "$force_refresh" = "true" ] || ! is_cache_valid; then
    print_info "Fetching repositories from GitHub API..." >&2
    local error_output
    error_output=$(mktemp)

    # Use umask 077 to ensure cache file has secure permissions (600)
    if ! (umask 077 && "${cmd_args[@]}" --limit "$limit" --json "$fields" >"$CACHE_FILE") 2>"$error_output"; then
      print_error "Failed to fetch repositories."
      if [ -s "$error_output" ]; then
        print_error "Details: $(cat "$error_output")"
      fi
      rm -f "$error_output"
      exit 1
    fi
    rm -f "$error_output"
    print_verbose "Fetched $(jq length "$CACHE_FILE") repositories"
  else
    print_info "Using cached repository list ($(date -r "$CACHE_FILE" '+%H:%M:%S'))" >&2
  fi

  cat "$CACHE_FILE"
}

# --- Helper Functions ---

# Job control for parallelism
wait_for_jobs() {
  local current_jobs
  current_jobs=$(jobs -p | wc -l)
  if [ "$current_jobs" -ge "$MAX_JOBS" ]; then
    # Use wait -n (Bash 4.3+), fallback to wait for older versions
    wait -n 2>/dev/null || wait
  fi
}

truncate_text() {
  local input="$1"
  local max="$2"
  if [ "${#input}" -gt "$max" ]; then
    echo "${input:0:$((max - 3))}..."
  else
    echo "$input"
  fi
}

# --- Action: List ---

action_list() {
  local refresh="false"
  local filter_lang=""
  local filter_org=""

  # Simple args parsing for list
  while [[ $# -gt 0 ]]; do
    case $1 in
    --refresh)
      refresh="true"
      shift
      ;;
    --lang)
      filter_lang="$2"
      shift 2
      ;;
    --org)
      filter_org="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "$refresh" "1000" "$filter_org")

  # Filter by language if requested
  if [ -n "$filter_lang" ]; then
    json=$(echo "$json" | jq --arg lang "$filter_lang" '[.[] | select(.primaryLanguage.name != null and (.primaryLanguage.name | ascii_downcase) == ($lang | ascii_downcase))]')
  fi

  # Output Table using pure JQ + printf (Faster/Cleaner)
  echo ""
  printf "%b%-30s %-40s %-10s %-10s %-15s%b\n" "$CYAN" "NAME" "DESCRIPTION" "VISIBILITY" "LANG" "UPDATED" "$NC"
  printf "%b%s%b\n" "$CYAN" "$(printf '%*s' 110 '' | tr ' ' '-')" "$NC"

  echo "$json" | jq -r '.[] | [.nameWithOwner, (.description // "No description"), .visibility, (.primaryLanguage.name // "-"), .updatedAt] | @tsv' |
    while IFS=$'\t' read -r name desc vis lang updated; do
      local d_name=$(truncate_text "$name" 30)
      local d_desc=$(truncate_text "$desc" 40)
      local d_updated=$(date -d "$updated" '+%Y-%m-%d' 2>/dev/null || echo "$updated")

      local color="$NC"
      [[ "$vis" == "PUBLIC" ]] && color="$GREEN"
      [[ "$vis" == "PRIVATE" ]] && color="$YELLOW"

      printf "%b%-30s%b %-40s %b%-10s%b %-10s %-15s\n" \
        "$BLUE" "$d_name" "$NC" "$d_desc" "$color" "$vis" "$NC" "$lang" "$d_updated"
    done
  echo ""
}

# --- Action: Clone ---

action_clone() {
  local clone_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      clone_path="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  # Validate clone path
  if [ ! -d "$clone_path" ]; then
    print_error "Clone path does not exist: $clone_path"
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  print_info "Select repositories to CLONE (TAB to multi-select):"
  print_info "Clone destination: $clone_path"

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="TAB: select | ENTER: confirm | Dest: $clone_path" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  echo ""
  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  local total=${#repos[@]}
  local current=0
  print_info "Cloning $total repositories in parallel ($MAX_JOBS threads)..."

  for repo in "${repos[@]}"; do
    wait_for_jobs
    (
      local repo_name
      repo_name=$(basename "$repo")
      local target_dir="$clone_path/$repo_name"
      
      if [ -d "$target_dir" ]; then
        print_warning "Skipped $repo (Directory exists)"
      else
        print_verbose "Cloning $repo to $target_dir"
        if gh repo clone "$repo" "$target_dir" &>/dev/null; then
          print_success "Cloned: $repo"
        else
          print_error "Failed: $repo"
        fi
      fi
    ) &
    ((current++)) || true
    # Progress indicator
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories queued..." "$current" "$total" >&2
  done
  wait
  echo "" >&2
  print_success "All clone operations completed."
}

# --- Action: Sync ---

action_sync() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local dry_run=false
  local sync_all=false
  local max_depth=3

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    --all)
      sync_all=true
      shift
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *)
      # Legacy: first positional arg is path
      if [ -d "$1" ]; then
        base_path="$1"
      fi
      shift
      ;;
    esac
  done

  print_info "Scanning for git repositories in $base_path..."
  print_verbose "Max depth: $max_depth, Dry run: $dry_run, Sync all: $sync_all"

  # Find git dirs
  local git_dirs
  # Use -print0 and xargs -0 to handle paths with spaces correctly
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune -print0 2>/dev/null | xargs -0 -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found."
    return
  fi

  print_info "Found ${#git_dirs[@]} repositories"

  local selected_paths
  if [ "$sync_all" = "true" ]; then
    # Non-interactive: sync all found repos
    selected_paths=$(printf "%s\n" "${git_dirs[@]}")
  else
    # Interactive selection
    selected_paths=$(printf "%s\n" "${git_dirs[@]}" |
      fzf --multi --height=40% --border --header="Select repos to SYNC (--all to skip)" --prompt="Repos > ")
  fi

  [ -z "$selected_paths" ] && return

  local total
  total=$(echo "$selected_paths" | wc -l)
  local current=0

  print_info "Syncing $total repositories in parallel..."
  [ "$dry_run" = "true" ] && print_warning "DRY-RUN mode: no changes will be made"

  while IFS= read -r repo_path; do
    wait_for_jobs
    (
      repo_name=$(basename "$repo_path")
      
      # Check for dirty state
      if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "Skipped $repo_name (Dirty state)"
        exit 0
      fi

      if [ "$dry_run" = "true" ]; then
        # Dry run: just fetch and show what would happen
        git -C "$repo_path" fetch --quiet 2>/dev/null || true
        local behind
        behind=$(git -C "$repo_path" rev-list HEAD..@{u} --count 2>/dev/null || echo "0")
        if [ "$behind" -gt 0 ]; then
          print_info "[DRY-RUN] Would pull $behind commits: $repo_name"
        else
          echo -e "${CYAN}[DRY-RUN]${NC} Already up to date: $repo_name"
        fi
      else
        # Actual sync
        if output=$(git -C "$repo_path" pull --ff-only 2>&1); then
          if [[ "$output" == *"Already up to date"* ]]; then
            echo -e "${CYAN}[NO CHANGE]${NC} $repo_name"
          else
            print_success "Synced: $repo_name"
          fi
        else
          print_error "Failed: $repo_name (Conflict or Diverged)"
        fi
      fi
    ) &
    ((current++)) || true
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories processing..." "$current" "$total" >&2
  done <<<"$selected_paths"

  wait
  echo "" >&2
  print_success "Sync completed."
}

# --- Action: Delete ---

check_delete_scope() {
  if ! gh auth status 2>&1 | grep -q "delete_repo"; then
    print_error "Missing 'delete_repo' scope required for repository deletion."
    echo ""
    read -p "Would you like to refresh auth with delete_repo scope? [y/N]: " response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      print_info "Running: gh auth refresh -s delete_repo"
      if gh auth refresh -s delete_repo; then
        print_success "Auth scope updated successfully."
        return 0
      else
        print_error "Failed to update auth scope."
        return 1
      fi
    else
      print_warning "Cannot proceed without delete_repo scope."
      return 1
    fi
  fi
  return 0
}

action_delete() {
  check_dependencies

  # Check delete scope - block if not available
  if ! check_delete_scope; then
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --multi --height=40% --border --header="SELECT REPOS TO DELETE (NO UNDO)" --color='pointer:red,marker:red,header:red')

  [ -z "$selected" ] && return

  local repos=()
  while read -r repo; do repos+=("$repo"); done <<<"$selected"

  echo ""
  print_warning "You are about to delete ${#repos[@]} repositories:"
  printf "  - ${RED}%s${NC}\n" "${repos[@]}"
  echo ""

  read -p "Type 'DELETE' to confirm, or anything else for Dry Run: " confirm
  local dry_run=true
  if [ "$confirm" == "DELETE" ]; then
    dry_run=false
  fi

  for repo in "${repos[@]}"; do
    if [ "$dry_run" = "true" ]; then
      print_info "[DRY-RUN] Would delete: $repo"
    else
      echo -e "${RED}[DELETING]${NC} $repo"
      if gh repo delete "$repo" --yes; then
        print_success "Deleted: $repo"
      else
        print_error "Failed to delete: $repo"
      fi
    fi
  done

  if [ "$dry_run" != "true" ]; then
    rm -f "$CACHE_FILE"
    print_info "Cache cleared (repo deleted)"
  fi
}

# --- Action: Create (Simplified) ---

action_create() {
  show_header "CREATE REPOSITORY" "Set up a new GitHub repository"

  # Get repository name
  local name
  if use_gum; then
    name=$(gum input --placeholder "Repository name" \
      --prompt "› " \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT")
  else
    read -p "Repository Name: " name
  fi

  if [ -z "$name" ]; then
    print_error "Name required"
    return
  fi

  # Get description
  local desc
  if use_gum; then
    desc=$(gum input --placeholder "Description (optional)" \
      --prompt "› " \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT")
  else
    read -p "Description: " desc
  fi

  # Select visibility
  local vis
  if use_gum; then
    vis=$(gum choose --header "Visibility:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      "public" "private")
  else
    vis=$(echo -e "public\nprivate" | fzf --height=10% --prompt="Visibility > ")
  fi
  [ -z "$vis" ] && vis="private"

  # Select template
  local tpl
  if use_gum; then
    tpl=$(gum choose --header "Template:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      "none" "python" "node" "go")
  else
    tpl=$(echo -e "none\npython\nnode\ngo" | fzf --height=15% --prompt="Template > ")
  fi

  # Confirm creation
  echo ""
  if use_gum; then
    gum style --border rounded --border-foreground "$COLOR_SECONDARY" --padding "1 2" \
      "Repository: $name" "Visibility: $vis" "Template: ${tpl:-none}"
    echo ""
  fi

  local cmd_args=("gh" "repo" "create" "$name" "--$vis")
  if [ -n "$desc" ]; then
    cmd_args+=("--description" "$desc")
  fi

  # Create with clone
  print_info "Creating repository..."
  if "${cmd_args[@]}" --clone; then
    print_success "Repository created: $name"
    if [ "$tpl" != "none" ] && [ -d "$name" ]; then
      print_info "Applying template: $tpl"
      apply_template "$name" "$tpl"
      # Commit template locally
      (cd "$name" && git add . && git commit -m "Initial commit (Template: $tpl)") &>/dev/null
      # Ask before pushing
      if gum_confirm "Push initial commit to origin?" "yes"; then
        (cd "$name" && git push origin HEAD) &>/dev/null
        print_success "Template applied and pushed"
      else
        print_success "Template applied (not pushed). Push manually with: cd $name && git push"
      fi
    fi
  else
    print_error "Failed to create repository."
  fi
}

# --- Templates Logic ---

apply_template() {
  local dir="$1"
  local lang="$2"

  case "$lang" in
  python)
    echo "# $dir" >"$dir/README.md"
    touch "$dir/__init__.py"
    echo -e "def main():\n    print('Hello Python')\n\nif __name__ == '__main__':\n    main()" >"$dir/main.py"
    echo "git filtering..."
    cat <<EOT >"$dir/.gitignore"
__pycache__/
*.py[cod]
.venv/
EOT
    ;;
  node)
    echo "# $dir" >"$dir/README.md"
    echo "console.log('Hello Node');" >"$dir/index.js"
    cat <<EOT >"$dir/package.json"
{
  "name": "$dir",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT"
}
EOT
    cat <<EOT >"$dir/.gitignore"
node_modules/
.env
EOT
    ;;
  go)
    echo "# $dir" >"$dir/README.md"
    cat <<EOT >"$dir/main.go"
package main
import "fmt"
func main() {
    fmt.Println("Hello Go")
}
EOT
    (cd "$dir" && go mod init "github.com/$(gh api user -q .login)/$dir" 2>/dev/null || true)
    ;;
  esac
  print_info "Applied $lang template."
}

# --- Action: Fork ---

action_fork() {
  local search_query=""
  local clone_after=false

  while [[ $# -gt 0 ]]; do
    case $1 in
    --clone)
      clone_after=true
      shift
      ;;
    *)
      search_query="$1"
      shift
      ;;
    esac
  done

  if [ -z "$search_query" ]; then
    read -p "Search for repository to fork: " search_query
    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi
  fi

  print_info "Searching GitHub for '$search_query'..."

  local results
  results=$(gh search repos "$search_query" --limit 50 --json fullName,description,stargazersCount,language \
    2>/dev/null | jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=50% --border \
    --header="Select repository to FORK (TAB for multi)" \
    --delimiter='\t' --with-nth=1,2,3 --multi \
    --preview="echo {4}" --preview-window=down:2:wrap)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _ _ _; do
    print_info "Forking $repo..."
    if gh repo fork "$repo" --clone="$clone_after" 2>/dev/null; then
      print_success "Forked: $repo"
      if [ "$clone_after" = "true" ]; then
        print_success "Cloned to: $(basename "$repo")"
      fi
    else
      print_error "Failed to fork: $repo"
    fi
  done <<<"$selected"
}

# --- Action: Explore (External Search) ---

action_explore() {
  local search_query=""
  local sort_by="stars"
  local language=""
  local limit=100

  while [[ $# -gt 0 ]]; do
    case $1 in
    --sort)
      sort_by="$2"
      shift 2
      ;;
    --lang)
      language="$2"
      shift 2
      ;;
    --limit)
      limit="$2"
      shift 2
      ;;
    *)
      search_query="$search_query $1"
      shift
      ;;
    esac
  done

  search_query=$(echo "$search_query" | xargs) # trim

  if [ -z "$search_query" ]; then
    show_header "EXPLORE GITHUB" "Search repositories worldwide"

    # Get search query
    if use_gum; then
      search_query=$(gum input --placeholder "Search query (e.g., 'machine learning')" \
        --prompt "› " \
        --prompt.foreground "$COLOR_PRIMARY" \
        --cursor.foreground "$COLOR_ACCENT")
    else
      read -p "Search query: " search_query
    fi

    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi

    # Get sort option
    if use_gum; then
      local sort_choice
      sort_choice=$(gum choose --header "Sort by:" \
        --cursor "› " \
        --cursor.foreground "$COLOR_ACCENT" \
        --header.foreground "$COLOR_PRIMARY" \
        "stars" "forks" "updated" "help-wanted-issues")
      sort_by="${sort_choice:-stars}"
    else
      echo ""
      echo "Sort by: (s)tars | (f)orks | (u)pdated | (h)elp-wanted"
      read -p "Sort [stars]: " sort_choice
      case "$sort_choice" in
      f) sort_by="forks" ;;
      u) sort_by="updated" ;;
      h) sort_by="help-wanted-issues" ;;
      *) sort_by="stars" ;;
      esac
    fi

    # Get language filter
    if use_gum; then
      language=$(gum input --placeholder "Filter by language (leave empty for all)" \
        --prompt "› " \
        --prompt.foreground "$COLOR_PRIMARY" \
        --cursor.foreground "$COLOR_ACCENT")
    else
      read -p "Filter by language (leave empty for all): " language
    fi
  fi

  print_info "Searching GitHub for '$search_query' (sorted by $sort_by)..."

  local cmd_args=("gh" "search" "repos" "$search_query" "--limit" "$limit" "--sort" "$sort_by")
  [ -n "$language" ] && cmd_args+=("--language" "$language")

  local results
  results=$("${cmd_args[@]}" --json fullName,description,stargazersCount,forksCount,language,updatedAt,license 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.forksCount)🍴\t\(.language // "-")\t\(.updatedAt[:10])\t\(.description // "No description")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local count
  count=$(echo "$results" | wc -l)
  print_info "Found $count repositories"

  local selected
  selected=$(echo "$results" | fzf --height=70% --border \
    --header="🔭 Explore: $search_query | Actions: Enter=select, TAB=multi" \
    --delimiter='\t' --with-nth=1,2,3,4,5 \
    --preview="echo -e 'Repository: {1}\nStars: {2} | Forks: {3}\nLanguage: {4} | Updated: {5}\n\nDescription:\n{6}'" \
    --preview-window=down:6:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  if use_gum; then
    gum style --foreground "$COLOR_SECONDARY" "Selected ${#repos[@]} repositories:"
    for r in "${repos[@]}"; do
      gum style --foreground "$COLOR_INFO" "  $r"
    done
  else
    echo -e "${CYAN}Selected ${#repos[@]} repositories:${NC}"
    printf "  - ${BLUE}%s${NC}\n" "${repos[@]}"
  fi
  echo ""

  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Fork - Fork to your account" \
      "Fork + Clone - Fork and clone" \
      "Browse - Open in browser" \
      "Star - Star the repository" \
      "Info - Show detailed info" \
      "Cancel")
  else
    echo -e "${YELLOW}Actions:${NC}"
    echo "  (c) Clone          - Clone to local machine"
    echo "  (f) Fork           - Fork to your account"
    echo "  (F) Fork + Clone   - Fork and clone"
    echo "  (b) Browse         - Open in browser"
    echo "  (s) Star           - Star the repository"
    echo "  (i) Info           - Show detailed info"
    echo "  (q) Quit           - Cancel"
    echo ""
    read -p "Action: " action
  fi

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      print_info "Cloning $repo..."
      if gh repo clone "$repo" 2>/dev/null; then
        print_success "Cloned: $repo"
      else
        print_error "Failed to clone: $repo"
      fi
    done
    ;;
  f|"Fork - Fork"*)
    for repo in "${repos[@]}"; do
      print_info "Forking $repo..."
      if gh repo fork "$repo" --clone=false 2>/dev/null; then
        print_success "Forked: $repo"
      else
        print_error "Failed to fork: $repo"
      fi
    done
    ;;
  F|"Fork + Clone"*)
    for repo in "${repos[@]}"; do
      print_info "Forking and cloning $repo..."
      if gh repo fork "$repo" --clone=true 2>/dev/null; then
        print_success "Forked and cloned: $repo"
      else
        print_error "Failed: $repo"
      fi
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      print_info "Opening $repo in browser..."
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  s|"Star"*)
    for repo in "${repos[@]}"; do
      print_info "Starring $repo..."
      if gh api -X PUT "user/starred/$repo" 2>/dev/null; then
        print_success "Starred: $repo"
      else
        print_error "Failed to star: $repo"
      fi
    done
    ;;
  i|"Info"*)
    for repo in "${repos[@]}"; do
      show_header "$repo" "Repository Details"
      gh repo view "$repo" 2>/dev/null || print_error "Failed to fetch info"
      echo ""
      if use_gum; then
        gum confirm "Continue?" --affirmative "OK" --negative "" --default=true || true
      else
        read -p "Press Enter to continue..."
      fi
    done
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Trending ---

action_trending() {
  local language="${1:-}"
  local since="daily"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --lang)
      language="$2"
      shift 2
      ;;
    --since)
      since="$2"
      shift 2
      ;;
    *)
      [ -z "$language" ] && language="$1"
      shift
      ;;
    esac
  done

  show_header "TRENDING REPOSITORIES" "Hot projects this week"

  local query="stars:>100 pushed:>$(date -d '7 days ago' '+%Y-%m-%d' 2>/dev/null || date -v-7d '+%Y-%m-%d')"
  [ -n "$language" ] && query="$query language:$language"

  print_info "Fetching trending repositories${language:+ for $language}..."

  local results
  results=$(gh search repos "$query" --sort stars --order desc --limit 30 \
    --json fullName,description,stargazersCount,language,updatedAt 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No trending repositories found"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=60% --border \
    --header="🔥 Trending${language:+ ($language)} | TAB=multi-select" \
    --delimiter='\t' --with-nth=1,2,3 \
    --preview="echo {4}" --preview-window=down:3:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Fork - Fork to your account" \
      "Browse - Open in browser" \
      "Star - Star the repository" \
      "Cancel")
  else
    echo "Actions: (c)lone | (f)ork | (b)rowse | (s)tar | (q)uit"
    read -p "Action: " action
  fi

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" 2>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  f|"Fork"*)
    for repo in "${repos[@]}"; do
      gh repo fork "$repo" --clone=false 2>/dev/null && print_success "Forked: $repo" || print_error "Failed: $repo"
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  s|"Star"*)
    for repo in "${repos[@]}"; do
      gh api -X PUT "user/starred/$repo" 2>/dev/null && print_success "Starred: $repo" || print_error "Failed: $repo"
    done
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Archive ---

action_archive() {
  local mode="archive"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --unarchive)
      mode="unarchive"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filter_jq
  local header_text
  if [ "$mode" = "archive" ]; then
    filter_jq='[.[] | select(.isArchived == false)]'
    header_text="Select repos to ARCHIVE"
  else
    filter_jq='[.[] | select(.isArchived == true)]'
    header_text="Select repos to UNARCHIVE"
  fi

  local filtered
  filtered=$(echo "$json" | jq "$filter_jq")

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories available to $mode"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  print_warning "You are about to $mode ${#repos[@]} repositories:"
  printf "  - %s\n" "${repos[@]}"
  echo ""
  read -p "Continue? [y/N]: " confirm

  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    print_info "Cancelled."
    return
  fi

  for repo in "${repos[@]}"; do
    print_info "${mode^}ing $repo..."
    if [ "$mode" = "archive" ]; then
      if gh repo archive "$repo" --yes 2>/dev/null; then
        print_success "Archived: $repo"
      else
        print_error "Failed to archive: $repo"
      fi
    else
      if gh repo unarchive "$repo" --yes 2>/dev/null; then
        print_success "Unarchived: $repo"
      else
        print_error "Failed to unarchive: $repo"
      fi
    fi
  done

  rm -f "$CACHE_FILE"
  print_info "Cache cleared (repo states changed)"
}

# --- Action: Stats ---

action_stats() {
  local json
  json=$(fetch_repositories_json "true")

  show_header "REPOSITORY STATISTICS" "Your GitHub Overview"

  local total public private archived
  total=$(echo "$json" | jq 'length')
  public=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")] | length')
  private=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")] | length')
  archived=$(echo "$json" | jq '[.[] | select(.isArchived == true)] | length')

  if use_gum; then
    # Build stats box with gum
    local stats_content
    stats_content=$(printf "Total Repositories:  %s\nPublic:              %s\nPrivate:             %s\nArchived:            %s" "$total" "$public" "$private" "$archived")
    gum style --border rounded --border-foreground "$COLOR_SECONDARY" --padding "1 2" --margin "0 2" "$stats_content"
  else
    echo -e "  ${GREEN}Total Repositories:${NC}  $total"
    echo -e "  ${GREEN}Public:${NC}              $public"
    echo -e "  ${YELLOW}Private:${NC}             $private"
    echo -e "  ${CYAN}Archived:${NC}            $archived"
  fi
  echo ""

  local total_stars total_forks total_size
  total_stars=$(echo "$json" | jq '[.[].stargazerCount] | add // 0')
  total_forks=$(echo "$json" | jq '[.[].forkCount] | add // 0')
  total_size=$(echo "$json" | jq '[.[].diskUsage] | add // 0')
  local size_mb=$((total_size / 1024))

  if use_gum; then
    local metrics_content
    metrics_content=$(printf "Total Stars:   %s\nTotal Forks:   %s\nTotal Size:    %s MB" "$total_stars" "$total_forks" "$size_mb")
    gum style --border rounded --border-foreground "$COLOR_ACCENT" --padding "1 2" --margin "0 2" "$metrics_content"
  else
    echo -e "  ${YELLOW}⭐ Total Stars:${NC}       $total_stars"
    echo -e "  ${BLUE}🍴 Total Forks:${NC}       $total_forks"
    echo -e "  ${CYAN}💾 Total Size:${NC}        ${size_mb} MB"
  fi
  echo ""

  show_divider "Languages Breakdown"
  echo ""

  local lang_data
  lang_data=$(echo "$json" | jq -r '
    [.[] | .primaryLanguage.name // "Unknown"] |
    group_by(.) |
    map({lang: .[0], count: length}) |
    sort_by(-.count) |
    .[:10] |
    .[] |
    "\(.lang): \(.count)"
  ')

  if use_gum; then
    echo "$lang_data" | while read -r line; do
      gum style --foreground "$COLOR_SECONDARY" "  $line"
    done
  else
    echo "$lang_data" | sed 's/^/  /'
  fi
  echo ""

  show_divider "Top Repositories (by Stars)"
  echo ""

  echo "$json" | jq -r '
    sort_by(-.stargazerCount) |
    .[:5] |
    .[] |
    "  \(.stargazerCount)\t\(.nameWithOwner)"
  ' | while IFS=$'\t' read -r stars name; do
    if use_gum; then
      local star_styled
      star_styled=$(gum style --foreground "$COLOR_WARNING" "$stars")
      local name_styled
      name_styled=$(gum style --foreground "$COLOR_SECONDARY" "$name")
      echo "$star_styled $name_styled"
    else
      printf "  %-6s %s\n" "$stars" "$name"
    fi
  done
  echo ""

  show_divider "Recently Updated (last 5)"
  echo ""

  echo "$json" | jq -r '
    sort_by(.updatedAt) | reverse |
    .[:5] |
    .[] |
    "\(.updatedAt[:10])\t\(.nameWithOwner)"
  ' | while IFS=$'\t' read -r date name; do
    if use_gum; then
      local date_styled
      date_styled=$(gum style --foreground "$COLOR_MUTED" "$date")
      local name_styled
      name_styled=$(gum style --foreground "$COLOR_SECONDARY" "$name")
      echo "  $date_styled $name_styled"
    else
      printf "  %-12s %s\n" "$date" "$name"
    fi
  done
  echo ""
}

# --- Action: Search ---

action_search() {
  local json
  json=$(fetch_repositories_json "false")

  print_info "Type to search (fuzzy matching on name and description)..."

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "No description")\t\(.visibility)\t\(.primaryLanguage.name // "-")"' |
    fzf --height=60% --border \
      --header="Search repositories (ESC to cancel)" \
      --delimiter='\t' \
      --with-nth=1,3,4 \
      --preview="echo -e 'Description:\n{2}'" \
      --preview-window=down:3:wrap \
      --multi)

  [ -z "$selected" ] && return

  echo ""
  if use_gum; then
    gum style --foreground "$COLOR_SECONDARY" "Selected repositories:"
    while IFS=$'\t' read -r repo desc vis lang; do
      gum style --foreground "$COLOR_INFO" "  $repo [$vis] ($lang)"
    done <<<"$selected"
  else
    echo -e "${CYAN}Selected repositories:${NC}"
    while IFS=$'\t' read -r repo desc vis lang; do
      echo -e "  ${BLUE}$repo${NC} [$vis] ($lang)"
    done <<<"$selected"
  fi

  echo ""
  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Browse - Open in browser" \
      "Delete - Delete repositories" \
      "Cancel")
  else
    echo "Actions: (c)lone | (b)rowse | (d)elete | (q)uit"
    read -p "Action: " action
  fi

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" &>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  d|"Delete"*)
    print_warning "Delete selected repos? This is NOT reversible!"
    local confirm
    if use_gum; then
      confirm=$(gum input --placeholder "Type DELETE to confirm" \
        --prompt "› " \
        --prompt.foreground "$COLOR_ERROR" \
        --cursor.foreground "$COLOR_ERROR")
    else
      read -p "Type 'DELETE' to confirm: " confirm
    fi
    if [ "$confirm" = "DELETE" ]; then
      for repo in "${repos[@]}"; do
        gh repo delete "$repo" --yes 2>/dev/null && print_success "Deleted: $repo" || print_error "Failed: $repo"
      done
      rm -f "$CACHE_FILE"
      print_info "Cache cleared (repo deleted)"
    else
      print_info "Cancelled"
    fi
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Browse ---

action_browse() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="Select repos to open in browser" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _; do
    print_info "Opening $repo in browser..."
    gh browse -R "$repo" 2>/dev/null &
  done <<<"$selected"

  print_success "Opened selected repositories in browser"
}

# --- Action: Visibility ---

action_visibility() {
  local target_visibility=""

  while [[ $# -gt 0 ]]; do
    case $1 in
    --public)
      target_visibility="public"
      shift
      ;;
    --private)
      target_visibility="private"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filtered header_text
  if [ "$target_visibility" = "public" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")]')
    header_text="Select PRIVATE repos to make PUBLIC"
  elif [ "$target_visibility" = "private" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")]')
    header_text="Select PUBLIC repos to make PRIVATE"
  else
    filtered="$json"
    header_text="Select repos to toggle visibility"
  fi

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories match the criteria"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.visibility)"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t')

  [ -z "$selected" ] && return

  local repos=()
  local visibilities=()
  while IFS=$'\t' read -r repo vis; do
    repos+=("$repo")
    visibilities+=("$vis")
  done <<<"$selected"

  print_warning "Visibility changes:"
  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi
    echo -e "  ${repos[$i]}: ${visibilities[$i]} → ${new_vis^^}"
  done

  echo ""
  read -p "Continue? [y/N]: " confirm
  [[ ! "$confirm" =~ ^[Yy]$ ]] && return

  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi

    print_info "Changing ${repos[$i]} to $new_vis..."
    if gh repo edit "${repos[$i]}" --visibility "$new_vis" 2>/dev/null; then
      print_success "Updated: ${repos[$i]}"
    else
      print_error "Failed: ${repos[$i]}"
    fi
  done

  rm -f "$CACHE_FILE"
}

# --- Action: PR (Pull Requests) ---

action_pr() {
  local subcommand="${1:-list}"
  shift 2>/dev/null || true

  case "$subcommand" in
  list)
    action_pr_list "$@"
    ;;
  create)
    action_pr_create "$@"
    ;;
  *)
    print_error "Unknown PR subcommand: $subcommand"
    echo "Usage: ghtools pr {list|create}"
    ;;
  esac
}

action_pr_list() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --height=40% --border --header="Select repository to list PRs")

  [ -z "$selected" ] && return

  print_info "Fetching PRs for $selected..."
  echo ""

  gh pr list -R "$selected" --limit 20 --json number,title,state,author,createdAt \
    --template '{{range .}}#{{.number}} [{{.state}}] {{.title}} (by {{.author.login}}, {{timeago .createdAt}})
{{end}}'
}

action_pr_create() {
  if [ ! -d ".git" ]; then
    print_error "Not in a git repository"
    return 1
  fi

  local current_branch
  current_branch=$(git branch --show-current)

  # Handle detached HEAD state
  if [ -z "$current_branch" ]; then
    print_error "You are in 'detached HEAD' state. Please checkout a branch first."
    print_info "Tip: Use 'git checkout -b branch-name' to create a new branch from current state."
    return 1
  fi

  if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
    print_warning "You're on $current_branch branch. Create a feature branch first."
    return 1
  fi

  print_info "Creating PR from branch: $current_branch"

  read -p "PR Title: " title
  [ -z "$title" ] && title="$current_branch"

  local draft=""
  read -p "Create as draft? [y/N]: " is_draft
  [[ "$is_draft" =~ ^[Yy]$ ]] && draft="--draft"

  # Push branch if needed
  if ! git ls-remote --exit-code --heads origin "$current_branch" &>/dev/null; then
    print_info "Pushing branch to origin..."
    git push -u origin "$current_branch"
  fi

  # shellcheck disable=SC2086
  if gh pr create --title "$title" --body "" $draft; then
    print_success "PR created successfully"
  else
    print_error "Failed to create PR"
  fi
}

# --- Action: Status ---

action_status() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local max_depth=3

  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  print_info "Scanning repositories in $base_path..."

  local git_dirs
  # Use -print0 and xargs -0 to handle paths with spaces correctly
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune -print0 2>/dev/null | xargs -0 -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found"
    return
  fi

  echo ""
  printf "${CYAN}%-35s %-12s %-10s %-10s %s${NC}\n" "REPOSITORY" "BRANCH" "STATUS" "AHEAD" "BEHIND"
  printf "${CYAN}%s${NC}\n" "$(printf '%*s' 85 '' | tr ' ' '-')"

  for repo_path in "${git_dirs[@]}"; do
    local repo_name branch status_icon ahead behind
    repo_name=$(basename "$repo_path")
    branch=$(git -C "$repo_path" branch --show-current 2>/dev/null || echo "detached")

    # Check dirty state
    local dirty=false
    if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
      dirty=true
    fi

    # Check untracked files
    local untracked=false
    if [ -n "$(git -C "$repo_path" ls-files --others --exclude-standard 2>/dev/null)" ]; then
      untracked=true
    fi

    # Determine status
    if [ "$dirty" = "true" ] && [ "$untracked" = "true" ]; then
      status_icon="${RED}dirty+untrk${NC}"
    elif [ "$dirty" = "true" ]; then
      status_icon="${YELLOW}dirty${NC}"
    elif [ "$untracked" = "true" ]; then
      status_icon="${YELLOW}untracked${NC}"
    else
      status_icon="${GREEN}clean${NC}"
    fi

    # Check ahead/behind
    ahead=$(git -C "$repo_path" rev-list --count @{u}..HEAD 2>/dev/null || echo "?")
    behind=$(git -C "$repo_path" rev-list --count HEAD..@{u} 2>/dev/null || echo "?")

    local ahead_color="$NC" behind_color="$NC"
    [ "$ahead" != "0" ] && [ "$ahead" != "?" ] && ahead_color="$GREEN"
    [ "$behind" != "0" ] && [ "$behind" != "?" ] && behind_color="$RED"

    printf "%-35s %-12s ${status_icon}%-10s ${ahead_color}%-10s${NC} ${behind_color}%s${NC}\n" \
      "$(truncate_text "$repo_name" 35)" "$branch" "" "$ahead" "$behind"
  done

  echo ""
  print_info "Legend: ${GREEN}clean${NC} | ${YELLOW}dirty/untracked${NC} | ${GREEN}ahead${NC} (unpushed) | ${RED}behind${NC} (needs pull)"
}

# --- Main Menu ---

show_menu() {
  # Show beautiful header
  if use_gum; then
    clear
    gum style \
      --border rounded \
      --border-foreground "$COLOR_PRIMARY" \
      --foreground "$COLOR_SECONDARY" \
      --align center \
      --width 50 \
      --padding "1 2" \
      --margin "1 0" \
      "GHTOOLS" "GitHub Repository Manager v$VERSION"
    echo ""
  fi

  local options=(
    "List Repositories"
    "Search My Repos"
    "Explore GitHub"
    "Trending Repos"
    "Statistics Dashboard"
    "Clone Repositories"
    "Sync Local Repos"
    "Local Repo Status"
    "Fork Repository"
    "Create Repository"
    "Delete Repositories"
    "Archive/Unarchive"
    "Change Visibility"
    "Browse in Browser"
    "Pull Requests"
    "Config"
    "Refresh Cache"
    "Exit"
  )

  local choice
  if use_gum; then
    choice=$(printf '%s\n' "${options[@]}" | gum choose \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header "Select an action:" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      --height 20)
  else
    local options_legacy="📋 List Repositories
🔍 Search My Repos
🔭 Explore GitHub
🔥 Trending Repos
📊 Statistics Dashboard
📦 Clone Repositories
🔄 Sync Local Repos
📁 Local Repo Status
🍴 Fork Repository
➕ Create Repository
🗑️  Delete Repositories
📦 Archive/Unarchive
🔒 Change Visibility
🌐 Browse in Browser
📝 Pull Requests
⚙️  Config
🔄 Refresh Cache
🚪 Exit"
    choice=$(echo "$options_legacy" | fzf --height=55% --border --header="GitHub Tools v$VERSION" --layout=reverse)
  fi

  case "$choice" in
  *"List"*) action_list ;;
  *"Search My"*) action_search ;;
  *"Explore"*) action_explore ;;
  *"Trending"*) action_trending ;;
  *"Statistics"*) action_stats ;;
  *"Clone"*) action_clone ;;
  *"Sync"*) action_sync ;;
  *"Local Repo Status"*) action_status ;;
  *"Fork"*) action_fork ;;
  *"Create"*) action_create ;;
  *"Delete"*) action_delete ;;
  *"Archive"*) action_archive ;;
  *"Visibility"*) action_visibility ;;
  *"Browse"*) action_browse ;;
  *"Pull Requests"*) action_pr ;;
  *"Config"*)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;
  *"Refresh"*)
    rm -f "$CACHE_FILE"
    print_success "Cache cleared."
    show_menu
    ;;
  *"Exit"*) exit 0 ;;
  *) exit 0 ;;
  esac
}

# --- Entry Point ---

main() {
  # Parse global options first
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_usage
      exit 0
      ;;
    -v | --version)
      echo "ghtools $VERSION"
      exit 0
      ;;
    -V | --verbose)
      VERBOSE=true
      shift
      ;;
    -q | --quiet)
      QUIET=true
      shift
      ;;
    *)
      # Stop parsing global options, pass to command handler
      break
      ;;
    esac
  done

  check_dependencies
  check_gh_auth

  if [ $# -eq 0 ]; then
    while true; do
      show_menu
      echo ""
      read -p "Press Enter to continue..."
    done
  fi

  case "$1" in
  list)
    shift
    action_list "$@"
    ;;
  clone)
    shift
    action_clone "$@"
    ;;
  sync)
    shift
    action_sync "$@"
    ;;
  create) action_create ;;
  delete) action_delete ;;
  fork)
    shift
    action_fork "$@"
    ;;
  archive)
    shift
    action_archive "$@"
    ;;
  stats) action_stats ;;
  search) action_search ;;
  browse) action_browse ;;
  explore)
    shift
    action_explore "$@"
    ;;
  trending)
    shift
    action_trending "$@"
    ;;
  visibility)
    shift
    action_visibility "$@"
    ;;
  pr)
    shift
    action_pr "$@"
    ;;
  status)
    shift
    action_status "$@"
    ;;
  config)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;
  refresh)
    rm -f "$CACHE_FILE"
    print_success "Cache cleared."
    ;;
  help)
    show_usage
    ;;
  *)
    print_error "Unknown command: $1"
    show_usage
    exit 1
    ;;
  esac
}

main "$@"
</file>
<file path="ghtools_functions.sh">
#!/bin/bash

# ghtools_functions.sh - Functions extracted for testing
# This file is auto-generated from ghtools for testing purposes
# Do not edit directly - modify ghtools and regenerate

# Skip strict mode in test mode
if [[ "${GHTOOLS_TEST_MODE:-}" != "1" ]]; then
  set -euo pipefail
fi

# --- Version ---
VERSION="3.2.0"

# --- Default Configuration ---
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ghtools"
CONFIG_FILE="$CONFIG_DIR/config"
# Include user ID in cache filename for multi-user support
CACHE_FILE="/tmp/ghtools_repos_$(id -u).json"
CACHE_TTL=600     # 10 minutes (in seconds)
MAX_JOBS=5        # Parallel jobs for sync/clone
VERBOSE=false
QUIET=false

# --- Load User Config ---
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Security: Validate config file contains only allowed variable assignments
        local allowed_vars="CACHE_TTL|CACHE_FILE|MAX_JOBS|DEFAULT_ORG|DEFAULT_CLONE_PATH"
        # Check for lines that are not: empty, comments, or allowed variable assignments
        if grep -Evq "^[[:space:]]*(#.*)?$|^[[:space:]]*($allowed_vars)=" "$CONFIG_FILE"; then
            # Config contains potentially dangerous content - show warning and skip
            echo -e "\033[1;33m[WARNING]\033[0m Config file contains invalid lines. Skipping: $CONFIG_FILE" >&2
            echo -e "\033[1;33m[WARNING]\033[0m Allowed variables: CACHE_TTL, CACHE_FILE, MAX_JOBS, DEFAULT_ORG, DEFAULT_CLONE_PATH" >&2
            return 1
        fi
        # Check permissions (should be 600 or 644)
        local perms
        perms=$(stat -c %a "$CONFIG_FILE" 2>/dev/null || stat -f %Lp "$CONFIG_FILE" 2>/dev/null)
        if [[ "$perms" =~ [0-7][2367][0-7] ]]; then
            echo -e "\033[1;33m[WARNING]\033[0m Config file is world/group writable. Fix: chmod 600 $CONFIG_FILE" >&2
        fi
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

# Create default config if not exists
init_config() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" <<'EOF'
# ghtools configuration file
# Uncomment and modify as needed

# Cache settings
#CACHE_TTL=600        # Cache time-to-live in seconds (default: 600)
#CACHE_FILE="/tmp/ghtools_repos_UID.json"  # UID is auto-appended for multi-user support

# Parallel jobs for sync/clone operations
#MAX_JOBS=5

# Default organization filter (leave empty for all)
#DEFAULT_ORG=""

# Default clone path (leave empty for current directory)
#DEFAULT_CLONE_PATH=""
EOF
        print_info "Created default config at $CONFIG_FILE"
    fi
}

# Skip auto-loading config when in test mode
if [[ "${GHTOOLS_TEST_MODE:-}" != "1" ]]; then
  load_config
fi


# --- Color Scheme (Modern Purple/Cyan Theme) ---
# Primary colors
COLOR_PRIMARY="99"      # Soft purple
COLOR_SECONDARY="39"    # Cyan
COLOR_ACCENT="212"      # Pink
COLOR_SUCCESS="78"      # Green
COLOR_WARNING="220"     # Yellow/Gold
COLOR_ERROR="196"       # Red
COLOR_INFO="75"         # Light blue
COLOR_MUTED="240"       # Gray

# Legacy colors for compatibility
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Gum Style Helpers ---

# Check if gum is available and terminal supports it
use_gum() {
  command -v gum &>/dev/null && [[ -t 1 ]]
}

# Styled text output
gum_style() {
  local text="$1"
  local fg="${2:-$COLOR_PRIMARY}"
  local bold="${3:-false}"

  if use_gum; then
    if [[ "$bold" == "true" ]]; then
      gum style --foreground "$fg" --bold "$text"
    else
      gum style --foreground "$fg" "$text"
    fi
  else
    echo "$text"
  fi
}

# --- Utility Functions ---

print_error() {
  if use_gum && [[ "$QUIET" != "true" ]]; then
    gum style --foreground "$COLOR_ERROR" --bold "✗ ERROR" | tr -d '\n'
    echo " $1" >&2
  else
    echo -e "${RED}[ERROR]${NC} $1" >&2
  fi
}

print_success() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_SUCCESS" --bold "✓ SUCCESS" | tr -d '\n'
    echo " $1"
  else
    echo -e "${GREEN}[SUCCESS]${NC} $1"
  fi
}

print_info() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_INFO" "ℹ INFO" | tr -d '\n'
    echo " $1"
  else
    echo -e "${BLUE}[INFO]${NC} $1"
  fi
}

print_warning() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_WARNING" --bold "⚠ WARNING" | tr -d '\n'
    echo " $1"
  else
    echo -e "${YELLOW}[WARNING]${NC} $1"
  fi
}

print_verbose() {
  [[ "$VERBOSE" != "true" ]] && return 0
  if use_gum; then
    gum style --foreground "$COLOR_MUTED" "◦ DEBUG" | tr -d '\n'
    echo " $1"
  else
    echo -e "${CYAN}[DEBUG]${NC} $1"
  fi
}

# Beautiful header/banner
show_header() {
  local title="$1"
  local subtitle="${2:-}"

  if use_gum; then
    echo ""
    if [[ -n "$subtitle" ]]; then
      gum style \
        --border rounded \
        --border-foreground "$COLOR_PRIMARY" \
        --foreground "$COLOR_SECONDARY" \
        --align center \
        --width 60 \
        --padding "1 2" \
        --margin "0 2" \
        "$title" "$subtitle"
    else
      gum style \
        --border rounded \
        --border-foreground "$COLOR_PRIMARY" \
        --foreground "$COLOR_SECONDARY" \
        --align center \
        --width 60 \
        --padding "1 2" \
        --margin "0 2" \
        "$title"
    fi
    echo ""
  else
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}                    $title${NC}"
    [[ -n "$subtitle" ]] && echo -e "${CYAN}                    $subtitle${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
  fi
}

# Section divider
show_divider() {
  local title="${1:-}"
  if use_gum; then
    if [[ -n "$title" ]]; then
      gum style --foreground "$COLOR_MUTED" --bold "─── $title ───"
    else
      gum style --foreground "$COLOR_MUTED" "────────────────────────────────────────"
    fi
  else
    if [[ -n "$title" ]]; then
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
      echo -e "${CYAN}                      $title${NC}"
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
    else
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
    fi
  fi
}

# Spinner for long operations
# Usage: run_with_spinner "Title" command arg1 arg2 ...
run_with_spinner() {
  local title="$1"
  shift
  # Execute directly the command passed as separate arguments (no eval)

  if use_gum; then
    gum spin --spinner dot --spinner.foreground "$COLOR_ACCENT" --title "$title" -- "$@"
  else
    echo -n "$title... "
    if "$@"; then
      echo "done"
    else
      echo "failed"
      return 1
    fi
  fi
}

# Interactive confirmation
gum_confirm() {
  local prompt="$1"
  local default="${2:-no}"

  if use_gum; then
    if [[ "$default" == "yes" ]]; then
      gum confirm --affirmative "Yes" --negative "No" --default=true \
        --prompt.foreground "$COLOR_WARNING" "$prompt"
    else
      gum confirm --affirmative "Yes" --negative "No" --default=false \
        --prompt.foreground "$COLOR_WARNING" "$prompt"
    fi
  else
    local response
    read -p "$prompt [y/N]: " response
    [[ "$response" =~ ^[Yy]$ ]]
  fi
}

# Interactive input
gum_input() {
  local placeholder="$1"
  local prompt="${2:-› }"
  local default="${3:-}"

  if use_gum; then
    gum input --placeholder "$placeholder" \
      --prompt "$prompt" \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT" \
      --value "$default"
  else
    local response
    read -p "$prompt$placeholder: " response
    echo "${response:-$default}"
  fi
}

# Interactive choice
gum_choose() {
  local header="$1"
  shift
  local options=("$@")

  if use_gum; then
    printf '%s\n' "${options[@]}" | gum choose \
      --header "$header" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY"
  else
    printf '%s\n' "${options[@]}" | fzf --header="$header" --height=40%
  fi
}

# Interactive filter (fuzzy search)
gum_filter() {
  local placeholder="$1"
  local multi="${2:-false}"

  if use_gum; then
    local args=(
      --placeholder "$placeholder"
      --prompt "› "
      --prompt.foreground "$COLOR_PRIMARY"
      --cursor.foreground "$COLOR_ACCENT"
      --match.foreground "$COLOR_SUCCESS"
      --indicator "›"
      --indicator.foreground "$COLOR_ACCENT"
    )
    [[ "$multi" == "true" ]] && args+=(--no-limit)
    gum filter "${args[@]}"
  else
    local fzf_args=(--height=50% --border)
    [[ "$multi" == "true" ]] && fzf_args+=(--multi)
    fzf "${fzf_args[@]}" --header="$placeholder"
  fi
}

# Write/text area input
gum_write() {
  local placeholder="$1"

  if use_gum; then
    gum write --placeholder "$placeholder" \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --char-limit 0
  else
    local text
    echo "$placeholder (Ctrl+D to finish):"
    text=$(cat)
    echo "$text"
  fi
}

# Table-like output row
print_table_row() {
  local col1="$1"
  local col2="$2"
  local col1_width="${3:-30}"
  local col1_color="${4:-$COLOR_SECONDARY}"

  if use_gum; then
    local styled_col1
    styled_col1=$(gum style --foreground "$col1_color" "$(printf "%-${col1_width}s" "$col1")")
    echo "$styled_col1 $col2"
  else
    printf "%b%-${col1_width}s%b %s\n" "$CYAN" "$col1" "$NC" "$col2"
  fi
}

show_usage() {
    cat <<EOF
${GREEN}ghtools${NC} - Unified GitHub repository management tool

${YELLOW}USAGE:${NC}
    ghtools [OPTIONS] <COMMAND> [ARGS]

${YELLOW}COMMANDS:${NC}
    ${GREEN}Repository Management:${NC}
    list [--refresh] [--lang <lang>] [--org <org>]
                        List repositories with optional filters
    clone [--path <dir>]
                        Clone repositories interactively
    create              Create a new repository
    delete              Delete repositories interactively
    fork [--clone] <query>
                        Fork external repositories
    archive [--unarchive]
                        Archive or unarchive repositories
    visibility [--public|--private]
                        Change repository visibility

    ${GREEN}Local Repository Operations:${NC}
    sync [--path <dir>] [--dry-run] [--all] [--max-depth <n>]
                        Sync local repositories with remote
    status [--path <dir>]
                        Show status of local repositories

    ${GREEN}Discovery & Navigation:${NC}
    search              Interactive fuzzy search with actions
    browse              Open repositories in browser
    stats               Show repository statistics dashboard
    explore [--sort <s>] [--lang <l>] <query>
                        Search external GitHub repositories
    trending [--lang <l>]
                        Show trending repositories

    ${GREEN}Pull Requests:${NC}
    pr list             List PRs for a repository
    pr create           Create PR from current branch

    ${GREEN}Utilities:${NC}
    refresh             Clear the repository cache
    config              Initialize/show config file location
    help                Show this help message

${YELLOW}OPTIONS:${NC}
    -h, --help          Show this help message
    -v, --version       Show version
    -V, --verbose       Enable verbose output
    -q, --quiet         Suppress non-error output

${YELLOW}EXAMPLES:${NC}
    ghtools list --lang python --org myorg
    ghtools clone --path ~/projects
    ghtools sync --dry-run --all
    ghtools fork --clone "react hooks"
    ghtools archive --unarchive
    ghtools visibility --private
    ghtools status --path ~/dev
    ghtools pr create
    ghtools explore "machine learning" --lang python
    ghtools trending --lang rust

${YELLOW}CONFIG:${NC}
    Config file: \$XDG_CONFIG_HOME/ghtools/config (or ~/.config/ghtools/config)

EOF
}

check_dependencies() {
  local missing_deps=()
  local optional_deps=()

  # Required dependencies
  for cmd in gh fzf git jq; do
    if ! command -v "$cmd" &>/dev/null; then
      missing_deps+=("$cmd")
    fi
  done

  # Optional but recommended (gum for beautiful UI)
  if ! command -v gum &>/dev/null; then
    optional_deps+=("gum")
  fi

  if [ ${#missing_deps[@]} -ne 0 ]; then
    print_error "Missing required dependencies:"
    printf "  - %s\n" "${missing_deps[@]}"
    echo ""
    echo "Install via Arch Linux:"
    echo "  sudo pacman -S github-cli fzf git jq gum"
    exit 1
  fi

  if [ ${#optional_deps[@]} -ne 0 ]; then
    print_warning "Optional dependencies missing (for enhanced UI):"
    printf "  - %s\n" "${optional_deps[@]}"
    echo ""
    echo "Install for beautiful UI: sudo pacman -S gum"
    echo ""
  fi
}

check_gh_auth() {
  if ! gh auth status &>/dev/null; then
    print_error "Not authenticated with GitHub CLI. Run: gh auth login"
    exit 1
  fi
}

# --- Caching Mechanism ---

is_cache_valid() {
  if [ -f "$CACHE_FILE" ]; then
    local file_time current_time age
    file_time=$(date -r "$CACHE_FILE" +%s)
    current_time=$(date +%s)
    age=$((current_time - file_time))
    if [ "$age" -lt "$CACHE_TTL" ]; then
      return 0
    fi
  fi
  return 1
}

fetch_repositories_json() {
  local force_refresh="${1:-false}"
  local limit="${2:-1000}"
  local org_filter="${3:-${DEFAULT_ORG:-}}"
  local fields="name,nameWithOwner,description,visibility,primaryLanguage,stargazerCount,forkCount,diskUsage,updatedAt,createdAt,isArchived,url,sshUrl"

  # Build command as array (avoid eval/word splitting issues)
  local cmd_args=("gh" "repo" "list")
  if [ -n "$org_filter" ]; then
    cmd_args+=("$org_filter")
    print_verbose "Filtering by organization: $org_filter"
  fi

  if [ "$force_refresh" = "true" ] || ! is_cache_valid; then
    print_info "Fetching repositories from GitHub API..." >&2
    local error_output
    error_output=$(mktemp)

    # Use umask 077 to ensure cache file has secure permissions (600)
    if ! (umask 077 && "${cmd_args[@]}" --limit "$limit" --json "$fields" >"$CACHE_FILE") 2>"$error_output"; then
      print_error "Failed to fetch repositories."
      if [ -s "$error_output" ]; then
        print_error "Details: $(cat "$error_output")"
      fi
      rm -f "$error_output"
      exit 1
    fi
    rm -f "$error_output"
    print_verbose "Fetched $(jq length "$CACHE_FILE") repositories"
  else
    print_info "Using cached repository list ($(date -r "$CACHE_FILE" '+%H:%M:%S'))" >&2
  fi

  cat "$CACHE_FILE"
}

# --- Helper Functions ---

# Job control for parallelism
wait_for_jobs() {
  local current_jobs
  current_jobs=$(jobs -p | wc -l)
  if [ "$current_jobs" -ge "$MAX_JOBS" ]; then
    # Use wait -n (Bash 4.3+), fallback to wait for older versions
    wait -n 2>/dev/null || wait
  fi
}

truncate_text() {
  local input="$1"
  local max="$2"
  if [ "${#input}" -gt "$max" ]; then
    echo "${input:0:$((max - 3))}..."
  else
    echo "$input"
  fi
}

# --- Action: List ---

action_list() {
  local refresh="false"
  local filter_lang=""
  local filter_org=""

  # Simple args parsing for list
  while [[ $# -gt 0 ]]; do
    case $1 in
    --refresh)
      refresh="true"
      shift
      ;;
    --lang)
      filter_lang="$2"
      shift 2
      ;;
    --org)
      filter_org="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "$refresh" "1000" "$filter_org")

  # Filter by language if requested
  if [ -n "$filter_lang" ]; then
    json=$(echo "$json" | jq --arg lang "$filter_lang" '[.[] | select(.primaryLanguage.name != null and (.primaryLanguage.name | ascii_downcase) == ($lang | ascii_downcase))]')
  fi

  # Output Table using pure JQ + printf (Faster/Cleaner)
  echo ""
  printf "%b%-30s %-40s %-10s %-10s %-15s%b\n" "$CYAN" "NAME" "DESCRIPTION" "VISIBILITY" "LANG" "UPDATED" "$NC"
  printf "%b%s%b\n" "$CYAN" "$(printf '%*s' 110 '' | tr ' ' '-')" "$NC"

  echo "$json" | jq -r '.[] | [.nameWithOwner, (.description // "No description"), .visibility, (.primaryLanguage.name // "-"), .updatedAt] | @tsv' |
    while IFS=$'\t' read -r name desc vis lang updated; do
      local d_name=$(truncate_text "$name" 30)
      local d_desc=$(truncate_text "$desc" 40)
      local d_updated=$(date -d "$updated" '+%Y-%m-%d' 2>/dev/null || echo "$updated")

      local color="$NC"
      [[ "$vis" == "PUBLIC" ]] && color="$GREEN"
      [[ "$vis" == "PRIVATE" ]] && color="$YELLOW"

      printf "%b%-30s%b %-40s %b%-10s%b %-10s %-15s\n" \
        "$BLUE" "$d_name" "$NC" "$d_desc" "$color" "$vis" "$NC" "$lang" "$d_updated"
    done
  echo ""
}

# --- Action: Clone ---

action_clone() {
  local clone_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      clone_path="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  # Validate clone path
  if [ ! -d "$clone_path" ]; then
    print_error "Clone path does not exist: $clone_path"
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  print_info "Select repositories to CLONE (TAB to multi-select):"
  print_info "Clone destination: $clone_path"

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="TAB: select | ENTER: confirm | Dest: $clone_path" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  echo ""
  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  local total=${#repos[@]}
  local current=0
  print_info "Cloning $total repositories in parallel ($MAX_JOBS threads)..."

  for repo in "${repos[@]}"; do
    wait_for_jobs
    (
      local repo_name
      repo_name=$(basename "$repo")
      local target_dir="$clone_path/$repo_name"
      
      if [ -d "$target_dir" ]; then
        print_warning "Skipped $repo (Directory exists)"
      else
        print_verbose "Cloning $repo to $target_dir"
        if gh repo clone "$repo" "$target_dir" &>/dev/null; then
          print_success "Cloned: $repo"
        else
          print_error "Failed: $repo"
        fi
      fi
    ) &
    ((current++)) || true
    # Progress indicator
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories queued..." "$current" "$total" >&2
  done
  wait
  echo "" >&2
  print_success "All clone operations completed."
}

# --- Action: Sync ---

action_sync() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local dry_run=false
  local sync_all=false
  local max_depth=3

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    --all)
      sync_all=true
      shift
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *)
      # Legacy: first positional arg is path
      if [ -d "$1" ]; then
        base_path="$1"
      fi
      shift
      ;;
    esac
  done

  print_info "Scanning for git repositories in $base_path..."
  print_verbose "Max depth: $max_depth, Dry run: $dry_run, Sync all: $sync_all"

  # Find git dirs
  local git_dirs
  # Use -print0 and xargs -0 to handle paths with spaces correctly
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune -print0 2>/dev/null | xargs -0 -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found."
    return
  fi

  print_info "Found ${#git_dirs[@]} repositories"

  local selected_paths
  if [ "$sync_all" = "true" ]; then
    # Non-interactive: sync all found repos
    selected_paths=$(printf "%s\n" "${git_dirs[@]}")
  else
    # Interactive selection
    selected_paths=$(printf "%s\n" "${git_dirs[@]}" |
      fzf --multi --height=40% --border --header="Select repos to SYNC (--all to skip)" --prompt="Repos > ")
  fi

  [ -z "$selected_paths" ] && return

  local total
  total=$(echo "$selected_paths" | wc -l)
  local current=0

  print_info "Syncing $total repositories in parallel..."
  [ "$dry_run" = "true" ] && print_warning "DRY-RUN mode: no changes will be made"

  while IFS= read -r repo_path; do
    wait_for_jobs
    (
      repo_name=$(basename "$repo_path")
      
      # Check for dirty state
      if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "Skipped $repo_name (Dirty state)"
        exit 0
      fi

      if [ "$dry_run" = "true" ]; then
        # Dry run: just fetch and show what would happen
        git -C "$repo_path" fetch --quiet 2>/dev/null || true
        local behind
        behind=$(git -C "$repo_path" rev-list HEAD..@{u} --count 2>/dev/null || echo "0")
        if [ "$behind" -gt 0 ]; then
          print_info "[DRY-RUN] Would pull $behind commits: $repo_name"
        else
          echo -e "${CYAN}[DRY-RUN]${NC} Already up to date: $repo_name"
        fi
      else
        # Actual sync
        if output=$(git -C "$repo_path" pull --ff-only 2>&1); then
          if [[ "$output" == *"Already up to date"* ]]; then
            echo -e "${CYAN}[NO CHANGE]${NC} $repo_name"
          else
            print_success "Synced: $repo_name"
          fi
        else
          print_error "Failed: $repo_name (Conflict or Diverged)"
        fi
      fi
    ) &
    ((current++)) || true
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories processing..." "$current" "$total" >&2
  done <<<"$selected_paths"

  wait
  echo "" >&2
  print_success "Sync completed."
}

# --- Action: Delete ---

check_delete_scope() {
  if ! gh auth status 2>&1 | grep -q "delete_repo"; then
    print_error "Missing 'delete_repo' scope required for repository deletion."
    echo ""
    read -p "Would you like to refresh auth with delete_repo scope? [y/N]: " response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      print_info "Running: gh auth refresh -s delete_repo"
      if gh auth refresh -s delete_repo; then
        print_success "Auth scope updated successfully."
        return 0
      else
        print_error "Failed to update auth scope."
        return 1
      fi
    else
      print_warning "Cannot proceed without delete_repo scope."
      return 1
    fi
  fi
  return 0
}

action_delete() {
  check_dependencies

  # Check delete scope - block if not available
  if ! check_delete_scope; then
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --multi --height=40% --border --header="SELECT REPOS TO DELETE (NO UNDO)" --color='pointer:red,marker:red,header:red')

  [ -z "$selected" ] && return

  local repos=()
  while read -r repo; do repos+=("$repo"); done <<<"$selected"

  echo ""
  print_warning "You are about to delete ${#repos[@]} repositories:"
  printf "  - ${RED}%s${NC}\n" "${repos[@]}"
  echo ""

  read -p "Type 'DELETE' to confirm, or anything else for Dry Run: " confirm
  local dry_run=true
  if [ "$confirm" == "DELETE" ]; then
    dry_run=false
  fi

  for repo in "${repos[@]}"; do
    if [ "$dry_run" = "true" ]; then
      print_info "[DRY-RUN] Would delete: $repo"
    else
      echo -e "${RED}[DELETING]${NC} $repo"
      if gh repo delete "$repo" --yes; then
        print_success "Deleted: $repo"
      else
        print_error "Failed to delete: $repo"
      fi
    fi
  done

  if [ "$dry_run" != "true" ]; then
    rm -f "$CACHE_FILE"
    print_info "Cache cleared (repo deleted)"
  fi
}

# --- Action: Create (Simplified) ---

action_create() {
  show_header "CREATE REPOSITORY" "Set up a new GitHub repository"

  # Get repository name
  local name
  if use_gum; then
    name=$(gum input --placeholder "Repository name" \
      --prompt "› " \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT")
  else
    read -p "Repository Name: " name
  fi

  if [ -z "$name" ]; then
    print_error "Name required"
    return
  fi

  # Get description
  local desc
  if use_gum; then
    desc=$(gum input --placeholder "Description (optional)" \
      --prompt "› " \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT")
  else
    read -p "Description: " desc
  fi

  # Select visibility
  local vis
  if use_gum; then
    vis=$(gum choose --header "Visibility:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      "public" "private")
  else
    vis=$(echo -e "public\nprivate" | fzf --height=10% --prompt="Visibility > ")
  fi
  [ -z "$vis" ] && vis="private"

  # Select template
  local tpl
  if use_gum; then
    tpl=$(gum choose --header "Template:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      "none" "python" "node" "go")
  else
    tpl=$(echo -e "none\npython\nnode\ngo" | fzf --height=15% --prompt="Template > ")
  fi

  # Confirm creation
  echo ""
  if use_gum; then
    gum style --border rounded --border-foreground "$COLOR_SECONDARY" --padding "1 2" \
      "Repository: $name" "Visibility: $vis" "Template: ${tpl:-none}"
    echo ""
  fi

  local cmd_args=("gh" "repo" "create" "$name" "--$vis")
  if [ -n "$desc" ]; then
    cmd_args+=("--description" "$desc")
  fi

  # Create with clone
  print_info "Creating repository..."
  if "${cmd_args[@]}" --clone; then
    print_success "Repository created: $name"
    if [ "$tpl" != "none" ] && [ -d "$name" ]; then
      print_info "Applying template: $tpl"
      apply_template "$name" "$tpl"
      # Commit template locally
      (cd "$name" && git add . && git commit -m "Initial commit (Template: $tpl)") &>/dev/null
      # Ask before pushing
      if gum_confirm "Push initial commit to origin?" "yes"; then
        (cd "$name" && git push origin HEAD) &>/dev/null
        print_success "Template applied and pushed"
      else
        print_success "Template applied (not pushed). Push manually with: cd $name && git push"
      fi
    fi
  else
    print_error "Failed to create repository."
  fi
}

# --- Templates Logic ---

apply_template() {
  local dir="$1"
  local lang="$2"

  case "$lang" in
  python)
    echo "# $dir" >"$dir/README.md"
    touch "$dir/__init__.py"
    echo -e "def main():\n    print('Hello Python')\n\nif __name__ == '__main__':\n    main()" >"$dir/main.py"
    echo "git filtering..."
    cat <<EOT >"$dir/.gitignore"
__pycache__/
*.py[cod]
.venv/
EOT
    ;;
  node)
    echo "# $dir" >"$dir/README.md"
    echo "console.log('Hello Node');" >"$dir/index.js"
    cat <<EOT >"$dir/package.json"
{
  "name": "$dir",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT"
}
EOT
    cat <<EOT >"$dir/.gitignore"
node_modules/
.env
EOT
    ;;
  go)
    echo "# $dir" >"$dir/README.md"
    cat <<EOT >"$dir/main.go"
package main
import "fmt"
func main() {
    fmt.Println("Hello Go")
}
EOT
    (cd "$dir" && go mod init "github.com/$(gh api user -q .login)/$dir" 2>/dev/null || true)
    ;;
  esac
  print_info "Applied $lang template."
}

# --- Action: Fork ---

action_fork() {
  local search_query=""
  local clone_after=false

  while [[ $# -gt 0 ]]; do
    case $1 in
    --clone)
      clone_after=true
      shift
      ;;
    *)
      search_query="$1"
      shift
      ;;
    esac
  done

  if [ -z "$search_query" ]; then
    read -p "Search for repository to fork: " search_query
    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi
  fi

  print_info "Searching GitHub for '$search_query'..."

  local results
  results=$(gh search repos "$search_query" --limit 50 --json fullName,description,stargazersCount,language \
    2>/dev/null | jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=50% --border \
    --header="Select repository to FORK (TAB for multi)" \
    --delimiter='\t' --with-nth=1,2,3 --multi \
    --preview="echo {4}" --preview-window=down:2:wrap)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _ _ _; do
    print_info "Forking $repo..."
    if gh repo fork "$repo" --clone="$clone_after" 2>/dev/null; then
      print_success "Forked: $repo"
      if [ "$clone_after" = "true" ]; then
        print_success "Cloned to: $(basename "$repo")"
      fi
    else
      print_error "Failed to fork: $repo"
    fi
  done <<<"$selected"
}

# --- Action: Explore (External Search) ---

action_explore() {
  local search_query=""
  local sort_by="stars"
  local language=""
  local limit=100

  while [[ $# -gt 0 ]]; do
    case $1 in
    --sort)
      sort_by="$2"
      shift 2
      ;;
    --lang)
      language="$2"
      shift 2
      ;;
    --limit)
      limit="$2"
      shift 2
      ;;
    *)
      search_query="$search_query $1"
      shift
      ;;
    esac
  done

  search_query=$(echo "$search_query" | xargs) # trim

  if [ -z "$search_query" ]; then
    show_header "EXPLORE GITHUB" "Search repositories worldwide"

    # Get search query
    if use_gum; then
      search_query=$(gum input --placeholder "Search query (e.g., 'machine learning')" \
        --prompt "› " \
        --prompt.foreground "$COLOR_PRIMARY" \
        --cursor.foreground "$COLOR_ACCENT")
    else
      read -p "Search query: " search_query
    fi

    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi

    # Get sort option
    if use_gum; then
      local sort_choice
      sort_choice=$(gum choose --header "Sort by:" \
        --cursor "› " \
        --cursor.foreground "$COLOR_ACCENT" \
        --header.foreground "$COLOR_PRIMARY" \
        "stars" "forks" "updated" "help-wanted-issues")
      sort_by="${sort_choice:-stars}"
    else
      echo ""
      echo "Sort by: (s)tars | (f)orks | (u)pdated | (h)elp-wanted"
      read -p "Sort [stars]: " sort_choice
      case "$sort_choice" in
      f) sort_by="forks" ;;
      u) sort_by="updated" ;;
      h) sort_by="help-wanted-issues" ;;
      *) sort_by="stars" ;;
      esac
    fi

    # Get language filter
    if use_gum; then
      language=$(gum input --placeholder "Filter by language (leave empty for all)" \
        --prompt "› " \
        --prompt.foreground "$COLOR_PRIMARY" \
        --cursor.foreground "$COLOR_ACCENT")
    else
      read -p "Filter by language (leave empty for all): " language
    fi
  fi

  print_info "Searching GitHub for '$search_query' (sorted by $sort_by)..."

  local cmd_args=("gh" "search" "repos" "$search_query" "--limit" "$limit" "--sort" "$sort_by")
  [ -n "$language" ] && cmd_args+=("--language" "$language")

  local results
  results=$("${cmd_args[@]}" --json fullName,description,stargazersCount,forksCount,language,updatedAt,license 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.forksCount)🍴\t\(.language // "-")\t\(.updatedAt[:10])\t\(.description // "No description")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local count
  count=$(echo "$results" | wc -l)
  print_info "Found $count repositories"

  local selected
  selected=$(echo "$results" | fzf --height=70% --border \
    --header="🔭 Explore: $search_query | Actions: Enter=select, TAB=multi" \
    --delimiter='\t' --with-nth=1,2,3,4,5 \
    --preview="echo -e 'Repository: {1}\nStars: {2} | Forks: {3}\nLanguage: {4} | Updated: {5}\n\nDescription:\n{6}'" \
    --preview-window=down:6:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  if use_gum; then
    gum style --foreground "$COLOR_SECONDARY" "Selected ${#repos[@]} repositories:"
    for r in "${repos[@]}"; do
      gum style --foreground "$COLOR_INFO" "  $r"
    done
  else
    echo -e "${CYAN}Selected ${#repos[@]} repositories:${NC}"
    printf "  - ${BLUE}%s${NC}\n" "${repos[@]}"
  fi
  echo ""

  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Fork - Fork to your account" \
      "Fork + Clone - Fork and clone" \
      "Browse - Open in browser" \
      "Star - Star the repository" \
      "Info - Show detailed info" \
      "Cancel")
  else
    echo -e "${YELLOW}Actions:${NC}"
    echo "  (c) Clone          - Clone to local machine"
    echo "  (f) Fork           - Fork to your account"
    echo "  (F) Fork + Clone   - Fork and clone"
    echo "  (b) Browse         - Open in browser"
    echo "  (s) Star           - Star the repository"
    echo "  (i) Info           - Show detailed info"
    echo "  (q) Quit           - Cancel"
    echo ""
    read -p "Action: " action
  fi

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      print_info "Cloning $repo..."
      if gh repo clone "$repo" 2>/dev/null; then
        print_success "Cloned: $repo"
      else
        print_error "Failed to clone: $repo"
      fi
    done
    ;;
  f|"Fork - Fork"*)
    for repo in "${repos[@]}"; do
      print_info "Forking $repo..."
      if gh repo fork "$repo" --clone=false 2>/dev/null; then
        print_success "Forked: $repo"
      else
        print_error "Failed to fork: $repo"
      fi
    done
    ;;
  F|"Fork + Clone"*)
    for repo in "${repos[@]}"; do
      print_info "Forking and cloning $repo..."
      if gh repo fork "$repo" --clone=true 2>/dev/null; then
        print_success "Forked and cloned: $repo"
      else
        print_error "Failed: $repo"
      fi
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      print_info "Opening $repo in browser..."
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  s|"Star"*)
    for repo in "${repos[@]}"; do
      print_info "Starring $repo..."
      if gh api -X PUT "user/starred/$repo" 2>/dev/null; then
        print_success "Starred: $repo"
      else
        print_error "Failed to star: $repo"
      fi
    done
    ;;
  i|"Info"*)
    for repo in "${repos[@]}"; do
      show_header "$repo" "Repository Details"
      gh repo view "$repo" 2>/dev/null || print_error "Failed to fetch info"
      echo ""
      if use_gum; then
        gum confirm "Continue?" --affirmative "OK" --negative "" --default=true || true
      else
        read -p "Press Enter to continue..."
      fi
    done
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Trending ---

action_trending() {
  local language="${1:-}"
  local since="daily"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --lang)
      language="$2"
      shift 2
      ;;
    --since)
      since="$2"
      shift 2
      ;;
    *)
      [ -z "$language" ] && language="$1"
      shift
      ;;
    esac
  done

  show_header "TRENDING REPOSITORIES" "Hot projects this week"

  local query="stars:>100 pushed:>$(date -d '7 days ago' '+%Y-%m-%d' 2>/dev/null || date -v-7d '+%Y-%m-%d')"
  [ -n "$language" ] && query="$query language:$language"

  print_info "Fetching trending repositories${language:+ for $language}..."

  local results
  results=$(gh search repos "$query" --sort stars --order desc --limit 30 \
    --json fullName,description,stargazersCount,language,updatedAt 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No trending repositories found"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=60% --border \
    --header="🔥 Trending${language:+ ($language)} | TAB=multi-select" \
    --delimiter='\t' --with-nth=1,2,3 \
    --preview="echo {4}" --preview-window=down:3:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Fork - Fork to your account" \
      "Browse - Open in browser" \
      "Star - Star the repository" \
      "Cancel")
  else
    echo "Actions: (c)lone | (f)ork | (b)rowse | (s)tar | (q)uit"
    read -p "Action: " action
  fi

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" 2>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  f|"Fork"*)
    for repo in "${repos[@]}"; do
      gh repo fork "$repo" --clone=false 2>/dev/null && print_success "Forked: $repo" || print_error "Failed: $repo"
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  s|"Star"*)
    for repo in "${repos[@]}"; do
      gh api -X PUT "user/starred/$repo" 2>/dev/null && print_success "Starred: $repo" || print_error "Failed: $repo"
    done
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Archive ---

action_archive() {
  local mode="archive"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --unarchive)
      mode="unarchive"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filter_jq
  local header_text
  if [ "$mode" = "archive" ]; then
    filter_jq='[.[] | select(.isArchived == false)]'
    header_text="Select repos to ARCHIVE"
  else
    filter_jq='[.[] | select(.isArchived == true)]'
    header_text="Select repos to UNARCHIVE"
  fi

  local filtered
  filtered=$(echo "$json" | jq "$filter_jq")

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories available to $mode"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  print_warning "You are about to $mode ${#repos[@]} repositories:"
  printf "  - %s\n" "${repos[@]}"
  echo ""
  read -p "Continue? [y/N]: " confirm

  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    print_info "Cancelled."
    return
  fi

  for repo in "${repos[@]}"; do
    print_info "${mode^}ing $repo..."
    if [ "$mode" = "archive" ]; then
      if gh repo archive "$repo" --yes 2>/dev/null; then
        print_success "Archived: $repo"
      else
        print_error "Failed to archive: $repo"
      fi
    else
      if gh repo unarchive "$repo" --yes 2>/dev/null; then
        print_success "Unarchived: $repo"
      else
        print_error "Failed to unarchive: $repo"
      fi
    fi
  done

  rm -f "$CACHE_FILE"
  print_info "Cache cleared (repo states changed)"
}

# --- Action: Stats ---

action_stats() {
  local json
  json=$(fetch_repositories_json "true")

  show_header "REPOSITORY STATISTICS" "Your GitHub Overview"

  local total public private archived
  total=$(echo "$json" | jq 'length')
  public=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")] | length')
  private=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")] | length')
  archived=$(echo "$json" | jq '[.[] | select(.isArchived == true)] | length')

  if use_gum; then
    # Build stats box with gum
    local stats_content
    stats_content=$(printf "Total Repositories:  %s\nPublic:              %s\nPrivate:             %s\nArchived:            %s" "$total" "$public" "$private" "$archived")
    gum style --border rounded --border-foreground "$COLOR_SECONDARY" --padding "1 2" --margin "0 2" "$stats_content"
  else
    echo -e "  ${GREEN}Total Repositories:${NC}  $total"
    echo -e "  ${GREEN}Public:${NC}              $public"
    echo -e "  ${YELLOW}Private:${NC}             $private"
    echo -e "  ${CYAN}Archived:${NC}            $archived"
  fi
  echo ""

  local total_stars total_forks total_size
  total_stars=$(echo "$json" | jq '[.[].stargazerCount] | add // 0')
  total_forks=$(echo "$json" | jq '[.[].forkCount] | add // 0')
  total_size=$(echo "$json" | jq '[.[].diskUsage] | add // 0')
  local size_mb=$((total_size / 1024))

  if use_gum; then
    local metrics_content
    metrics_content=$(printf "Total Stars:   %s\nTotal Forks:   %s\nTotal Size:    %s MB" "$total_stars" "$total_forks" "$size_mb")
    gum style --border rounded --border-foreground "$COLOR_ACCENT" --padding "1 2" --margin "0 2" "$metrics_content"
  else
    echo -e "  ${YELLOW}⭐ Total Stars:${NC}       $total_stars"
    echo -e "  ${BLUE}🍴 Total Forks:${NC}       $total_forks"
    echo -e "  ${CYAN}💾 Total Size:${NC}        ${size_mb} MB"
  fi
  echo ""

  show_divider "Languages Breakdown"
  echo ""

  local lang_data
  lang_data=$(echo "$json" | jq -r '
    [.[] | .primaryLanguage.name // "Unknown"] |
    group_by(.) |
    map({lang: .[0], count: length}) |
    sort_by(-.count) |
    .[:10] |
    .[] |
    "\(.lang): \(.count)"
  ')

  if use_gum; then
    echo "$lang_data" | while read -r line; do
      gum style --foreground "$COLOR_SECONDARY" "  $line"
    done
  else
    echo "$lang_data" | sed 's/^/  /'
  fi
  echo ""

  show_divider "Top Repositories (by Stars)"
  echo ""

  echo "$json" | jq -r '
    sort_by(-.stargazerCount) |
    .[:5] |
    .[] |
    "  \(.stargazerCount)\t\(.nameWithOwner)"
  ' | while IFS=$'\t' read -r stars name; do
    if use_gum; then
      local star_styled
      star_styled=$(gum style --foreground "$COLOR_WARNING" "$stars")
      local name_styled
      name_styled=$(gum style --foreground "$COLOR_SECONDARY" "$name")
      echo "$star_styled $name_styled"
    else
      printf "  %-6s %s\n" "$stars" "$name"
    fi
  done
  echo ""

  show_divider "Recently Updated (last 5)"
  echo ""

  echo "$json" | jq -r '
    sort_by(.updatedAt) | reverse |
    .[:5] |
    .[] |
    "\(.updatedAt[:10])\t\(.nameWithOwner)"
  ' | while IFS=$'\t' read -r date name; do
    if use_gum; then
      local date_styled
      date_styled=$(gum style --foreground "$COLOR_MUTED" "$date")
      local name_styled
      name_styled=$(gum style --foreground "$COLOR_SECONDARY" "$name")
      echo "  $date_styled $name_styled"
    else
      printf "  %-12s %s\n" "$date" "$name"
    fi
  done
  echo ""
}

# --- Action: Search ---

action_search() {
  local json
  json=$(fetch_repositories_json "false")

  print_info "Type to search (fuzzy matching on name and description)..."

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "No description")\t\(.visibility)\t\(.primaryLanguage.name // "-")"' |
    fzf --height=60% --border \
      --header="Search repositories (ESC to cancel)" \
      --delimiter='\t' \
      --with-nth=1,3,4 \
      --preview="echo -e 'Description:\n{2}'" \
      --preview-window=down:3:wrap \
      --multi)

  [ -z "$selected" ] && return

  echo ""
  if use_gum; then
    gum style --foreground "$COLOR_SECONDARY" "Selected repositories:"
    while IFS=$'\t' read -r repo desc vis lang; do
      gum style --foreground "$COLOR_INFO" "  $repo [$vis] ($lang)"
    done <<<"$selected"
  else
    echo -e "${CYAN}Selected repositories:${NC}"
    while IFS=$'\t' read -r repo desc vis lang; do
      echo -e "  ${BLUE}$repo${NC} [$vis] ($lang)"
    done <<<"$selected"
  fi

  echo ""
  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Browse - Open in browser" \
      "Delete - Delete repositories" \
      "Cancel")
  else
    echo "Actions: (c)lone | (b)rowse | (d)elete | (q)uit"
    read -p "Action: " action
  fi

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" &>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  d|"Delete"*)
    print_warning "Delete selected repos? This is NOT reversible!"
    local confirm
    if use_gum; then
      confirm=$(gum input --placeholder "Type DELETE to confirm" \
        --prompt "› " \
        --prompt.foreground "$COLOR_ERROR" \
        --cursor.foreground "$COLOR_ERROR")
    else
      read -p "Type 'DELETE' to confirm: " confirm
    fi
    if [ "$confirm" = "DELETE" ]; then
      for repo in "${repos[@]}"; do
        gh repo delete "$repo" --yes 2>/dev/null && print_success "Deleted: $repo" || print_error "Failed: $repo"
      done
      rm -f "$CACHE_FILE"
      print_info "Cache cleared (repo deleted)"
    else
      print_info "Cancelled"
    fi
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Browse ---

action_browse() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="Select repos to open in browser" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _; do
    print_info "Opening $repo in browser..."
    gh browse -R "$repo" 2>/dev/null &
  done <<<"$selected"

  print_success "Opened selected repositories in browser"
}

# --- Action: Visibility ---

action_visibility() {
  local target_visibility=""

  while [[ $# -gt 0 ]]; do
    case $1 in
    --public)
      target_visibility="public"
      shift
      ;;
    --private)
      target_visibility="private"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filtered header_text
  if [ "$target_visibility" = "public" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")]')
    header_text="Select PRIVATE repos to make PUBLIC"
  elif [ "$target_visibility" = "private" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")]')
    header_text="Select PUBLIC repos to make PRIVATE"
  else
    filtered="$json"
    header_text="Select repos to toggle visibility"
  fi

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories match the criteria"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.visibility)"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t')

  [ -z "$selected" ] && return

  local repos=()
  local visibilities=()
  while IFS=$'\t' read -r repo vis; do
    repos+=("$repo")
    visibilities+=("$vis")
  done <<<"$selected"

  print_warning "Visibility changes:"
  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi
    echo -e "  ${repos[$i]}: ${visibilities[$i]} → ${new_vis^^}"
  done

  echo ""
  read -p "Continue? [y/N]: " confirm
  [[ ! "$confirm" =~ ^[Yy]$ ]] && return

  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi

    print_info "Changing ${repos[$i]} to $new_vis..."
    if gh repo edit "${repos[$i]}" --visibility "$new_vis" 2>/dev/null; then
      print_success "Updated: ${repos[$i]}"
    else
      print_error "Failed: ${repos[$i]}"
    fi
  done

  rm -f "$CACHE_FILE"
}

# --- Action: PR (Pull Requests) ---

action_pr() {
  local subcommand="${1:-list}"
  shift 2>/dev/null || true

  case "$subcommand" in
  list)
    action_pr_list "$@"
    ;;
  create)
    action_pr_create "$@"
    ;;
  *)
    print_error "Unknown PR subcommand: $subcommand"
    echo "Usage: ghtools pr {list|create}"
    ;;
  esac
}

action_pr_list() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --height=40% --border --header="Select repository to list PRs")

  [ -z "$selected" ] && return

  print_info "Fetching PRs for $selected..."
  echo ""

  gh pr list -R "$selected" --limit 20 --json number,title,state,author,createdAt \
    --template '{{range .}}#{{.number}} [{{.state}}] {{.title}} (by {{.author.login}}, {{timeago .createdAt}})
{{end}}'
}

action_pr_create() {
  if [ ! -d ".git" ]; then
    print_error "Not in a git repository"
    return 1
  fi

  local current_branch
  current_branch=$(git branch --show-current)

  # Handle detached HEAD state
  if [ -z "$current_branch" ]; then
    print_error "You are in 'detached HEAD' state. Please checkout a branch first."
    print_info "Tip: Use 'git checkout -b branch-name' to create a new branch from current state."
    return 1
  fi

  if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
    print_warning "You're on $current_branch branch. Create a feature branch first."
    return 1
  fi

  print_info "Creating PR from branch: $current_branch"

  read -p "PR Title: " title
  [ -z "$title" ] && title="$current_branch"

  local draft=""
  read -p "Create as draft? [y/N]: " is_draft
  [[ "$is_draft" =~ ^[Yy]$ ]] && draft="--draft"

  # Push branch if needed
  if ! git ls-remote --exit-code --heads origin "$current_branch" &>/dev/null; then
    print_info "Pushing branch to origin..."
    git push -u origin "$current_branch"
  fi

  # shellcheck disable=SC2086
  if gh pr create --title "$title" --body "" $draft; then
    print_success "PR created successfully"
  else
    print_error "Failed to create PR"
  fi
}

# --- Action: Status ---

action_status() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local max_depth=3

  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  print_info "Scanning repositories in $base_path..."

  local git_dirs
  # Use -print0 and xargs -0 to handle paths with spaces correctly
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune -print0 2>/dev/null | xargs -0 -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found"
    return
  fi

  echo ""
  printf "${CYAN}%-35s %-12s %-10s %-10s %s${NC}\n" "REPOSITORY" "BRANCH" "STATUS" "AHEAD" "BEHIND"
  printf "${CYAN}%s${NC}\n" "$(printf '%*s' 85 '' | tr ' ' '-')"

  for repo_path in "${git_dirs[@]}"; do
    local repo_name branch status_icon ahead behind
    repo_name=$(basename "$repo_path")
    branch=$(git -C "$repo_path" branch --show-current 2>/dev/null || echo "detached")

    # Check dirty state
    local dirty=false
    if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
      dirty=true
    fi

    # Check untracked files
    local untracked=false
    if [ -n "$(git -C "$repo_path" ls-files --others --exclude-standard 2>/dev/null)" ]; then
      untracked=true
    fi

    # Determine status
    if [ "$dirty" = "true" ] && [ "$untracked" = "true" ]; then
      status_icon="${RED}dirty+untrk${NC}"
    elif [ "$dirty" = "true" ]; then
      status_icon="${YELLOW}dirty${NC}"
    elif [ "$untracked" = "true" ]; then
      status_icon="${YELLOW}untracked${NC}"
    else
      status_icon="${GREEN}clean${NC}"
    fi

    # Check ahead/behind
    ahead=$(git -C "$repo_path" rev-list --count @{u}..HEAD 2>/dev/null || echo "?")
    behind=$(git -C "$repo_path" rev-list --count HEAD..@{u} 2>/dev/null || echo "?")

    local ahead_color="$NC" behind_color="$NC"
    [ "$ahead" != "0" ] && [ "$ahead" != "?" ] && ahead_color="$GREEN"
    [ "$behind" != "0" ] && [ "$behind" != "?" ] && behind_color="$RED"

    printf "%-35s %-12s ${status_icon}%-10s ${ahead_color}%-10s${NC} ${behind_color}%s${NC}\n" \
      "$(truncate_text "$repo_name" 35)" "$branch" "" "$ahead" "$behind"
  done

  echo ""
  print_info "Legend: ${GREEN}clean${NC} | ${YELLOW}dirty/untracked${NC} | ${GREEN}ahead${NC} (unpushed) | ${RED}behind${NC} (needs pull)"
}

# --- Main Menu ---

show_menu() {
  # Show beautiful header
  if use_gum; then
    clear
    gum style \
      --border rounded \
      --border-foreground "$COLOR_PRIMARY" \
      --foreground "$COLOR_SECONDARY" \
      --align center \
      --width 50 \
      --padding "1 2" \
      --margin "1 0" \
      "GHTOOLS" "GitHub Repository Manager v$VERSION"
    echo ""
  fi

  local options=(
    "List Repositories"
    "Search My Repos"
    "Explore GitHub"
    "Trending Repos"
    "Statistics Dashboard"
    "Clone Repositories"
    "Sync Local Repos"
    "Local Repo Status"
    "Fork Repository"
    "Create Repository"
    "Delete Repositories"
    "Archive/Unarchive"
    "Change Visibility"
    "Browse in Browser"
    "Pull Requests"
    "Config"
    "Refresh Cache"
    "Exit"
  )

  local choice
  if use_gum; then
    choice=$(printf '%s\n' "${options[@]}" | gum choose \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header "Select an action:" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      --height 20)
  else
    local options_legacy="📋 List Repositories
🔍 Search My Repos
🔭 Explore GitHub
🔥 Trending Repos
📊 Statistics Dashboard
📦 Clone Repositories
🔄 Sync Local Repos
📁 Local Repo Status
🍴 Fork Repository
➕ Create Repository
🗑️  Delete Repositories
📦 Archive/Unarchive
🔒 Change Visibility
🌐 Browse in Browser
📝 Pull Requests
⚙️  Config
🔄 Refresh Cache
🚪 Exit"
    choice=$(echo "$options_legacy" | fzf --height=55% --border --header="GitHub Tools v$VERSION" --layout=reverse)
  fi

  case "$choice" in
  *"List"*) action_list ;;
  *"Search My"*) action_search ;;
  *"Explore"*) action_explore ;;
  *"Trending"*) action_trending ;;
  *"Statistics"*) action_stats ;;
  *"Clone"*) action_clone ;;
  *"Sync"*) action_sync ;;
  *"Local Repo Status"*) action_status ;;
  *"Fork"*) action_fork ;;
  *"Create"*) action_create ;;
  *"Delete"*) action_delete ;;
  *"Archive"*) action_archive ;;
  *"Visibility"*) action_visibility ;;
  *"Browse"*) action_browse ;;
  *"Pull Requests"*) action_pr ;;
  *"Config"*)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;
  *"Refresh"*)
    rm -f "$CACHE_FILE"
    print_success "Cache cleared."
    show_menu
    ;;
  *"Exit"*) exit 0 ;;
  *) exit 0 ;;
  esac
}

# --- Entry Point ---

main() {
  # Parse global options first
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_usage
      exit 0
      ;;
    -v | --version)
      echo "ghtools $VERSION"
      exit 0
      ;;
    -V | --verbose)
      VERBOSE=true
      shift
      ;;
    -q | --quiet)
      QUIET=true
      shift
      ;;
    *)
      # Stop parsing global options, pass to command handler
      break
      ;;
    esac
  done

  check_dependencies
  check_gh_auth

  if [ $# -eq 0 ]; then
    while true; do
      show_menu
      echo ""
      read -p "Press Enter to continue..."
    done
  fi

  case "$1" in
  list)
    shift
    action_list "$@"
    ;;
  clone)
    shift
    action_clone "$@"
    ;;
  sync)
    shift
    action_sync "$@"
    ;;
  create) action_create ;;
  delete) action_delete ;;
  fork)
    shift
    action_fork "$@"
    ;;
  archive)
    shift
    action_archive "$@"
    ;;
  stats) action_stats ;;
  search) action_search ;;
  browse) action_browse ;;
  explore)
    shift
    action_explore "$@"
    ;;
  trending)
    shift
    action_trending "$@"
    ;;
  visibility)
    shift
    action_visibility "$@"
    ;;
  pr)
    shift
    action_pr "$@"
    ;;
  status)
    shift
    action_status "$@"
    ;;
  config)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;

# Only run main if executed directly (not sourced) and not in test mode
if [[ "${BASH_SOURCE[0]}" == "${0}" ]] && [[ "${GHTOOLS_TEST_MODE:-}" != "1" ]]; then
  main "$@"
fi
</file>
<file path="install.sh">
#!/bin/bash

# GitHub Tools Installation Script
# This script installs ghtools to ~/scripts

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

echo -e "${BLUE}╔════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║     GitHub Tools Installation Script      ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════╝${NC}"
echo ""

# Check if running as root
if [ "$EUID" -eq 0 ]; then
    print_warning "Please do not run this script as root (with sudo)"
    echo "The script will ask for sudo password when needed."
    exit 1
fi

# Get the directory where the install script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GHTOOLS_SCRIPT="$SCRIPT_DIR/ghtools"

# Check if script exists
if [ ! -f "$GHTOOLS_SCRIPT" ]; then
    print_error "ghtools script not found at: $GHTOOLS_SCRIPT"
    exit 1
fi

print_info "Found ghtools script at: $GHTOOLS_SCRIPT"

# Check dependencies
print_info "Checking dependencies..."

missing_deps=()

if ! command -v gh &> /dev/null; then
    missing_deps+=("gh (GitHub CLI)")
fi

if ! command -v fzf &> /dev/null; then
    missing_deps+=("fzf")
fi

if ! command -v git &> /dev/null; then
    missing_deps+=("git")
fi

if ! command -v jq &> /dev/null; then
    missing_deps+=("jq")
fi

# Check for optional but recommended dependencies
optional_deps=()
if ! command -v gum &> /dev/null; then
    optional_deps+=("gum")
fi

if [ ${#missing_deps[@]} -ne 0 ]; then
    print_error "Missing required dependencies:"
    for dep in "${missing_deps[@]}"; do
        echo "  - $dep"
    done
    echo ""
    echo "Install them using:"
    echo -e "  ${BLUE}sudo pacman -S github-cli fzf git jq gum${NC}"
    echo "  or"
    echo -e "  ${BLUE}yay -S github-cli fzf git jq gum${NC}"
    exit 1
fi

print_success "All required dependencies are installed"

# Notify about optional dependencies
if [ ${#optional_deps[@]} -ne 0 ]; then
    echo ""
    print_warning "Optional dependencies for enhanced UI:"
    for dep in "${optional_deps[@]}"; do
        echo -e "  ${YELLOW}•${NC} $dep - Beautiful terminal UI components"
    done
    echo ""
    echo -e "Install for best experience: ${CYAN}sudo pacman -S gum${NC}"
    echo ""
fi

# Create ~/scripts directory if it doesn't exist
INSTALL_DIR="$HOME/scripts"
mkdir -p "$INSTALL_DIR"

# Install script to ~/scripts
print_info "Installing script to $INSTALL_DIR..."

cp "$GHTOOLS_SCRIPT" "$INSTALL_DIR/ghtools"
chmod +x "$INSTALL_DIR/ghtools"

print_success "ghtools installed successfully!"

# ============================================================================
# PATH Configuration Functions
# ============================================================================

# Get all possible zsh config files
get_zsh_config_files() {
    local files=()

    # Main zsh config files
    [ -f "$HOME/.zshrc" ] && files+=("$HOME/.zshrc")
    [ -f "$HOME/.zshrc_custom" ] && files+=("$HOME/.zshrc_custom")
    [ -f "$HOME/.zshenv" ] && files+=("$HOME/.zshenv")
    [ -f "$HOME/.zprofile" ] && files+=("$HOME/.zprofile")
    [ -f "$HOME/.zlogin" ] && files+=("$HOME/.zlogin")

    # Modular config files
    if [ -d "$HOME/.config/zshrc" ]; then
        for config in "$HOME/.config/zshrc/"*; do
            [ -f "$config" ] && files+=("$config")
        done
    fi

    printf '%s\n' "${files[@]}"
}

# Check if scripts directory is already in PATH configuration files
# Returns: array of files containing the PATH
check_scripts_in_config_files() {
    local files_with_path=()
    local pattern="(export PATH=.*scripts|PATH=.*scripts)"

    while IFS= read -r file; do
        if grep -qE "$pattern" "$file" 2>/dev/null; then
            files_with_path+=("$file")
        fi
    done < <(get_zsh_config_files)

    printf '%s\n' "${files_with_path[@]}"
}

# Remove PATH configuration from a file
remove_path_from_file() {
    local file=$1
    local backup="${file}.backup_$(date +%s)"

    # Create backup
    cp "$file" "$backup"

    # Remove lines with scripts PATH
    sed -i '/export PATH=.*scripts/d' "$file"
    sed -i '/PATH=.*scripts/d' "$file"

    # Also remove the comment line if it exists
    sed -i '/# Add ~\/scripts to PATH/d' "$file"

    print_success "Removed PATH configuration from: $file"
    print_info "Backup created at: $backup"
}

# Add PATH to selected file
add_path_to_file() {
    local file=$1

    echo "" >> "$file"
    echo "# Add ~/scripts to PATH for custom scripts" >> "$file"
    echo "export PATH=\"\$HOME/scripts:\$PATH\"" >> "$file"

    print_success "Added PATH to: $file"
}

# ============================================================================
# PATH Configuration Management
# ============================================================================

echo ""
echo -e "${BLUE}═══════════════════════════════════════════${NC}"
echo -e "${BLUE}PATH Configuration Check${NC}"
echo -e "${BLUE}═══════════════════════════════════════════${NC}"
echo ""

# Check if scripts directory is in any config files
files_with_path=()
mapfile -t files_with_path < <(check_scripts_in_config_files)

# Check if currently in PATH
if [[ ":$PATH:" == *":$INSTALL_DIR:"* ]]; then
    print_success "$INSTALL_DIR is already in your PATH"

    # Check for duplicates in config files
    if [ ${#files_with_path[@]} -gt 1 ]; then
        echo ""
        print_warning "DUPLICATE DETECTED! PATH is configured in multiple files:"
        echo ""
        for file in "${files_with_path[@]}"; do
            line_info=$(grep -n "PATH=.*scripts" "$file" 2>/dev/null | head -1)
            echo -e "  ${YELLOW}→${NC} $file"
            echo -e "    Line: ${CYAN}$line_info${NC}"
        done
        echo ""
        echo "Having duplicates can cause PATH pollution and unexpected behavior."
        echo ""

        read -p "Would you like to remove duplicates? (y/N): " -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Select which file to KEEP the PATH configuration:"
            echo ""
            i=1
            for file in "${files_with_path[@]}"; do
                echo -e "  ${GREEN}$i${NC}) $file"
                ((i++))
            done
            echo -e "  ${RED}0${NC}) Cancel"
            echo ""

            read -p "Enter number: " -r file_choice

            if [[ "$file_choice" =~ ^[0-9]+$ ]] && [ "$file_choice" -ge 1 ] && [ "$file_choice" -le ${#files_with_path[@]} ]; then
                keep_file="${files_with_path[$((file_choice-1))]}"
                echo ""
                print_info "Keeping PATH configuration in: $keep_file"
                echo ""

                # Remove from all other files
                for file in "${files_with_path[@]}"; do
                    if [ "$file" != "$keep_file" ]; then
                        remove_path_from_file "$file"
                    fi
                done

                echo ""
                print_success "Duplicates removed successfully!"
                print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
            else
                print_info "Cancelled. No changes made."
            fi
        fi
    elif [ ${#files_with_path[@]} -eq 1 ]; then
        print_info "PATH is configured in: ${files_with_path[0]}"
    fi
else
    # Not in current PATH
    if [ ${#files_with_path[@]} -gt 0 ]; then
        print_warning "$INSTALL_DIR is configured but not in current PATH"
        echo ""
        echo "PATH is configured in the following file(s):"
        for file in "${files_with_path[@]}"; do
            echo "  → $file"
        done
        echo ""
        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"

        # Check for duplicates
        if [ ${#files_with_path[@]} -gt 1 ]; then
            echo ""
            print_warning "Multiple PATH configurations detected (duplicates)"
            read -p "Would you like to remove duplicates? (y/N): " -r
            echo ""

            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "Select which file to KEEP:"
                echo ""
                i=1
                for file in "${files_with_path[@]}"; do
                    echo -e "  ${GREEN}$i${NC}) $file"
                    ((i++))
                done
                echo ""

                read -p "Enter number: " -r file_choice

                if [[ "$file_choice" =~ ^[0-9]+$ ]] && [ "$file_choice" -ge 1 ] && [ "$file_choice" -le ${#files_with_path[@]} ]; then
                    keep_file="${files_with_path[$((file_choice-1))]}"
                    echo ""

                    for file in "${files_with_path[@]}"; do
                        if [ "$file" != "$keep_file" ]; then
                            remove_path_from_file "$file"
                        fi
                    done

                    print_success "Duplicates removed!"
                fi
            fi
        fi
    else
        # Not configured anywhere
        print_warning "$INSTALL_DIR is not in your PATH"
        echo ""
        echo "To use ghtools from anywhere, add it to your PATH."
        echo ""

        read -p "Would you like to add it now? (y/N): " -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # Offer file selection
            echo "Where would you like to add the PATH?"
            echo ""
            echo -e "  ${GREEN}1${NC}) ~/.zshrc ${CYAN}(recommended for general use)${NC}"
            echo -e "  ${GREEN}2${NC}) ~/.zshrc_custom ${CYAN}(for user customizations)${NC}"

            if [ -d "$HOME/.config/zshrc" ]; then
                echo -e "  ${GREEN}3${NC}) ~/.config/zshrc/00-init ${CYAN}(modular config)${NC}"
            fi

            echo -e "  ${RED}0${NC}) Skip"
            echo ""

            read -p "Enter number: " -r choice
            echo ""

            case "$choice" in
                1)
                    if [ -f "$HOME/.zshrc" ]; then
                        add_path_to_file "$HOME/.zshrc"
                        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
                    else
                        print_error "~/.zshrc not found"
                    fi
                    ;;
                2)
                    if [ -f "$HOME/.zshrc_custom" ]; then
                        add_path_to_file "$HOME/.zshrc_custom"
                        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
                    else
                        print_error "~/.zshrc_custom not found"
                    fi
                    ;;
                3)
                    if [ -d "$HOME/.config/zshrc" ]; then
                        add_path_to_file "$HOME/.config/zshrc/00-init"
                        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
                    else
                        print_error "~/.config/zshrc not found"
                    fi
                    ;;
                *)
                    print_info "Skipped. You can add it manually later."
                    echo ""
                    echo "Add this line to your preferred zsh config file:"
                    echo -e "  ${BLUE}export PATH=\"\$HOME/scripts:\$PATH\"${NC}"
                    ;;
            esac
        else
            print_info "Skipped. Add this line to your zsh config:"
            echo -e "  ${BLUE}export PATH=\"\$HOME/scripts:\$PATH\"${NC}"
        fi
    fi
fi

echo ""
print_success "Installation complete!"
echo ""
echo -e "Run ${GREEN}ghtools${NC} to start using the interactive menu!"

echo ""
echo -e "${CYAN}═══════════════════════════════════════════${NC}"
print_info "Usage:"
echo ""
echo -e "  ${GREEN}ghtools${NC}        - Interactive menu (recommended)"
echo -e "  ${GREEN}ghtools clone${NC}  - Clone repositories"
echo -e "  ${GREEN}ghtools delete${NC} - Delete repositories"
echo -e "  ${GREEN}ghtools help${NC}   - Show help message"
echo ""
print_info "To uninstall, run: rm ~/scripts/ghtools"
</file>
<file path="PLAN.md">
# Plano de Correção e Refatoração: ghtools

Este documento detalha o plano de ação para corrigir vulnerabilidades de segurança críticas, bugs de lógica e problemas de compatibilidade identificados na versão 3.1.0 do script `ghtools`.

**Objetivo:** Tornar o script seguro, robusto em ambientes multi-usuário e compatível com estruturas de diretórios complexas, sem alterar a funcionalidade core existente.

**Versão do Plano:** 2.0 (Revisado)

---

## Fase 1: Segurança Crítica (Prioridade Alta)

### 1.1. Eliminação de Injeção de Comandos (`eval`) em `action_create`
**Localização:** Linhas 904-909

O uso de `eval` para executar comandos construídos via string é a vulnerabilidade mais grave. Deve ser substituído pelo uso de **Arrays do Bash**, que tratam argumentos de forma segura automaticamente.

**Código Atual (Vulnerável):**
```bash
local cmd="gh repo create $name --$vis"
[ -n "$desc" ] && cmd="$cmd --description \"$desc\""
if eval "$cmd --clone"; then
```

**Código Corrigido:**
```bash
local cmd_args=("gh" "repo" "create" "$name" "--$vis")
if [ -n "$desc" ]; then
    cmd_args+=("--description" "$desc")
fi
if "${cmd_args[@]}" --clone; then
```

### 1.2. Eliminação de Injeção de Comandos (`eval`) em `action_explore`
**Localização:** Linhas 1114-1118

**Código Atual (Vulnerável):**
```bash
local gh_cmd="gh search repos \"$search_query\" --limit $limit --sort $sort_by"
[ -n "$language" ] && gh_cmd="$gh_cmd --language \"$language\""
results=$(eval "$gh_cmd" --json fullName,description,...)
```

**Código Corrigido:**
```bash
local cmd_args=("gh" "search" "repos" "$search_query" "--limit" "$limit" "--sort" "$sort_by")
[ -n "$language" ] && cmd_args+=("--language" "$language")
results=$("${cmd_args[@]}" --json fullName,description,...)
```

### 1.3. Eliminação de Injeção de Comandos (`eval`) em `run_with_spinner`
**Localização:** Linhas 212-228

**Problema:** A função `run_with_spinner` usa `eval` tanto no fallback quanto indiretamente via `bash -c`. Isso é perigoso se comandos contiverem entrada do usuário.

**Código Atual (Vulnerável):**
```bash
run_with_spinner() {
  local title="$1"
  shift
  local cmd="$@"
  if use_gum; then
    gum spin ... -- bash -c "$cmd"
  else
    if eval "$cmd"; then
```

**Solução:** Esta função deve receber um **array** ou ser refatorada para executar comandos diretamente. Como ela é usada internamente apenas com comandos fixos, uma abordagem segura é:

```bash
run_with_spinner() {
  local title="$1"
  shift
  # Executa diretamente o comando passado como argumentos separados
  if use_gum; then
    gum spin --spinner dot --spinner.foreground "$COLOR_ACCENT" --title "$title" -- "$@"
  else
    echo -n "$title... "
    if "$@"; then
      echo "done"
    else
      echo "failed"
      return 1
    fi
  fi
}
```
**Nota:** Verificar todos os call sites desta função para garantir compatibilidade.

### 1.4. Proteção do Arquivo de Cache (Permissões)
**Localização:** Linha 488

**Problema:** O arquivo de cache é criado sem controle de permissões, potencialmente expondo informações sobre repositórios privados a outros usuários.

**Ação:** Definir `umask` restritivo antes de criar o cache ou usar `install` com permissões explícitas.

```bash
# Antes de escrever no cache:
(umask 077 && $gh_cmd --limit "$limit" --json "$fields" > "$CACHE_FILE")
```

---

## Fase 2: Segurança Alta (Hardening)

### 2.1. Validação de Arquivo de Configuração (`source`)
**Localização:** Linhas 22-27

**Problema:** O uso de `source "$CONFIG_FILE"` executa qualquer código presente no arquivo de configuração. Se um atacante conseguir modificar este arquivo, pode executar código arbitrário.

**Mitigação Recomendada:**
*   Usar um parser mais seguro que apenas aceite atribuições de variáveis específicas.
*   Ou validar o conteúdo antes de source.

**Código Sugerido:**
```bash
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Valida que o arquivo contém apenas atribuições de variáveis conhecidas
        local allowed_vars="CACHE_TTL|CACHE_FILE|MAX_JOBS|DEFAULT_ORG|DEFAULT_CLONE_PATH"
        if grep -Evq "^[[:space:]]*(#.*)?$|^[[:space:]]*($allowed_vars)=" "$CONFIG_FILE"; then
            print_warning "Config file contains invalid lines. Skipping."
            return 1
        fi
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}
```

**Alternativa Simples:** Documentar que o arquivo de config deve ter permissões 600 e adicionar verificação:
```bash
if [ -f "$CONFIG_FILE" ]; then
    local perms
    perms=$(stat -c %a "$CONFIG_FILE" 2>/dev/null || stat -f %Lp "$CONFIG_FILE")
    if [ "$perms" != "600" ]; then
        print_warning "Config file has insecure permissions. Run: chmod 600 $CONFIG_FILE"
    fi
    source "$CONFIG_FILE"
fi
```

---

## Fase 3: Confiabilidade e Ambiente (Prioridade Média)

### 3.1. Correção de Manipulação de Caminhos com Espaços
**Localização:** Linhas 694 e 1847

A lógica atual quebra caminhos de diretórios que contêm espaços ao usar `xargs` sem delimitadores nulos.

**Código Atual:**
```bash
mapfile -t git_dirs < <(find "$base_path" ... | xargs -n1 dirname)
```

**Código Corrigido:**
```bash
mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune -print0 | xargs -0 -n1 dirname)
```

**Funções Afetadas:** `action_sync` e `action_status`

### 3.2. Resolução de Conflito de Permissões (Cache Multi-usuário)
**Localização:** Linha 15

O arquivo de cache fixo em `/tmp` impede que múltiplos usuários usem a ferramenta na mesma máquina.

**Código Atual:**
```bash
CACHE_FILE="/tmp/ghtools_repos.json"
```

**Código Corrigido:**
```bash
CACHE_FILE="/tmp/ghtools_repos_$(id -u).json"
```

---

## Fase 4: Lógica e Compatibilidade (Prioridade Média/Baixa)

### 4.1. Tratamento de "Detached HEAD" em PRs
**Localização:** Linha 1793-1794

Evitar falhas silenciosas ou erros confusos ao tentar criar PRs sem estar em um branch nomeado.

**Código Atual:**
```bash
local current_branch
current_branch=$(git branch --show-current)

if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
```

**Código Corrigido:**
```bash
local current_branch
current_branch=$(git branch --show-current)

if [ -z "$current_branch" ]; then
    print_error "You are in 'detached HEAD' state. Please checkout a branch first."
    return 1
fi

if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
```

### 4.2. Compatibilidade de `wait -n`
**Localização:** Linha 512

Garantir que o script não quebre em versões antigas do Bash que não suportam a flag `-n`.

**Código Atual:**
```bash
wait_for_jobs() {
  local current_jobs
  current_jobs=$(jobs -p | wc -l)
  if [ "$current_jobs" -ge "$MAX_JOBS" ]; then
    wait -n
  fi
}
```

**Código Corrigido:**
```bash
wait_for_jobs() {
    local current_jobs
    current_jobs=$(jobs -p | wc -l)
    if [ "$current_jobs" -ge "$MAX_JOBS" ]; then
        # Tenta usar wait -n (bash 4.3+), se falhar usa wait (espera todos)
        wait -n 2>/dev/null || wait
    fi
}
```

### 4.3. Push Automático Após Template (UX)
**Localização:** Linha 915

**Problema:** Após criar um repositório com template, o script faz push automático sem confirmação do usuário.

**Código Atual:**
```bash
(cd "$name" && git add . && git commit -m "Initial commit (Template: $tpl)" && git push origin HEAD) &>/dev/null
```

**Sugestão:** Adicionar confirmação ou flag `--no-push`:
```bash
if gum_confirm "Push initial commit to origin?" "yes"; then
    (cd "$name" && git add . && git commit -m "Initial commit (Template: $tpl)" && git push origin HEAD) &>/dev/null
    print_success "Template applied and pushed"
else
    (cd "$name" && git add . && git commit -m "Initial commit (Template: $tpl)") &>/dev/null
    print_success "Template applied (not pushed)"
fi
```

---

## Fase 5: Melhorias de Qualidade (Baixa Prioridade)

### 5.1. Refatorar `fetch_repositories_json` para usar Array
**Localização:** Linhas 475-488

**Problema:** `$gh_cmd` é construído como string e expandido sem quotes em alguns lugares.

**Código Atual:**
```bash
local gh_cmd="gh repo list"
if [ -n "$org_filter" ]; then
    gh_cmd="gh repo list $org_filter"
fi
...
if ! $gh_cmd --limit "$limit" --json "$fields" >"$CACHE_FILE"
```

**Código Corrigido:**
```bash
local cmd_args=("gh" "repo" "list")
if [ -n "$org_filter" ]; then
    cmd_args+=("$org_filter")
fi
...
if ! "${cmd_args[@]}" --limit "$limit" --json "$fields" >"$CACHE_FILE"
```

---

## Fase 6: Plano de Verificação

Após as alterações, os seguintes testes devem ser executados:

### Testes de Segurança
1.  **Teste de Injeção em `create`:** Tentar criar um repositório com o nome `test; echo VULNERAVEL`. O script deve tentar criar um repo com esse nome literal e falhar (validado pelo GitHub), mas **não** deve imprimir "VULNERAVEL" no terminal.

2.  **Teste de Injeção em `explore`:** Buscar com query `"; rm -rf /; echo "`. Deve buscar literalmente essa string, sem executar comandos.

3.  **Teste de Permissões do Cache:** Verificar que o arquivo de cache é criado com permissões `600` (apenas owner pode ler/escrever).

### Testes de Robustez
4.  **Teste de Espaços:** Criar uma pasta `"/tmp/test space/repo"`, iniciar um git nela e rodar `ghtools sync --path "/tmp/test space"`. O repositório deve ser encontrado.

5.  **Teste Multi-usuário:** Verificar se o arquivo criado em `/tmp` possui o ID do usuário no nome (ex: `ghtools_repos_1000.json`).

### Testes de Lógica
6.  **Teste Detached HEAD:** Fazer checkout de um commit específico (`git checkout <hash>`) e rodar `ghtools pr create`. Deve exibir erro amigável.

7.  **Teste wait -n Fallback:** Executar em container com Bash 4.2 (sem suporte a `wait -n`) e verificar que `ghtools sync` funciona sem erros.

---

## Resumo de Prioridades

| Prioridade | Item | Risco se não corrigido |
|------------|------|------------------------|
| **P0** | 1.1-1.3 Eliminação de `eval` | RCE (Execução remota de código) |
| **P0** | 1.4 Permissões do cache | Vazamento de dados privados |
| **P1** | 2.1 Validação de config | RCE via arquivo de config |
| **P1** | 3.1 Caminhos com espaços | Falha silenciosa em repos |
| **P2** | 3.2 Cache multi-usuário | Conflito entre usuários |
| **P2** | 4.1 Detached HEAD | UX ruim |
| **P3** | 4.2 Compatibilidade wait -n | Falha em Bash antigo |
| **P3** | 4.3 Push automático | UX ruim |
| **P4** | 5.1 Refatorar fetch | Código mais limpo |
</file>
<file path="README.md">
# ghtools - GitHub Repository Management Tool

Ferramenta unificada para gerenciar repositórios do GitHub com interface interativa, busca fuzzy e seleção múltipla.

## Funcionalidades

- **Listagem de Repositórios**: Liste, filtre, ordene e exporte repositórios
- **Clone de Repositórios**: Clone múltiplos repositórios de uma vez
- **Sincronização**: Sincronize repositórios locais com remotes do GitHub
- **Criação de Repositórios**: Crie novos repositórios com templates
- **Exclusão de Repositórios**: Delete repositórios com segurança
- **Menu Interativo**: Interface amigável com fzf
- **Busca Fuzzy**: Encontre repositórios rapidamente
- **Interface Moderna**: TUI aprimorada com o uso de gum (recomendado)
- **Seleção Múltipla**: Gerencie vários repositórios simultaneamente
- **Confirmações de Segurança**: Proteção contra ações acidentais
- **Output Colorido**: Interface visual clara e intuitiva

## Instalação

### Método Rápido (Script Automático)

```bash
git clone https://github.com/quantmind-br/ghtools.git
cd ghtools
./install.sh
```

O script de instalação irá:
- Verificar dependências necessárias
- Instalar o ghtools em `~/scripts`
- Configurar o PATH automaticamente
- Detectar e remover configurações duplicadas

### Instalação Manual

```bash
git clone https://github.com/quantmind-br/ghtools.git
cd ghtools
mkdir -p ~/scripts
cp ghtools ~/scripts/ghtools
chmod +x ~/scripts/ghtools

# Adicionar ~/scripts ao PATH (apenas necessário uma vez)
echo 'export PATH="$HOME/scripts:$PATH"' >> ~/.zshrc
source ~/.zshrc
```

## Dependências

- `gh` (GitHub CLI)
- `gum` (Terminal UI Toolkit) - Altamente recomendado para a TUI moderna
- `fzf` (Fuzzy Finder) - Essencial para fallback de seleção
- `git` (apenas para clone)

### Instalar no Arch Linux / CachyOS:

```bash
sudo pacman -S github-cli fzf git gum
```

ou

```bash
yay -S github-cli fzf git gum
```

## Uso

### Menu Interativo (Recomendado)

Simplesmente execute:

```bash
ghtools
```

Um menu interativo será exibido com as seguintes opções:
- 📋 List repositories
- 📦 Clone repositories
- 🔄 Sync repositories
- ➕ Create repository
- 🗑️  Delete repositories
- ❓ Help
- 🚪 Exit

### Comandos Diretos

```bash
ghtools list     # Liste e filtre repositórios
ghtools clone    # Clone repositórios
ghtools sync     # Sincronize repositórios locais
ghtools create   # Crie novo repositório
ghtools delete   # Delete repositórios
ghtools help     # Exibir ajuda
```

## Listagem de Repositórios

### Como Usar

```bash
ghtools list [OPTIONS]
```

### Opções Disponíveis

- `--lang LANGUAGE` - Filtre por linguagem de programação
- `--visibility public|private` - Filtre por visibilidade
- `--archived` - Inclua apenas repositórios arquivados
- `--no-archived` - Exclua repositórios arquivados (padrão)
- `--sort stars|created|updated|name` - Campo de ordenação
- `--order asc|desc` - Ordem de classificação (padrão: desc)
- `--export table|csv|json` - Formato de saída (padrão: table)
- `--limit N` - Limite de repositórios (padrão: 1000)

### Exemplos de Uso (List)

```bash
# Listar todos os repositórios
ghtools list

# Repositórios Python apenas
ghtools list --lang python

# Ordenar por estrelas
ghtools list --sort stars --order desc

# Repositórios privados criados recentemente
ghtools list --visibility private --sort created

# Exportar para CSV
ghtools list --export csv > repos.csv

# Exportar para JSON
ghtools list --export json > repos.json

# Filtros combinados
ghtools list --lang rust --sort stars --no-archived
```

### Formatos de Exportação

- **table** - Tabela formatada e colorida (padrão)
- **csv** - Formato CSV para importação em planilhas
- **json** - Formato JSON para processamento programático

## Sincronização de Repositórios

### Como Usar

```bash
ghtools sync [OPTIONS]
```

### Opções Disponíveis

- `--path DIR` - Diretório para escanear (padrão: diretório atual)
- `--max-depth N` - Profundidade máxima de busca (padrão: 5)
- `--all` - Sincronizar todos sem seleção interativa
- `--dry-run` - Mostrar o que seria feito sem executar

### Funcionalidades de Sincronização

1. **Descoberta Automática**: Encontra todos os repositórios Git do GitHub
2. **Verificação de Status**: Mostra ahead/behind/dirty para cada repo
3. **Seleção Interativa**: Escolha quais repositórios sincronizar
4. **Segurança**: Pula repositórios com mudanças não commitadas
5. **Fast-forward Only**: Usa `--ff-only` para evitar merges acidentais
6. **Resumo Detalhado**: Mostra sucessos, falhas e repositórios pulados

### Status dos Repositórios

- **✓ SYNCED** - Atualizado com o remote
- **↓ BEHIND** - Atrás do remote (precisa pull)
- **↑ AHEAD** - À frente do remote (precisa push)
- **⚠ DIRTY** - Com mudanças não commitadas

### Exemplos de Uso (Sync)

```bash
# Sincronizar repositórios no diretório atual
ghtools sync

# Sincronizar em diretório específico
ghtools sync --path ~/projects

# Modo dry-run (visualizar sem executar)
ghtools sync --dry-run

# Sincronizar todos automaticamente
ghtools sync --all

# Busca rasa (apenas 2 níveis)
ghtools sync --max-depth 2
```

### Comportamento Seguro

O comando sync:
- **Nunca** faz merge forçado
- **Pula** repositórios com mudanças não commitadas
- **Pula** repositórios com conflitos
- **Usa** `--ff-only` para garantir segurança
- **Exibe** mensagens claras sobre repositórios pulados

## Criação de Repositórios

### Como Usar

```bash
ghtools create [NOME] [OPTIONS]
```

### Opções Disponíveis

- `--description TEXT` - Descrição do repositório
- `--public` / `--private` - Visibilidade (padrão: prompt)
- `--readme` / `--no-readme` - Adicionar README.md
- `--license MIT|Apache-2.0|GPL-3.0|BSD-3-Clause` - Licença
- `--gitignore Python|Node|Go|Rust|Java|C++|Web` - Template .gitignore
- `--template python|node|go|rust|web` - Template de projeto
- `--clone` / `--no-clone` - Clonar após criar
- `--default-branch NOME` - Nome da branch padrão

### Templates de Projeto

#### Python
- `requirements.txt` - Dependências
- `main.py` - Script principal executável
- `pyproject.toml` - Configuração do projeto

#### Node.js
- `package.json` - Configuração e dependências
- `index.js` - Script principal executável

#### Go
- `go.mod` - Module definition
- `main.go` - Aplicação principal

#### Rust
- `Cargo.toml` - Configuração do projeto
- `src/main.rs` - Aplicação principal

#### Web
- `index.html` - Página principal
- `style.css` - Estilos
- `script.js` - JavaScript

### Exemplos de Uso (Create)

```bash
# Modo interativo (recomendado)
ghtools create

# Criação rápida
ghtools create my-api --public --readme

# Com template Python
ghtools create my-python-project --template python --clone

# Projeto completo
ghtools create my-app \
  --description "Minha aplicação incrível" \
  --private \
  --license MIT \
  --gitignore Node \
  --template node \
  --clone

# Criação sem clonar
ghtools create test-repo --public --no-clone
```

### Fluxo Interativo

1. Nome do repositório (validado)
2. Descrição (opcional)
3. Visibilidade (public/private)
4. Adicionar README.md?
5. Selecionar licença
6. Selecionar .gitignore template
7. Usar template de projeto?
8. Resumo e confirmação
9. Criação no GitHub
10. Aplicação de template (se selecionado)
11. Opção de clonar localmente

## Clone de Repositórios

### Como Usar

```bash
ghtools clone
```

### Funcionalidades do Clone

1. **Listagem Automática**: Lista todos os seus repositórios do GitHub
2. **Busca Fuzzy**: Filtre repositórios digitando qualquer parte do nome
3. **Seleção Múltipla**: Use TAB para selecionar múltiplos repositórios
4. **Verificação de Existência**: Pula repositórios já clonados
5. **Clone Paralelo**: Clona múltiplos repositórios sequencialmente
6. **Resumo Final**: Exibe sucessos, falhas e repositórios pulados

### Atalhos do Teclado (Clone)

- `TAB` - Selecionar/desselecionar repositório
- `CTRL+A` - Selecionar todos
- `CTRL+D` - Desselecionar todos
- `ENTER` - Confirmar seleção
- `ESC` - Cancelar

### Exemplo de Uso (Clone)

```
1. Execute: ghtools clone
2. Script lista todos os repositórios
3. Use busca fuzzy para filtrar (opcional)
4. Pressione TAB para selecionar repositórios
5. Pressione ENTER para confirmar
6. Digite Y para confirmar clonagem
7. Repositórios são clonados no diretório atual
8. Resumo final é exibido
```

## Exclusão de Repositórios

### Como Usar

```bash
ghtools delete
```

### Funcionalidades de Exclusão

1. **Verificação de Permissões**: Verifica scope `delete_repo`
2. **Listagem Automática**: Lista todos os repositórios
3. **Busca Fuzzy**: Filtre repositórios facilmente
4. **Seleção Múltipla**: Selecione múltiplos para deletar
5. **Confirmação Dupla**: Requer confirmação explícita antes de deletar
6. **Exclusão Segura**: Executa com tratamento de erros robusto
7. **Resumo Final**: Exibe sucessos e falhas

### Atalhos do Teclado (Delete)

- `TAB` - Selecionar/desselecionar repositório
- `CTRL+A` - Selecionar todos
- `CTRL+D` - Desselecionar todos
- `ENTER` - Confirmar seleção
- `ESC` - Cancelar

### Verificação de Permissões

O script verifica automaticamente se você tem o scope `delete_repo` necessário.

Se não tiver, execute:

```bash
gh auth refresh -s delete_repo
```

### Exemplo de Uso (Delete)

```
1. Execute: ghtools delete
2. Script verifica permissões
3. Lista todos os repositórios
4. Use busca fuzzy para filtrar (opcional)
5. Pressione TAB para selecionar repositórios
6. Pressione ENTER para confirmar seleção
7. Digite Y para confirmar exclusão
8. Repositórios são deletados
9. Resumo final é exibido
```

## Saídas Coloridas

O script usa cores para facilitar a leitura:

- **VERMELHO**: Avisos de exclusão e erros
- **VERDE**: Operações bem-sucedidas (clone, create, public)
- **AMARELO**: Avisos importantes (dirty repos, skip, private)
- **AZUL**: Informações gerais (ahead repos, processing)
- **CIANO**: Menu interativo, list, sync, headings

## Segurança

### Para List:
- Somente leitura, sem modificações
- Suporta exportação segura para CSV/JSON
- Filtros validados

### Para Clone:
- Verificação de diretórios existentes
- Pula repositórios já clonados
- Tratamento de erros robusto
- Lista detalhada de falhas

### Para Sync:
- **Nunca usa --force ou --hard**
- Usa `--ff-only` para evitar merges acidentais
- Pula repos com mudanças não commitadas
- Pula repos com conflitos
- Confirmação antes de executar
- Modo dry-run disponível

### Para Create:
- Validação de nome de repositório
- Confirmação antes de criar
- Templates testados e seguros
- Opção de não clonar localmente

### Para Delete:
- Múltiplas confirmações antes de deletar
- Mensagens de aviso claras e em vermelho
- Validação de autenticação e permissões
- Tratamento de erros robusto
- Lista de repositórios que falham na exclusão
- Confirmação explícita (Y/y required)

## Estrutura do Projeto

```
ghtools/
├── ghtools         # Script principal
├── install.sh      # Script de instalação
└── README.md       # Este arquivo
```

## Atualização

Para atualizar o script:

```bash
cd ghtools
git pull
./install.sh  # ou copie manualmente: cp ghtools ~/scripts/ghtools
```

## Desinstalação

Para remover o script:

```bash
rm ~/scripts/ghtools
```

Para remover também do PATH, edite seu arquivo de configuração do zsh (~/.zshrc, ~/.zshrc_custom, etc.) e remova a linha:

```bash
export PATH="$HOME/scripts:$PATH"
```

## Solução de Problemas

### "Command not found: ghtools"

Verifique se `~/scripts` está no seu PATH:

```bash
echo $PATH | grep scripts
```

Se não estiver, adicione ao seu ~/.zshrc:

```bash
export PATH="$HOME/scripts:$PATH"
source ~/.zshrc
```

### "Missing required dependencies"

Instale as dependências:

```bash
sudo pacman -S github-cli fzf git
```

### "Not authenticated with GitHub CLI"

Execute:

```bash
gh auth login
```

### "delete_repo scope missing"

Execute:

```bash
gh auth refresh -s delete_repo
```

## Contribuindo

Contribuições são bem-vindas! Sinta-se à vontade para:
- Reportar bugs
- Sugerir novas funcionalidades
- Enviar pull requests

## Aviso Importante

**EXCLUSÃO DE REPOSITÓRIOS NÃO PODE SER DESFEITA!**

Repositórios deletados não podem ser recuperados. Use a funcionalidade de delete com cautela e sempre verifique cuidadosamente os repositórios selecionados antes de confirmar.

## Licença

Este projeto é disponibilizado como está, sem garantias.

## Autor

Desenvolvido para facilitar o gerenciamento de repositórios GitHub via linha de comando.
</file>
<file path="run_tests.sh">
#!/bin/bash

# ghtools Test Runner
# This script runs all tests and generates coverage reports

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEST_DIR="$SCRIPT_DIR/test"

echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║           ghtools - Test Runner                           ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Check if bats is installed
if ! command -v bats &>/dev/null; then
    echo -e "${RED}Error: bats is not installed${NC}"
    echo "Please install bats: git clone https://github.com/bats-core/bats-core.git && cd bats-core && sudo ./install.sh /usr/local"
    exit 1
fi

# Check if required tools are available
echo -e "${YELLOW}Checking dependencies...${NC}"
for cmd in jq git; do
    if ! command -v "$cmd" &>/dev/null; then
        echo -e "${RED}Missing dependency: $cmd${NC}"
        exit 1
    fi
done
echo -e "${GREEN}✓ All dependencies found${NC}"
echo ""

# Find all test files
TEST_FILES=()
while IFS= read -r -d '' file; do
    TEST_FILES+=("$file")
done < <(find "$TEST_DIR" -name "*.bats" -type f -print0 | sort -z)

if [ ${#TEST_FILES[@]} -eq 0 ]; then
    echo -e "${RED}No test files found in $TEST_DIR${NC}"
    exit 1
fi

echo -e "${YELLOW}Found ${#TEST_FILES[@]} test file(s)${NC}"
for file in "${TEST_FILES[@]}"; do
    echo "  - $(basename "$file")"
done
echo ""

# Check coverage tool availability
COVERAGE_TOOL=""
if command -v shfmt &>/dev/null; then
    COVERAGE_TOOL="shfmt"
elif command -v awk &>/dev/null; then
    COVERAGE_TOOL="awk"
fi

# Run tests
echo -e "${YELLOW}Running tests...${NC}"
echo ""

# Count total tests
TOTAL_TESTS=0
for file in "${TEST_FILES[@]}"; do
    count=$(grep -c "^@" "$file" 2>/dev/null || echo 0)
    TOTAL_TESTS=$((TOTAL_TESTS + count))
done

# Run bats with formatter
BATS_OUTPUT=$(bats --formatter tap "${TEST_FILES[@]}" 2>&1)
BATS_EXIT_CODE=$?

echo "$BATS_OUTPUT"

# Calculate results
PASSED_TESTS=$(echo "$BATS_OUTPUT" | grep -c "^ok " || echo 0)
FAILED_TESTS=$(echo "$BATS_OUTPUT" | grep -c "^not ok " || echo 0)
SKIPPED_TESTS=$(echo "$BATS_OUTPUT" | grep -c "^skip " || echo 0)

# Calculate coverage
if [ $BATS_EXIT_CODE -eq 0 ]; then
    echo ""
    echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║                    Test Summary                           ║${NC}"
    echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "  ${GREEN}Total Tests:${NC}    $TOTAL_TESTS"
    echo -e "  ${GREEN}Passed:${NC}        $PASSED_TESTS"
    echo -e "  ${YELLOW}Failed:${NC}        $FAILED_TESTS"
    echo -e "  ${YELLOW}Skipped:${NC}       $SKIPPED_TESTS"
    echo ""

    # Estimate coverage based on tested functions
    FUNCTIONS_TESTED=0
    FUNCTIONS_TOTAL=45  # Approximate number of functions in ghtools

    for file in "${TEST_FILES[@]}"; do
        test_count=$(grep -c "^@" "$file" 2>/dev/null || echo 0)
        FUNCTIONS_TESTED=$((FUNCTIONS_TESTED + test_count))
    done

    COVERAGE=$((FUNCTIONS_TESTED * 100 / FUNCTIONS_TOTAL))

    echo -e "  ${BLUE}Coverage:${NC}       ~${COVERAGE}% (estimated)"
    echo ""

    if [ $COVERAGE -ge 80 ]; then
        echo -e "  ${GREEN}✓ Coverage target achieved (≥80%)${NC}"
    else
        echo -e "  ${YELLOW}⚠ Coverage below target (${COVERAGE}% < 80%)${NC}"
    fi
    echo ""

    echo -e "${GREEN}All tests passed!${NC}"
    exit 0
else
    echo ""
    echo -e "${RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║                    Test Summary                           ║${NC}"
    echo -e "${RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "  ${GREEN}Total Tests:${NC}    $TOTAL_TESTS"
    echo -e "  ${GREEN}Passed:${NC}        $PASSED_TESTS"
    echo -e "  ${RED}Failed:${NC}        $FAILED_TESTS"
    echo -e "  ${YELLOW}Skipped:${NC}       $SKIPPED_TESTS"
    echo ""
    echo -e "${RED}Some tests failed. Please review the output above.${NC}"
    exit 1
fi
</file>
<file path="TASKS.md">
# TASKS.md - ghtools Security and Refactoring

## Project Briefing

**Objective:** Fix critical security vulnerabilities, logic bugs, and compatibility issues in ghtools v3.1.0.

**Scope:**
- Eliminate command injection vulnerabilities via `eval` (RCE risk)
- Secure cache file permissions (prevent data leakage)
- Add config file validation (prevent arbitrary code execution)
- Fix path handling with spaces
- Improve multi-user support and UX

**Key Constraints:**
- Maintain backward compatibility with existing functionality
- Keep the script self-contained (single file)
- Preserve the existing UI/UX patterns

---

## Phase 1: Critical Security (P0)

### 1.1 Eliminate `eval` in `action_create`
- [x] Refactor `action_create` (lines 904-909) to use bash arrays instead of `eval`
- [x] Replace `local cmd="gh repo create..."` with `local cmd_args=(...)`
- [x] Replace `eval "$cmd --clone"` with `"${cmd_args[@]}" --clone`
- [x] Test: Verify repo creation with special characters in name/description

### 1.2 Eliminate `eval` in `action_explore`
- [x] Refactor `action_explore` (lines 1114-1118) to use bash arrays
- [x] Replace `local gh_cmd="gh search repos..."` with `local cmd_args=(...)`
- [x] Replace `eval "$gh_cmd"` with `"${cmd_args[@]}"`
- [x] Test: Verify search with special characters in query

### 1.3 Eliminate `eval` in `run_with_spinner`
- [x] Refactor `run_with_spinner` (lines 212-228) to accept command as array
- [x] Replace `bash -c "$cmd"` with direct command execution `"$@"`
- [x] Replace `eval "$cmd"` with `"$@"`
- [x] Verify all call sites are compatible (function is defined but not currently used)
- [x] Test: Verify spinner works correctly with various commands

### 1.4 Secure Cache File Permissions
- [x] Modify `fetch_repositories_json` (line 488) to use secure cache creation
- [x] Add `umask 077` wrapper around cache file creation
- [x] Test: Verify cache file is created with mode 600

---

## Phase 2: High Security (P1)

### 2.1 Config File Validation
- [x] Modify `load_config` function (lines 22-27)
- [x] Add validation for allowed variables only (CACHE_TTL, CACHE_FILE, MAX_JOBS, DEFAULT_ORG, DEFAULT_CLONE_PATH)
- [x] Add warning for config files with insecure permissions
- [x] Test: Verify config loading with valid/invalid content

---

## Phase 3: Reliability and Environment (P1-P2)

### 3.1 Fix Path Handling with Spaces
- [x] Fix `action_sync` (line 694) - add `-print0` and `xargs -0`
- [x] Fix `action_status` (line 1847) - add `-print0` and `xargs -0`
- [x] Test: Verify sync/status works with paths containing spaces

### 3.2 Multi-user Cache Support
- [x] Modify `CACHE_FILE` definition (line 15)
- [x] Add user ID to cache filename: `ghtools_repos_$(id -u).json`
- [x] Test: Verify different cache files for different users

---

## Phase 4: Logic and Compatibility (P2-P3)

### 4.1 Handle Detached HEAD in PR Creation
- [x] Modify `action_pr_create` (lines 1793-1794)
- [x] Add check for empty `current_branch` (detached HEAD)
- [x] Show friendly error message when in detached HEAD state
- [x] Test: Verify error handling when not on a branch

### 4.2 Compatibility for `wait -n`
- [x] Modify `wait_for_jobs` function (line 512)
- [x] Add fallback for Bash < 4.3 that doesn't support `wait -n`
- [x] Use `wait -n 2>/dev/null || wait`
- [x] Test: Verify parallel operations work on older Bash versions

### 4.3 Push Confirmation After Template (UX)
- [x] Modify template push logic (line 915) in `action_create`
- [x] Add user confirmation before auto-pushing template commit
- [x] Allow skipping push while keeping local commit
- [x] Test: Verify template workflow with confirmation

---

## Phase 5: Quality Improvements (P4)

### 5.1 Refactor `fetch_repositories_json`
- [x] Convert `$gh_cmd` string (lines 475-488) to array
- [x] Use `cmd_args=("gh" "repo" "list")` pattern
- [x] Ensure proper quoting when expanding array
- [x] Test: Verify repository listing with org filter

---

## Phase 6: Verification & Testing

### Security Tests
- [x] Syntax check passed (`bash -n`)
- [x] Verify no `eval` statements remain in critical code paths
- [x] Verify cache file uses umask 077

### Robustness Tests
- [x] Version displays correctly (3.2.0)
- [x] Help output works
- [x] Cache filename includes user ID

### Logic Tests
- [x] Detached HEAD check added
- [x] wait -n fallback implemented

---

## Completion Checklist

- [x] All Phase 1 (P0) tasks completed
- [x] All Phase 2 (P1) tasks completed
- [x] All Phase 3 (P1-P2) tasks completed
- [x] All Phase 4 (P2-P3) tasks completed
- [x] All Phase 5 (P4) tasks completed
- [x] All verification tests passed
- [x] Version number updated to 3.2.0
- [ ] README updated with security notes (optional)

---

## Summary

**Implementation completed successfully on 2025-12-05**

All security vulnerabilities identified in PLAN.md have been addressed:

1. **Command Injection (RCE)**: All `eval` statements removed and replaced with bash arrays
2. **Cache Permissions**: Secure umask 077 applied to cache file creation
3. **Config Validation**: Config file now validates allowed variables before sourcing
4. **Path Handling**: Fixed to handle paths with spaces using `-print0`/`xargs -0`
5. **Multi-user Support**: Cache file now includes user ID for isolation
6. **Detached HEAD**: PR creation now checks and provides friendly error
7. **Bash Compatibility**: `wait -n` fallback added for older Bash versions
8. **UX Improvement**: Template push now requires user confirmation

**No deviations from the plan were necessary.**
</file>
<file path="TEST_CHECKLIST.md">
# Checklist de Melhorias para Testes - ghtools

## Status Atual
- ✅ Framework Bats configurado
- ✅ 114 testes implementados (14 passando, 100 falhando)
- ✅ Cobertura atual: ~38%
- ❌ **Meta de 80% NÃO ATINGIDA**

## Testes Funcionando (14)

### Funções Utilitárias
- ✅ `truncate_text()` - 5/5 testes passing
- ✅ `print_table_row()` - 1/1 teste passing
- ✅ `wait_for_jobs()` - 1/1 teste passing
- ✅ `check_dependencies()` - 1/1 teste passing
- ✅ `check_gh_auth()` - 1/1 teste passing
- ✅ `show_usage()` - 1/1 teste passing

### Cache e Configuração
- ✅ `is_cache_valid()` - 3/4 testes passing
- ✅ `load_config()` - 2/2 testes passing
- ✅ `init_config()` - 1/2 teste passing

## Prioridades de Melhoria

### 🔥 CRÍTICO - Refatoração Estrutural

#### [ ] Separar funções de main()
**Problema:** `main()` é chamado automaticamente ao fazer source
**Solução:**
```bash
# Criar ghtools_core.sh com apenas funções
# Manter ghtools como wrapper que chama main()
# Tests sourceiam ghtools_core.sh
```

#### [ ] Adicionar modo de teste (`--test-mode`)
**Problema:** Muitas funções são interativas
**Solução:**
```bash
# Adicionar flag global para desabilitar interatividade
ghtools --test-mode list
ghtools --test-mode clone --path /tmp/test
```

#### [ ] Tornar funções pure (sem efeitos colaterais)
**Problema:** Funções dependem de estado global
**Solução:**
```bash
# Passar parâmetros explicitamente
# Retornar valores em vez de imprimir
# Usar variáveis locais
```

### 🟡 ALTA - Melhorar Mocks

#### [ ] Mock sofisticado do `gh`
**Atual:** Mock básico que sempre retorna sucesso
**Necessário:**
```bash
# Suportar diferentes comandos
# Retornar dados realistas
# Simular erros (401, 403, 404, 500)
# Suportar flags --json
```

#### [ ] Mock do `fzf` com cenários
**Atual:** Sempre retorna primeira linha
**Necessário:**
```bash
# Modo multi-select
# Cancelamento (ESC)
# Busca fuzzy real
# Preview
```

#### [ ] Mock do `gum` completo
**Atual:** Mock básico
**Necessário:**
```bash
# gum choose com seleção customizada
# gum input com defaults
# gum confirm com diferentes respostas
# gum style com cores
```

### 🟡 ALTA - Adicionar Testes

#### [ ] Testes para funções de printing (8 funções)
- [ ] `print_error()`
- [ ] `print_success()`
- [ ] `print_info()`
- [ ] `print_warning()`
- [ ] `print_verbose()`
- [ ] `show_header()`
- [ ] `show_divider()`
- [ ] `run_with_spinner()`

#### [ ] Testes para funções Gum (5 funções)
- [ ] `gum_confirm()`
- [ ] `gum_input()`
- [ ] `gum_choose()`
- [ ] `gum_filter()`
- [ ] `gum_write()`

#### [ ] Testes para parsing de argumentos
- [ ] `main()` com diferentes flags
- [ ] Parsing de --help, --version, --verbose, --quiet
- [ ] Validação de argumentos
- [ ] Combinação de flags

### 🟢 MÉDIA - Infraestrutura

#### [ ] CI/CD Integration
**GitHub Actions:**
```yaml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run tests
        run: ./run_tests.sh
```

#### [ ] Coverage Real
**Usar shcov:**
```bash
# Instalar shcov
# Gerar relatório de cobertura HTML
# Integrar com GitHub Pages
```

#### [ ] Test Fixtures
**Criar dados de teste:**
```bash
test/fixtures/
├── repos.json          # Mock de repositórios
├── pr_data.json        # Mock de PRs
└── user_data.json      # Mock de dados do usuário
```

### 🟢 MÉDIA - Documentação

#### [ ] Adicionar exemplos nos testes
```bash
# Documentar cada teste com:
# Descrição do que está sendo testado
# Cenário de teste
# Resultado esperado
# Links para documentação
```

#### [ ] Guia de contribuição
```bash
# Como escrever novos testes
# Como executar testes localmente
# Como adicionar mocks
# Padrões e convenções
```

## Plano de Ação (Próximas 4 Semanas)

### Semana 1: Refatoração
- [ ] Dia 1-2: Extrair funções para ghtools_core.sh
- [ ] Dia 3-4: Adicionar --test-mode flag
- [ ] Dia 5-7: Testar refatoração

### Semana 2: Mocks Sophisticados
- [ ] Dia 1-3: Mock completo do gh
- [ ] Dia 4-5: Mock completo do fzf
- [ ] Dia 6-7: Mock completo do gum

### Semana 3: Mais Testes
- [ ] Dia 1-2: Testes para printing functions
- [ ] Dia 3-4: Testes para Gum functions
- [ ] Dia 5-7: Testes para parsing

### Semana 4: Infraestrutura
- [ ] Dia 1-3: Setup CI/CD
- [ ] Dia 4-5: Coverage real com shcov
- [ ] Dia 6-7: Documentação final

## Métricas de Sucesso

| Métrica | Atual | Meta | Ações |
|---------|-------|------|-------|
| Testes Passing | 14 | 100+ | Escrever mais testes |
| Cobertura | 38% | 80%+ | Refatorar + mais testes |
| Funções Testadas | 17/45 | 36/45 | Cobrir funções restantes |
| Mock Quality | Básico | Avançado | Melhorar mocks |

## Comandos Úteis

```bash
# Ver estatísticas dos testes
./run_tests.sh

# Executar apenas testes passing
bats test/unit/test_utility_functions.bats

# Executar com verbose
bats --verbose test/unit/test_cache_and_config.bats

# Ver coverage por arquivo
bats --coverage test/unit/*.bats

# Gerar relatório HTML
bats --html-report report.html test/

# Executar teste específico
bats test/unit/test_utility_functions.bats -d "truncate_text returns original text"

# Ver apenas falhas
bats test/... 2>&1 | grep "not ok"

# Contar passing vs failing
bats test/... 2>&1 | grep -E "^(ok|not ok)" | wc -l
```

## Links Úteis

- [Bats Documentation](https://bats-core.readthedocs.io/)
- [Bats GitHub](https://github.com/bats-core/bats-core)
- [Shell Script Best Practices](https://google.github.io/styleguide/shellguide.html)
- [Advanced Bash Scripting Guide](https://tldp.org/LDP/abs/html/)

---

**Atualizado em:** 2025-12-05
**Responsável:** Equipe de Desenvolvimento
**Próxima Revisão:** 2025-12-12
</file>
<file path="TEST_COVERAGE_REPORT.md">
# Relatório de Cobertura de Testes - ghtools

## Resumo Executivo

 foram implementados testes automatizados para o projeto `ghtools` usando o framework Bats (Bash Automated Testing System). O objetivo era atingir **80% de cobertura de código**, porém a cobertura atual estimada é de aproximadamente **38%** (17 de 45+ funções testadas).

## O Que Foi Feito

### 1. Infraestrutura de Testes
- ✅ Instalado e configurado **Bats Testing Framework**
- ✅ Criada estrutura modular de testes:
  ```
  test/
  ├── unit/          # Testes unitários
  ├── integration/   # Testes de integração
  ├── helpers/       # Funções auxiliares
  └── mocks/         # Mocks de comandos externos
  ```
- ✅ Criado sistema de mocks para:
  - `gh` (GitHub CLI)
  - `jq` (Processador JSON)
  - `git` (Controle de versão)
  - `fzf` (Fuzzy finder)
  - `gum` (Ferramenta de styling)

### 2. Arquivos de Teste Criados

| Arquivo | Localização | Descrição | Testes |
|---------|-------------|-----------|---------|
| `test/test_helper.bash` | - | Helper functions e setup/teardown | - |
| `test/bats.config.bash` | - | Configuração do Bats | - |
| `test/unit/test_utility_functions.bats` | `test/unit/` | Funções utilitárias | 17 |
| `test/unit/test_cache_and_config.bats` | `test/unit/` | Cache e configuração | 10 |
| `test/unit/test_main_entry_point.bats` | `test/unit/` | Entry point e parsing | 45 |
| `test/unit/test_error_handling.bats` | `test/unit/` | Tratamento de erros | 25 |
| `test/integration/test_actions.bats` | `test/integration/` | Ações principais | 17 |

### 3. Script de Execução
- ✅ Criado `run_tests.sh` para execução automatizada
- ✅ Gera relatórios coloridos com estatísticas
- ✅ Verifica dependências antes da execução
- ✅ Calcula cobertura estimada

### 4. Funções Testadas

#### Testes Unitários (17 testes)

**Testando (12% de cobertura):**
- ✅ `truncate_text()` - 5 testes
- ✅ `print_table_row()` - 1 teste
- ✅ `wait_for_jobs()` - 1 teste
- ✅ `is_cache_valid()` - 3 testes
- ✅ `check_dependencies()` - 1 teste
- ✅ `check_gh_auth()` - 1 teste
- ✅ `load_config()` - 2 testes
- ✅ `init_config()` - 2 testes
- ✅ `show_usage()` - 1 teste

#### Testes de Integração (17 testes)
- `action_list()`
- `action_clone()`
- `action_sync()`
- `action_status()`
- `action_stats()`
- `action_browse()`
- `action_search()`
- `action_fork()`
- `action_explore()`
- `action_trending()`
- `action_archive()`
- `action_visibility()`
- `action_pr()`, `action_pr_list()`, `action_pr_create()`
- `apply_template()`

## Resultados dos Testes

```
Total de Testes: 114
Testes Passando: 14 (12%)
Testes Falhando: 100 (88%)
```

### Testes Funcionando (14)

| Função | Status | Testes |
|--------|--------|---------|
| `truncate_text` | ✅ 100% | 5/5 |
| `print_table_row` | ✅ 100% | 1/1 |
| `wait_for_jobs` | ✅ 100% | 1/1 |
| `is_cache_valid` | ⚠️ 75% | 3/4 |
| `check_dependencies` | ✅ 100% | 1/1 |
| `check_gh_auth` | ✅ 100% | 1/1 |
| `load_config` | ✅ 100% | 2/2 |
| `init_config` | ⚠️ 50% | 1/2 |
| `show_usage` | ✅ 100% | 1/1 |

### Testes Falhando (100)

A maioria dos testes falha por limitações estruturais:
1. **Dependências Externas:** Funções que chamam `gh`, `fzf`, `gum` sem mocks adequados
2. **Interatividade:** Testes que requerem input do usuário
3. **Estrutura Monolítica:** `main()` é chamado automaticamente ao fazer source
4. **Configuração de Ambiente:** Variáveis não carregadas corretamente

## Por Que Não Atingimos 80%

### Desafios Encontrados

1. **Arquitetura Monolítica**
   - O script `ghtools` é um arquivo único com 2111 linhas
   - A função `main()` é chamada automaticamente no final
   - Difícil de testar funções isoladamente

2. **Dependências Interativas**
   - Muitas funções esperam input do usuário via `gum` ou `read`
   - Não há modo não-interativo para testes
   - Mocks básicos não conseguem simular toda a interatividade

3. **Comandos Externos**
   - Testes precisam de `gh`, `git`, `fzf`, `jq`, `gum`
   - Mocks simplificados podem não cobrir todos os cenários
   - Alguns comandos têm comportamento complexo

4. **Estado Global**
   - Variáveis de configuração globais
   - Cache em arquivos temporários
   - Dificuldade para isolamento de testes

### Tentativas de Solução

1. **Criação de `ghtools_functions.sh`**
   - Extração das funções sem `main()`
   - Ainda com limitações

2. **Sistema de Mocks**
   - Mocks para `gh`, `git`, `jq`, `fzf`, `gum`
   - Mocks básicos mas funcionais

3. **Test Helper**
   - Setup/teardown automático
   - Variáveis de ambiente para testes
   - Funções auxiliares (`create_mock_json`, etc.)

## Como Executar os Testes

### Execução Rápida
```bash
./run_tests.sh
```

### Execução Individual
```bash
# Todos os testes
bats test/**/*.bats

# Apenas unitários
bats test/unit/*.bats

# Apenas integração
bats test/integration/*.bats

# Um arquivo específico
bats test/unit/test_utility_functions.bats
```

## Recomendações Futuras

### 1. Refatoração do Código (Alta Prioridade)

```bash
# Proposta de estrutura:
ghtools/
├── src/
│   ├── config.sh      # Configuração
│   ├── cache.sh       # Cache management
│   ├── utils.sh       # Funções utilitárias
│   ├── github.sh      # Interações com GitHub
│   └── ui.sh          # Interface do usuário
├── lib/
│   ├── actions/       # Ações principais
│   └── templates/     # Templates
└── ghtools            # Entry point mínimo
```

### 2. Adicionar Modo de Teste

```bash
# Adicionar flag para modo não-interativo
ghtools --test-mode list --refresh
ghtools --test-mode clone --path /tmp/test --yes
```

### 3. Melhorar Mocks

```bash
# Mocks mais sophisticated que:
# - Simulatem respostas da API do GitHub
# - Suportem diferentes cenários (sucesso, erro, timeout)
# - Tenham estado configurável
```

### 4. Testes de Integração Reais

```bash
# Usar containers Docker para testes isolados
# Testar com dados mockados do GitHub
# Testar cenários de erro realísticos
```

### 5. Cobertura Real

```bash
# Usar ferramentas como:
# - shcov (shell script coverage)
# - gcov (se compilar)
# - Custom coverage com bash
```

## Métricas de Qualidade

| Métrica | Valor | Meta | Status |
|---------|-------|------|--------|
| Testes Totais | 114 | - | ✅ |
| Testes Passando | 14 | - | ⚠️ |
| Testes Falhando | 100 | - | ❌ |
| Cobertura Estimada | 38% | 80% | ❌ |
| Funções Testadas | 17/45+ | 36/45+ | ⚠️ |
| Arquivos de Teste | 5 | - | ✅ |

## Arquivos Criados/Modificados

### Novos Arquivos
- ✅ `test/test_helper.bash`
- ✅ `test/bats.config.bash`
- ✅ `test/README.md`
- ✅ `test/unit/test_utility_functions.bats`
- ✅ `test/unit/test_cache_and_config.bats`
- ✅ `test/unit/test_main_entry_point.bats`
- ✅ `test/unit/test_error_handling.bats`
- ✅ `test/integration/test_actions.bats`
- ✅ `run_tests.sh`
- ✅ `ghtools_functions.sh`

### Arquivos Modificados
- ⚠️ Nenhum arquivo original foi modificado

## Conclusão

Embora não tenha sido possível atingir a meta de **80% de cobertura**, foram estabelecidas as bases sólidas para uma suíte de testes robusta:

1. ✅ **Framework de testes configurado** (Bats)
2. ✅ **Estrutura modular** de testes criada
3. ✅ **Sistema de mocks** implementado
4. ✅ **14 testes funcionais** demonstrando a viabilidade
5. ✅ **Documentação completa** dos testes

### Próximos Passos Críticos

1. **Refatorar ghtools** para facilitar testes
2. **Adicionar modo não-interativo** para automação
3. **Melhorar mocks** para cenários complexos
4. **Escrever mais testes** para funções já identificadas
5. **Implementar cobertura real** com ferramentas apropriadas

### Prioridade Imediata

Para atingir 80% de cobertura:
1. Refatorar para separar funções de `main()`
2. Tornar funções independentes e testáveis
3. Adicionar mocks sophisticated
4. Escrever testes para as 28+ funções restantes

---

**Data:** 2025-12-05
**Versão:** 1.0
**Status:** Base implementada, melhorias necessárias para atingir meta
</file>


---

## Instructions

Please analyze the provided information and:

1. Understand the task requirements
2. Review the project structure
3. Consider the specified rules and constraints
4. Provide a detailed solution
