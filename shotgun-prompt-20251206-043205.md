## Context

You are an AI assistant helping with software development tasks.

**Current Date:** 2025-12-06 04:32:05

---

## Task Description

Procure por problemas ou bugs no script ghtools. Faça o diagnóstico e me diga como corrigir.

---

## Project Constraints & Rules



---

## Project Structure

└── ghtools/
    ├── mocks/
    ├── test/
    │   ├── helpers/
    │   ├── integration/
    │   │   ├── mocks/
    │   │   │   ├── fzf [215B]
    │   │   │   ├── gh [2.6KB]
    │   │   │   ├── git [1.6KB]
    │   │   │   ├── gum [825B]
    │   │   │   └── jq [74B]
    │   │   └── test_actions.bats [7.3KB]
    │   ├── mocks/
    │   ├── unit/
    │   │   ├── mocks/
    │   │   │   ├── fzf [215B]
    │   │   │   ├── gh [2.6KB]
    │   │   │   ├── gh_fail [19B]
    │   │   │   ├── gh_no_auth [76B]
    │   │   │   ├── git [1.6KB]
    │   │   │   ├── gum [825B]
    │   │   │   └── jq [74B]
    │   │   ├── test_action_clone.bats [2.9KB]
    │   │   ├── test_action_create.bats [2.4KB]
    │   │   ├── test_action_delete.bats [2.3KB]
    │   │   ├── test_action_list.bats [2.6KB]
    │   │   ├── test_action_sync.bats [4.7KB]
    │   │   ├── test_api_cache.bats [3.1KB]
    │   │   ├── test_cache_and_config.bats [3.0KB]
    │   │   ├── test_error_handling.bats [6.7KB]
    │   │   ├── test_gum_interactions.bats [6.7KB]
    │   │   ├── test_main_entry_point.bats [10.7KB]
    │   │   ├── test_printing_functions.bats [5.3KB]
    │   │   └── test_utility_functions.bats [4.0KB]
    │   ├── README.md [5.6KB]
    │   ├── bats.config.bash [480B]
    │   └── test_helper.bash [10.9KB]
    ├── AGENTS.md [2.8KB]
    ├── CLAUDE.md [5.1KB]
    ├── README.md [14.3KB]
    ├── ghtools [56.4KB]
    ├── install.sh [12.4KB]
    └── run_tests.sh [4.9KB]

<file path="test/integration/mocks/fzf">
#!/bin/bash
# Mock fzf - just select first line or echo input
if [ "$*" == *"--multi"* ]; then
    # Multi-select mode - return all lines
    cat
else
    # Single select - return first line
    head -n 1
fi
exit 0
</file>
<file path="test/integration/mocks/gh">
#!/bin/bash
case "$1" in
    "auth")
        if [ "$2" = "status" ]; then
            echo "github.com
  Logged in to github.com as user (oauth_token)
  Git operations done over the http on api.github.com
  Active user: user
  Token scopes: delete_repo, repo, read:org, gist"
            exit 0
        fi
        if [ "$2" = "refresh" ]; then
            # Mock auth refresh
            echo "Auth refreshed"
            exit 0
        fi
        ;;
    "repo")
        case "$2" in
            "list")
                # Check if --json flag is present
                if [[ "$*" == *"--json"* ]]; then
                    # Output mock JSON data
                    cat <<'JSON_DATA'
[
  {
    "name": "test-repo",
    "nameWithOwner": "user/test-repo",
    "description": "A test repository",
    "visibility": "PUBLIC",
    "primaryLanguage": {"name": "bash"},
    "stargazerCount": 10,
    "forkCount": 2,
    "diskUsage": 100,
    "updatedAt": "2024-01-01T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/test-repo",
    "sshUrl": "git@github.com:user/test-repo.git"
  },
  {
    "name": "private-repo",
    "nameWithOwner": "user/private-repo",
    "description": "A private test repository",
    "visibility": "PRIVATE",
    "primaryLanguage": {"name": "python"},
    "stargazerCount": 5,
    "forkCount": 1,
    "diskUsage": 200,
    "updatedAt": "2024-01-02T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/private-repo",
    "sshUrl": "git@github.com:user/private-repo.git"
  }
]
JSON_DATA
                    exit 0
                elif [ "$3" = "--limit" ]; then
                    # Output mock repository data (non-JSON)
                    echo "user/test-repo"
                    echo "user/private-repo"
                fi
                ;;
            "clone")
                echo "Mock clone of $3"
                exit 0
                ;;
            "create")
                echo "Mock create of $3"
                exit 0
                ;;
            "delete")
                echo "Mock delete of $3"
                exit 0
                ;;
            "edit")
                echo "Mock edit of $3"
                exit 0
                ;;
        esac
        ;;
    "search")
        if [ "$1" = "search" ] && [ "$2" = "repos" ]; then
            # Output mock search results
            echo "example/repo1"
            echo "example/repo2"
        fi
        ;;
    "api")
        # Mock API calls
        if [[ "$*" == *"user/starred"* ]]; then
            echo "Mock starred"
            exit 0
        fi
        ;;
esac
exit 0
</file>
<file path="test/integration/mocks/git">
#!/bin/bash
case "$1" in
    "init")
        # Handle git init with or without -q flag
        # git init -q (init in current dir, quiet)
        # git init <dir> (init in specified dir)
        # git init -q <dir> (init in specified dir, quiet)
        local dir=""
        shift  # skip "init"
        while [[ $# -gt 0 ]]; do
            case "$1" in
                -q|--quiet) shift ;;  # ignore quiet flag
                *) dir="$1"; shift ;;
            esac
        done
        # If no dir specified, use current directory
        if [[ -z "$dir" ]]; then
            mkdir -p ".git"
            echo "Initialized empty Git repository in .git/"
        else
            mkdir -p "$dir/.git"
            echo "Initialized empty Git repository in $dir/.git/"
        fi
        exit 0
        ;;
    "add")
        exit 0
        ;;
    "commit")
        echo "[master (root-commit) 1234567] Test commit"
        exit 0
        ;;
    "branch")
        if [ "$1" = "branch" ] && [ "$2" = "--show-current" ]; then
            echo "main"
            exit 0
        fi
        if [ "$1" = "branch" ]; then
            echo "* main"
            exit 0
        fi
        ;;
    "diff-index")
        # Pretend working tree is clean
        exit 0
        ;;
    "fetch")
        exit 0
        ;;
    "pull")
        echo "Already up to date."
        exit 0
        ;;
    "push")
        echo "Everything up-to-date"
        exit 0
        ;;
    "ls-remote")
        # Pretend remote branch exists
        exit 0
        ;;
    "rev-list")
        echo "0"
        exit 0
        ;;
esac
# Default: succeed
exit 0
</file>
<file path="test/integration/mocks/gum">
#!/bin/bash
# Mock gum - just echo the text or return first line for choose
case "$1" in
    "style")
        # Just output the text
        shift
        echo "$@"
        ;;
    "choose")
        # Return first option
        head -n 1
        ;;
    "input")
        # Return default or echo input
        if [[ "$*" == *"--value"* ]]; then
            # Get default value
            echo "default"
        else
            read -r input
            echo "${input:-default}"
        fi
        ;;
    "confirm")
        # Always return true
        exit 0
        ;;
    "filter")
        # Return input
        head -n 1
        ;;
    "write")
        # Return default text
        echo "Test commit message"
        ;;
    "spin")
        # Execute command and return
        shift
        "$@"
        ;;
esac
exit 0
</file>
<file path="test/integration/mocks/jq">
#!/bin/bash
# Simple jq mock - just pass through for basic operations
cat
</file>
<file path="test/integration/test_actions.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    local test_file="${BATS_TEST_FILENAME}"
    export PROJECT_DIR
    PROJECT_DIR="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up environment variables)
    source "$PROJECT_DIR/test/test_helper.bash"

    # Setup mocks (must be done after sourcing helper)
    # Note: We don't mock jq because we need real JSON processing
    mkdir -p "$TEST_TMP_DIR"
    setup_mock_gh
    setup_mock_git
    setup_mock_fzf
    setup_mock_gum
}

teardown() {
    teardown_test
}

# Test: action_list with default options
@test "action_list displays repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_list
    [ "$status" -eq 0 ]
    [[ "$output" == *"NAME"* ]]
    [[ "$output" == *"DESCRIPTION"* ]]
    [[ "$output" == *"VISIBILITY"* ]]
    [[ "$output" == *"LANG"* ]]
    [[ "$output" == *"UPDATED"* ]]
}

# Test: action_list with --refresh flag
@test "action_list with refresh flag forces cache update" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"

    run action_list --refresh
    [ "$status" -eq 0 ]
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: action_list with language filter
@test "action_list filters by language" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_list --lang bash
    [ "$status" -eq 0 ]
    [[ "$output" == *"NAME"* ]]
}

# Test: action_list with organization filter
@test "action_list filters by organization" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_list --org testorg
    [ "$status" -eq 0 ]
    [[ "$output" == *"NAME"* ]]
}

# Test: action_clone without arguments (uses default path)
@test "action_clone uses default clone path" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json
    mkdir -p "$HOME"

    run action_clone
    [ "$status" -eq 0 ]
}

# Test: action_clone with custom path
@test "action_clone accepts custom path" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json
    local test_dir="$TEST_TMP_DIR/clones"
    mkdir -p "$test_dir"

    run action_clone --path "$test_dir"
    [ "$status" -eq 0 ]
}

# Test: action_sync with dry-run mode
@test "action_sync dry-run mode shows what would be synced" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run action_sync --path "$test_dir" --dry-run
    [ "$status" -eq 0 ]
}

# Test: action_sync with --all flag
@test "action_sync with all flag syncs all repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    mkdir -p "$test_dir/repo2"
    create_test_git_repo "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo2"

    run action_sync --path "$test_dir" --all
    [ "$status" -eq 0 ]
}

# Test: action_sync with max-depth
@test "action_sync respects max-depth parameter" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir"

    run action_sync --path "$test_dir" --max-depth 1
    [ "$status" -eq 0 ]
}

# Test: action_status displays repository status
@test "action_status shows repository status" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run action_status --path "$test_dir"
    [ "$status" -eq 0 ]
    [[ "$output" == *"REPOSITORY"* ]]
    [[ "$output" == *"BRANCH"* ]]
    [[ "$output" == *"STATUS"* ]]
}

# Test: action_status with max-depth
@test "action_status respects max-depth parameter" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir"

    run action_status --path "$test_dir" --max-depth 2
    [ "$status" -eq 0 ]
}

# Test: action_stats generates statistics
@test "action_stats displays statistics dashboard" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    # Stats command may timeout in test environment, just check it starts
    run timeout 5 bash -c "source ${PROJECT_DIR}/ghtools && action_stats 2>&1 || true"
    [[ "$output" == *"Total Repositories"* ]] || [[ "$output" == *"REPOSITORY STATISTICS"* ]] || [[ "$output" == *"stats"* ]] || [ "$status" -eq 0 ]
}

# Test: action_browse opens repositories in browser
@test "action_browse opens selected repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_browse
    [ "$status" -eq 0 ]
}

# Test: action_search performs fuzzy search
@test "action_search performs repository search" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_search
    [ "$status" -eq 0 ]
}

# Test: action_fork without arguments
@test "action_fork prompts for search query" {
    PATH="${MOCK_DIR}:${PATH}"

    # Mock user input
    export GH_FORK_QUERY="test"

    run action_fork "test query"
    [ "$status" -eq 0 ]
}

# Test: action_fork with --clone flag
@test "action_fork with clone flag forks and clones" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_fork --clone "test query"
    [ "$status" -eq 0 ]
}

# Test: action_explore with query
@test "action_explore searches external repositories" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_explore "machine learning" --lang python
    [ "$status" -eq 0 ]
}

# Test: action_trending with language filter
@test "action_trending shows trending repositories" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_trending --lang python
    [ "$status" -eq 0 ]
}

# Test: action_archive archives repositories
@test "action_archive archives selected repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_archive
    [ "$status" -eq 0 ]
}

# Test: action_archive with --unarchive flag
@test "action_archive unarchives repositories" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_archive --unarchive
    [ "$status" -eq 0 ]
}

# Test: action_visibility changes repository visibility
@test "action_visibility changes to public" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_visibility --public
    [ "$status" -eq 0 ]
}

@test "action_visibility changes to private" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_visibility --private
    [ "$status" -eq 0 ]
}

# Test: action_pr list subcommand
@test "action_pr list shows pull requests" {
    PATH="${MOCK_DIR}:${PATH}"
    create_mock_json

    run action_pr list
    [ "$status" -eq 0 ]
}

# Test: apply_template for python
@test "apply_template creates python template" {
    local test_dir="$TEST_TMP_DIR/test_repo"
    mkdir -p "$test_dir"

    run apply_template "$test_dir" "python"
    [ "$status" -eq 0 ]
    [ -f "$test_dir/main.py" ]
    [ -f "$test_dir/README.md" ]
    [ -f "$test_dir/.gitignore" ]
}

# Test: apply_template for node
@test "apply_template creates node template" {
    local test_dir="$TEST_TMP_DIR/test_repo"
    mkdir -p "$test_dir"

    run apply_template "$test_dir" "node"
    [ "$status" -eq 0 ]
    [ -f "$test_dir/index.js" ]
    [ -f "$test_dir/package.json" ]
    [ -f "$test_dir/README.md" ]
    [ -f "$test_dir/.gitignore" ]
}

# Test: apply_template for go
@test "apply_template creates go template" {
    local test_dir="$TEST_TMP_DIR/test_repo"
    mkdir -p "$test_dir"

    run apply_template "$test_dir" "go"
    [ "$status" -eq 0 ]
    [ -f "$test_dir/main.go" ]
    [ -f "$test_dir/README.md" ]
}
</file>
<file path="test/unit/mocks/fzf">
#!/bin/bash
# Mock fzf - just select first line or echo input
if [ "$*" == *"--multi"* ]; then
    # Multi-select mode - return all lines
    cat
else
    # Single select - return first line
    head -n 1
fi
exit 0
</file>
<file path="test/unit/mocks/gh">
#!/bin/bash
case "$1" in
    "auth")
        if [ "$2" = "status" ]; then
            echo "github.com
  Logged in to github.com as user (oauth_token)
  Git operations done over the http on api.github.com
  Active user: user
  Token scopes: delete_repo, repo, read:org, gist"
            exit 0
        fi
        if [ "$2" = "refresh" ]; then
            # Mock auth refresh
            echo "Auth refreshed"
            exit 0
        fi
        ;;
    "repo")
        case "$2" in
            "list")
                # Check if --json flag is present
                if [[ "$*" == *"--json"* ]]; then
                    # Output mock JSON data
                    cat <<'JSON_DATA'
[
  {
    "name": "test-repo",
    "nameWithOwner": "user/test-repo",
    "description": "A test repository",
    "visibility": "PUBLIC",
    "primaryLanguage": {"name": "bash"},
    "stargazerCount": 10,
    "forkCount": 2,
    "diskUsage": 100,
    "updatedAt": "2024-01-01T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/test-repo",
    "sshUrl": "git@github.com:user/test-repo.git"
  },
  {
    "name": "private-repo",
    "nameWithOwner": "user/private-repo",
    "description": "A private test repository",
    "visibility": "PRIVATE",
    "primaryLanguage": {"name": "python"},
    "stargazerCount": 5,
    "forkCount": 1,
    "diskUsage": 200,
    "updatedAt": "2024-01-02T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/private-repo",
    "sshUrl": "git@github.com:user/private-repo.git"
  }
]
JSON_DATA
                    exit 0
                elif [ "$3" = "--limit" ]; then
                    # Output mock repository data (non-JSON)
                    echo "user/test-repo"
                    echo "user/private-repo"
                fi
                ;;
            "clone")
                echo "Mock clone of $3"
                exit 0
                ;;
            "create")
                echo "Mock create of $3"
                exit 0
                ;;
            "delete")
                echo "Mock delete of $3"
                exit 0
                ;;
            "edit")
                echo "Mock edit of $3"
                exit 0
                ;;
        esac
        ;;
    "search")
        if [ "$1" = "search" ] && [ "$2" = "repos" ]; then
            # Output mock search results
            echo "example/repo1"
            echo "example/repo2"
        fi
        ;;
    "api")
        # Mock API calls
        if [[ "$*" == *"user/starred"* ]]; then
            echo "Mock starred"
            exit 0
        fi
        ;;
esac
exit 0
</file>
<file path="test/unit/mocks/gh_fail">
#!/bin/bash
exit 1
</file>
<file path="test/unit/mocks/gh_no_auth">
#!/bin/bash
if [ "$1" = "auth" ] && [ "$2" = "status" ]; then
    exit 1
fi
</file>
<file path="test/unit/mocks/git">
#!/bin/bash
case "$1" in
    "init")
        # Handle git init with or without -q flag
        # git init -q (init in current dir, quiet)
        # git init <dir> (init in specified dir)
        # git init -q <dir> (init in specified dir, quiet)
        local dir=""
        shift  # skip "init"
        while [[ $# -gt 0 ]]; do
            case "$1" in
                -q|--quiet) shift ;;  # ignore quiet flag
                *) dir="$1"; shift ;;
            esac
        done
        # If no dir specified, use current directory
        if [[ -z "$dir" ]]; then
            mkdir -p ".git"
            echo "Initialized empty Git repository in .git/"
        else
            mkdir -p "$dir/.git"
            echo "Initialized empty Git repository in $dir/.git/"
        fi
        exit 0
        ;;
    "add")
        exit 0
        ;;
    "commit")
        echo "[master (root-commit) 1234567] Test commit"
        exit 0
        ;;
    "branch")
        if [ "$1" = "branch" ] && [ "$2" = "--show-current" ]; then
            echo "main"
            exit 0
        fi
        if [ "$1" = "branch" ]; then
            echo "* main"
            exit 0
        fi
        ;;
    "diff-index")
        # Pretend working tree is clean
        exit 0
        ;;
    "fetch")
        exit 0
        ;;
    "pull")
        echo "Already up to date."
        exit 0
        ;;
    "push")
        echo "Everything up-to-date"
        exit 0
        ;;
    "ls-remote")
        # Pretend remote branch exists
        exit 0
        ;;
    "rev-list")
        echo "0"
        exit 0
        ;;
esac
# Default: succeed
exit 0
</file>
<file path="test/unit/mocks/gum">
#!/bin/bash
# Mock gum - just echo the text or return first line for choose
case "$1" in
    "style")
        # Just output the text
        shift
        echo "$@"
        ;;
    "choose")
        # Return first option
        head -n 1
        ;;
    "input")
        # Return default or echo input
        if [[ "$*" == *"--value"* ]]; then
            # Get default value
            echo "default"
        else
            read -r input
            echo "${input:-default}"
        fi
        ;;
    "confirm")
        # Always return true
        exit 0
        ;;
    "filter")
        # Return input
        head -n 1
        ;;
    "write")
        # Return default text
        echo "Test commit message"
        ;;
    "spin")
        # Execute command and return
        shift
        "$@"
        ;;
esac
exit 0
</file>
<file path="test/unit/mocks/jq">
#!/bin/bash
# Simple jq mock - just pass through for basic operations
cat
</file>
<file path="test/unit/test_action_clone.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: action_clone
# ========================================

@test "action_clone executes without error" {
    create_mock_json
    run action_clone
    [ "$status" -eq 0 ]
}

@test "action_clone with --path flag executes without error" {
    create_mock_json
    mkdir -p /tmp/test_clone_path
    run action_clone --path /tmp/test_clone_path
    [ "$status" -eq 0 ]
}

@test "action_clone with default path executes without error" {
    create_mock_json
    run action_clone --path "$(pwd)"
    [ "$status" -eq 0 ]
}

@test "action_clone handles non-existent path" {
    create_mock_json
    run action_clone --path "/nonexistent/path"
    [ "$status" -eq 1 ]
}

@test "action_clone handles empty cache" {
    echo '[]' > "$CACHE_FILE"
    run action_clone
    [ "$status" -eq 0 ]
}

@test "action_clone handles cache with valid data" {
    create_mock_json
    run action_clone
    [ "$status" -eq 0 ]
}

@test "action_clone respects quiet mode" {
    export QUIET=true
    create_mock_json
    run action_clone
    [ "$status" -eq 0 ]
}

@test "action_clone handles path with spaces" {
    create_mock_json
    mkdir -p "/tmp/test path with spaces"
    run action_clone --path "/tmp/test path with spaces"
    [ "$status" -eq 0 ]
}

@test "action_clone handles path with special characters" {
    create_mock_json
    mkdir -p "/tmp/test-path_123"
    run action_clone --path "/tmp/test-path_123"
    [ "$status" -eq 0 ]
}

@test "action_clone handles path with trailing slash" {
    create_mock_json
    mkdir -p /tmp/test_trailing
    run action_clone --path "/tmp/test_trailing/"
    [ "$status" -eq 0 ]
}

@test "action_clone handles empty --path parameter" {
    create_mock_json
    run action_clone --path ""
    # Empty path may fail, which is expected behavior
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_clone handles path with tilde expansion" {
    create_mock_json
    # Tilde expansion might not work in all test environments
    # Accept either success or failure
    run action_clone --path "~"
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_clone handles multiple options together" {
    create_mock_json
    mkdir -p /tmp/test_multi
    run action_clone --path /tmp/test_multi
    [ "$status" -eq 0 ]
}

@test "action_clone respects verbose mode" {
    export VERBOSE=true
    create_mock_json
    run action_clone
    [ "$status" -eq 0 ]
}

@test "action_clone handles cache refresh" {
    create_mock_json
    run action_clone --path "$(pwd)"
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_action_create.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: action_create
# ========================================

@test "action_create executes without error" {
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create validates dependencies" {
    run action_create
    # Depends on interactive input, may fail in test
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles empty repository name" {
    # Mock will simulate empty input
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles repository name input" {
    # Mock will simulate name input
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles description input" {
    # Mock will simulate description input
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles visibility selection" {
    # Mock will simulate visibility selection
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles template selection" {
    # Mock will simulate template selection
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create respects quiet mode" {
    export QUIET=true
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles multiple templates" {
    # Mock will simulate template options
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles public repository" {
    # Mock will simulate public selection
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles private repository" {
    # Mock will simulate private selection
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_create handles repository creation flow" {
    # Full flow test - may fail in non-interactive environment
    run action_create
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}
</file>
<file path="test/unit/test_action_delete.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: action_delete
# ========================================

@test "action_delete executes without error" {
    create_mock_json
    # Delete requires interactive input, may fail in test environment
    run action_delete
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete checks dependencies" {
    create_mock_json
    # Dependencies check should work
    run action_delete
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete handles empty cache" {
    echo '[]' > "$CACHE_FILE"
    run action_delete
    # Empty cache may cause different behavior
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete handles cache with valid data" {
    create_mock_json
    run action_delete
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete respects quiet mode" {
    export QUIET=true
    create_mock_json
    run action_delete
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete handles mock confirmation" {
    create_mock_json
    # Mock will simulate user canceling (expected behavior)
    run action_delete
    # User cancellation is acceptable
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete validates delete scope" {
    create_mock_json
    run action_delete
    # Scope validation may fail in test environment
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete handles multiple repositories" {
    create_mock_json
    run action_delete
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete handles repository selection" {
    create_mock_json
    # Mock will simulate user selection
    run action_delete
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_delete handles cache clearing" {
    create_mock_json
    # Delete operation may clear cache
    run action_delete
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}
</file>
<file path="test/unit/test_action_list.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: action_list
# ========================================

@test "action_list executes without error" {
    create_mock_json
    run action_list
    [ "$status" -eq 0 ]
}

@test "action_list with --refresh flag executes without error" {
    create_mock_json
    run action_list --refresh
    [ "$status" -eq 0 ]
}

@test "action_list with --lang filter executes without error" {
    create_mock_json
    run action_list --lang python
    [ "$status" -eq 0 ]
}

@test "action_list with --org filter executes without error" {
    create_mock_json
    run action_list --org myorg
    [ "$status" -eq 0 ]
}

@test "action_list with multiple flags executes without error" {
    create_mock_json
    run action_list --refresh --lang python --org myorg
    [ "$status" -eq 0 ]
}

@test "action_list handles empty cache" {
    echo '[]' > "$CACHE_FILE"
    run action_list
    [ "$status" -eq 0 ]
}

@test "action_list handles cache with valid data" {
    create_mock_json
    run action_list
    [ "$status" -eq 0 ]
}

@test "action_list handles language filter case-insensitive" {
    create_mock_json
    run action_list --lang PYTHON
    [ "$status" -eq 0 ]
}

@test "action_list handles empty organization filter" {
    create_mock_json
    run action_list --org ""
    [ "$status" -eq 0 ]
}

@test "action_list handles organization with special characters" {
    create_mock_json
    run action_list --org "my-org_123"
    [ "$status" -eq 0 ]
}

@test "action_list handles language filter with special characters" {
    create_mock_json
    run action_list --lang "c++"
    [ "$status" -eq 0 ]
}

@test "action_list handles language filter with spaces" {
    create_mock_json
    run action_list --lang "objective c"
    [ "$status" -eq 0 ]
}

@test "action_list handles organization with spaces" {
    create_mock_json
    run action_list --org "my organization"
    [ "$status" -eq 0 ]
}

@test "action_list handles mixed case organization" {
    create_mock_json
    run action_list --org "MyOrg"
    [ "$status" -eq 0 ]
}

@test "action_list respects quiet mode" {
    export QUIET=true
    create_mock_json
    run action_list
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_action_sync.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: action_sync
# ========================================

@test "action_sync executes without error" {
    create_test_git_repo "/tmp/test_sync_repo"
    export DEFAULT_CLONE_PATH="/tmp"
    run action_sync --path /tmp/test_sync_repo --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync with --dry-run flag executes without error" {
    create_test_git_repo "/tmp/test_sync_dryrun"
    run action_sync --path /tmp/test_sync_dryrun --dry-run --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync with --all flag executes without error" {
    create_test_git_repo "/tmp/test_sync_all"
    run action_sync --path /tmp/test_sync_all --all --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync with --max-depth flag executes without error" {
    create_test_git_repo "/tmp/test_sync_depth"
    run action_sync --path /tmp/test_sync_depth --max-depth 2
    [ "$status" -eq 0 ]
}

@test "action_sync with custom path executes without error" {
    create_test_git_repo "/tmp/custom_sync_path"
    run action_sync --path /tmp/custom_sync_path --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync handles non-existent path" {
    run action_sync --path "/nonexistent/path"
    [ "$status" -eq 0 ]
}

@test "action_sync handles directory with no git repos" {
    mkdir -p "/tmp/no_git_dir"
    run action_sync --path /tmp/no_git_dir --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync handles multiple options together" {
    create_test_git_repo "/tmp/test_sync_multi"
    run action_sync --path /tmp/test_sync_multi --dry-run --all --max-depth 2
    [ "$status" -eq 0 ]
}

@test "action_sync respects quiet mode" {
    export QUIET=true
    create_test_git_repo "/tmp/test_sync_quiet"
    run action_sync --path /tmp/test_sync_quiet --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync respects verbose mode" {
    export VERBOSE=true
    create_test_git_repo "/tmp/test_sync_verbose"
    run action_sync --path /tmp/test_sync_verbose --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync handles path with spaces" {
    create_test_git_repo "/tmp/sync path test"
    run action_sync --path "/tmp/sync path test" --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync handles path with special characters" {
    create_test_git_repo "/tmp/sync-path_123"
    run action_sync --path "/tmp/sync-path_123" --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync handles zero max-depth" {
    create_test_git_repo "/tmp/sync_zero_depth"
    run action_sync --path /tmp/sync_zero_depth --max-depth 0
    [ "$status" -eq 0 ]
}

@test "action_sync handles large max-depth" {
    create_test_git_repo "/tmp/sync_large_depth"
    run action_sync --path /tmp/sync_large_depth --max-depth 10
    [ "$status" -eq 0 ]
}

@test "action_sync handles empty --path parameter" {
    # Empty path may fail or use default
    run action_sync --path ""
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

@test "action_sync handles default path (no --path flag)" {
    create_test_git_repo "/tmp/test_sync_default"
    export DEFAULT_CLONE_PATH="/tmp"
    run action_sync --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync handles multiple git repos" {
    # Clean up any previous test artifacts
    rm -rf "/tmp/sync_multi_1" "/tmp/sync_multi_2" "/tmp/sync_multi_dir"
    create_test_git_repo "/tmp/sync_multi_1"
    create_test_git_repo "/tmp/sync_multi_2"
    mkdir -p "/tmp/sync_multi_dir"
    mv /tmp/sync_multi_1 /tmp/sync_multi_dir/
    mv /tmp/sync_multi_2 /tmp/sync_multi_dir/
    run action_sync --path /tmp/sync_multi_dir --max-depth 2
    [ "$status" -eq 0 ]
}

@test "action_sync respects max_jobs setting" {
    create_test_git_repo "/tmp/test_sync_jobs"
    export MAX_JOBS=2
    run action_sync --path /tmp/test_sync_jobs --max-depth 1
    [ "$status" -eq 0 ]
}

@test "action_sync handles sync_all with multiple repos" {
    mkdir -p "/tmp/sync_all_test"
    create_test_git_repo "/tmp/sync_all_test/repo1"
    create_test_git_repo "/tmp/sync_all_test/repo2"
    run action_sync --path /tmp/sync_all_test --all --max-depth 2
    [ "$status" -eq 0 ]
}

@test "action_sync handles dry-run with no changes" {
    create_test_git_repo "/tmp/sync_dryrun_nochanges"
    run action_sync --path /tmp/sync_dryrun_nochanges --dry-run --max-depth 1
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_api_cache.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: fetch_repositories_json
# ========================================

@test "fetch_repositories_json executes without error" {
    # Create a mock cache file to avoid actual API call
    create_mock_json
    run fetch_repositories_json
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json respects force_refresh parameter" {
    create_mock_json
    run fetch_repositories_json "true"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json respects limit parameter" {
    create_mock_json
    run fetch_repositories_json "false" "10"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json respects organization filter" {
    create_mock_json
    run fetch_repositories_json "false" "100" "testorg"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json handles all parameters together" {
    create_mock_json
    run fetch_repositories_json "true" "50" "myorg"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json handles empty organization filter" {
    create_mock_json
    run fetch_repositories_json "false" "100" ""
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json works without organization filter" {
    create_mock_json
    run fetch_repositories_json
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json handles organization filter with special characters" {
    create_mock_json
    run fetch_repositories_json "false" "100" "my-org_123"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json handles zero limit" {
    create_mock_json
    run fetch_repositories_json "false" "0"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json handles large limit" {
    create_mock_json
    run fetch_repositories_json "false" "1000"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json handles default parameters" {
    create_mock_json
    run fetch_repositories_json "" "" ""
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json outputs valid JSON when cache exists" {
    create_mock_json
    run fetch_repositories_json "false"
    [ "$status" -eq 0 ]
    # Check if output contains JSON-like structure (even if it's mock data)
    [ -n "$output" ]
}

@test "fetch_repositories_json respects custom cache file" {
    # Set custom cache file path
    export CACHE_FILE="/tmp/test_custom_cache.json"
    echo '[]' > "$CACHE_FILE"
    run fetch_repositories_json "true"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json creates cache when forced refresh" {
    # Ensure cache doesn't exist initially
    rm -f "$CACHE_FILE"
    run fetch_repositories_json "true"
    [ "$status" -eq 0 ]
}

@test "fetch_repositories_json works with default TTL" {
    create_mock_json
    export CACHE_TTL=600
    run fetch_repositories_json
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_cache_and_config.bats">
#!/usr/bin/env bats

load '../test_helper.bash'

# Test: fetch_repositories_json with refresh
@test "fetch_repositories_json with force refresh creates cache" {
    PATH="${MOCK_DIR}:${PATH}"
    rm -f "$TEST_CACHE_FILE"
    export CACHE_TTL=600
    export DEFAULT_ORG=""

    run fetch_repositories_json "true"
    [ "$status" -eq 0 ]
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: fetch_repositories_json uses cache when valid
@test "fetch_repositories_json uses cache when valid" {
    PATH="${MOCK_DIR}:${PATH}"
    # Create a valid cache file
    create_mock_json
    touch -t 202412010000 "$TEST_CACHE_FILE"

    run fetch_repositories_json "false"
    [ "$status" -eq 0 ]
}

# Test: fetch_repositories_json with organization filter
@test "fetch_repositories_json respects organization filter" {
    PATH="${MOCK_DIR}:${PATH}"
    export DEFAULT_ORG="testorg"

    run fetch_repositories_json "true" "100" "testorg"
    [ "$status" -eq 0 ]
    # Check that cache was created
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: fetch_repositories_json with invalid org (should still create cache)
@test "fetch_repositories_json handles org filter gracefully" {
    PATH="${MOCK_DIR}:${PATH}"
    rm -f "$TEST_CACHE_FILE"

    run fetch_repositories_json "true" "100" "nonexistent"
    [ "$status" -eq 0 ]
    [ -f "$TEST_CACHE_FILE" ]
}

# Test: Configuration loading
@test "load_config respects XDG_CONFIG_HOME" {
    export XDG_CONFIG_HOME="$TEST_TMP_DIR/custom_config"
    mkdir -p "$XDG_CONFIG_HOME/ghtools"
    # Use a valid config variable
    echo 'MAX_JOBS=8' > "$XDG_CONFIG_HOME/ghtools/config"

    # Reload to pick up new config dir
    CONFIG_DIR="${XDG_CONFIG_HOME}/ghtools"
    CONFIG_FILE="$CONFIG_DIR/config"

    run load_config
    [ "$status" -eq 0 ]
}

# Test: Default configuration values
@test "init_config creates default config with commented options" {
    rm -rf "$TEST_CONFIG_DIR"
    run init_config
    [ "$status" -eq 0 ]
    [ -f "$TEST_CONFIG_FILE" ]

    content=$(cat "$TEST_CONFIG_FILE")
    [[ "$content" == *"CACHE_TTL"* ]]
    [[ "$content" == *"MAX_JOBS"* ]]
    [[ "$content" == *"DEFAULT_ORG"* ]]
    [[ "$content" == *"DEFAULT_CLONE_PATH"* ]]
}

# Test: Configuration overrides
@test "load_config applies configuration overrides" {
    mkdir -p "$TEST_CONFIG_DIR"
    cat > "$TEST_CONFIG_FILE" <<EOF
CACHE_TTL=300
MAX_JOBS=10
DEFAULT_CLONE_PATH="/custom/path"
EOF

    load_config
    [ "$CACHE_TTL" = "300" ]
    [ "$MAX_JOBS" = "10" ]
    [ "$DEFAULT_CLONE_PATH" = "/custom/path" ]
}

# Test: Cache TTL validation
@test "is_cache_valid respects CACHE_TTL setting" {
    export CACHE_TTL=60  # 1 minute
    echo '{}' > "$TEST_CACHE_FILE"
    # File is 2 minutes old, should be invalid
    touch -d "2 minutes ago" "$TEST_CACHE_FILE"

    run is_cache_valid
    [ "$status" -eq 1 ]
}

@test "is_cache_valid accepts fresh cache" {
    export CACHE_TTL=3600  # 1 hour
    echo '{}' > "$TEST_CACHE_FILE"
    # File is fresh (just created), should be valid
    touch "$TEST_CACHE_FILE"

    run is_cache_valid
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_error_handling.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper
    source "$project_dir/test/test_helper.bash"

    # Setup mocks
    mkdir -p "$TEST_TMP_DIR"
    setup_mock_gh
    setup_mock_git
    setup_mock_fzf
    setup_mock_gum
}

teardown() {
    teardown_test
}

# Test: check_dependencies with missing required commands
@test "check_dependencies fails with missing required command" {
    # Save original PATH
    ORIGINAL_PATH="$PATH"

    # Create empty PATH to simulate missing commands
    PATH="/nonexistent"

    run check_dependencies
    [ "$status" -eq 1 ]
    [[ "$output" == *"Missing required dependencies"* ]]

    # Restore PATH
    PATH="$ORIGINAL_PATH"
}

# Test: check_gh_auth when not authenticated
@test "check_gh_auth fails when not authenticated" {
    # Override gh mock to return failure for auth status
    cat > "${MOCK_DIR}/gh" <<'MOCK'
#!/bin/bash
if [ "$1" = "auth" ] && [ "$2" = "status" ]; then
    echo "not authenticated" >&2
    exit 1
fi
exit 0
MOCK
    chmod +x "${MOCK_DIR}/gh"

    PATH="${MOCK_DIR}:${PATH}"

    run check_gh_auth
    [ "$status" -eq 1 ]
}

# Test: action_list with no repositories
@test "action_list handles empty repository list" {
    PATH="${MOCK_DIR}:${PATH}"
    # Create empty cache
    echo '[]' > "$TEST_CACHE_FILE"

    run action_list
    [ "$status" -eq 0 ]
}

# Test: action_list with failed API call
@test "action_list handles API failure gracefully" {
    # Remove cache to force API call
    rm -f "$TEST_CACHE_FILE"

    # Override gh mock to fail
    cat > "${MOCK_DIR}/gh" <<'MOCK'
#!/bin/bash
echo "API Error" >&2
exit 1
MOCK
    chmod +x "${MOCK_DIR}/gh"
    PATH="${MOCK_DIR}:${PATH}"

    run action_list --refresh
    # May return 1 or exit gracefully with 0 depending on implementation
    [ "$status" -eq 1 ] || [ "$status" -eq 0 ]
}

# Test: action_sync with non-existent path
@test "action_sync handles non-existent path" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_sync --path "/nonexistent/path"
    [ "$status" -eq 0 ]  # Should handle gracefully, not fail
}

# Test: action_sync with no git repositories
@test "action_sync handles directory with no git repos" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/empty"
    mkdir -p "$test_dir"

    run action_sync --path "$test_dir"
    # Should complete successfully even with no repos
    [ "$status" -eq 0 ]
}

# Test: action_clone with non-existent clone path
@test "action_clone fails with non-existent path" {
    PATH="${MOCK_DIR}:${PATH}"

    run action_clone --path "/nonexistent/path"
    [ "$status" -eq 1 ]
    [[ "$output" == *"does not exist"* ]]
}

# Test: action_create with empty name
@test "action_create handles empty name" {
    PATH="${MOCK_DIR}:${PATH}"
    cd "$TEST_TMP_DIR"

    run action_create
    [ "$status" -eq 0 ]
    # Should not crash, gum/input will handle empty input
}

# Test: truncate_text with zero limit
@test "truncate_text handles zero limit" {
    result=$(truncate_text "test" 0)
    # Zero or very short limit should return minimal result
    [ ${#result} -le 5 ]  # May return "..." or empty
}

# Test: truncate_text with negative limit
@test "truncate_text handles negative limit" {
    result=$(truncate_text "test" -1)
    [ ${#result} -le 4 ]
}

# Test: is_cache_valid with empty file
@test "is_cache_valid handles empty file" {
    touch "$TEST_CACHE_FILE"

    run is_cache_valid
    # Empty file may be considered valid (file exists and is recent)
    [ "$status" -eq 0 ] || [ "$status" -eq 1 ]
}

# Test: action_delete without delete_repo scope
@test "action_delete handles missing delete scope" {
    # Mock check_delete_scope to return false
    check_delete_scope() {
        return 1
    }

    export -f check_delete_scope

    run action_delete
    [ "$status" -eq 1 ]
}

# Test: action_pr_create not in git repository
@test "action_pr_create fails outside git repository" {
    cd "$TEST_TMP_DIR"

    run action_pr_create
    [ "$status" -eq 1 ]
    [[ "$output" == *"Not in a git repository"* ]]
}

# Test: action_pr_create on main/master branch
@test "action_pr_create detects main/master branch" {
    PATH="${MOCK_DIR}:${PATH}"
    cd "$TEST_TMP_DIR"
    mkdir -p ".git"

    run action_pr_create
    # Should fail or warn when on main/master branch
    [ "$status" -eq 1 ] || [ "$status" -eq 0 ]
}

# Test: fetch_repositories_json with limit 0
@test "fetch_repositories_json handles limit 0" {
    PATH="${MOCK_DIR}:${PATH}"

    run fetch_repositories_json "true" "0"
    [ "$status" -eq 0 ]
}

# Test: show_header with and without subtitle
@test "show_header handles optional subtitle" {
    run show_header "Test Title" "Test Subtitle"
    [ "$status" -eq 0 ]
    [[ "$output" == *"Test Title"* ]]

    run show_header "Test Title Only"
    [ "$status" -eq 0 ]
    [[ "$output" == *"Test Title Only"* ]]
}

# Test: show_divider with and without title
@test "show_divider handles optional title" {
    run show_divider "Section Title"
    [ "$status" -eq 0 ]

    run show_divider
    [ "$status" -eq 0 ]
}

# Test: print_functions with QUIET mode
@test "print_info respects QUIET mode" {
    QUIET=true
    run print_info "Test message"
    [ "$status" -eq 0 ]
    [ -z "$output" ]
}

# Test: print_verbose with VERBOSE disabled
@test "print_verbose respects VERBOSE disabled" {
    VERBOSE=false
    run print_verbose "Debug message"
    [ "$status" -eq 0 ]
    [ -z "$output" ]
}

# Test: gum_confirm with default yes
@test "gum_confirm handles default yes" {
    PATH="${MOCK_DIR}:${PATH}"
    # Provide input to simulate user response
    run bash -c 'echo "y" | gum_confirm "Test prompt" "yes"'
    [ "$status" -eq 0 ]
}

# Test: gum_input with default value
@test "gum_input handles default value" {
    PATH="${MOCK_DIR}:${PATH}"
    run gum_input "Placeholder" "› " "default_value"
    [ "$status" -eq 0 ]
}

# Test: gum_choose with multiple options
@test "gum_choose handles multiple options" {
    PATH="${MOCK_DIR}:${PATH}"
    run gum_choose "Choose:" "Option 1" "Option 2" "Option 3"
    [ "$status" -eq 0 ]
}

# Test: gum_filter with multi-select
@test "gum_filter handles multi-select mode" {
    PATH="${MOCK_DIR}:${PATH}"
    run gum_filter "Filter items" "true"
    [ "$status" -eq 0 ]
}

# Test: run_with_spinner
@test "run_with_spinner executes command" {
    PATH="${MOCK_DIR}:${PATH}"
    run run_with_spinner "Testing" echo "success"
    [ "$status" -eq 0 ]
    [[ "$output" == *"success"* ]]
}

# Test: wait_for_jobs with multiple jobs
@test "wait_for_jobs handles job limit" {
    # Start some background jobs
    (sleep 0.1) &
    (sleep 0.1) &
    (sleep 0.1) &

    run wait_for_jobs
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_gum_interactions.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"

    # Setup mocks for interactive commands
    mkdir -p "$TEST_TMP_DIR"
    setup_mock_gh
    setup_mock_git
    setup_mock_fzf
    setup_mock_gum
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: gum_confirm
# These tests pipe input to simulate user response
# ========================================

@test "gum_confirm executes without error" {
    # Simulate user typing 'y' (yes)
    run bash -c 'echo "y" | gum_confirm "Test prompt"'
    [ "$status" -eq 0 ]
}

@test "gum_confirm respects default yes parameter" {
    run bash -c 'echo "y" | gum_confirm "Test prompt" "yes"'
    [ "$status" -eq 0 ]
}

@test "gum_confirm respects default no parameter" {
    # When default is no and user types nothing, should fail
    run bash -c 'echo "" | gum_confirm "Test prompt" "no"'
    [ "$status" -eq 1 ]
}

@test "gum_confirm handles empty prompt" {
    run bash -c 'echo "y" | gum_confirm ""'
    [ "$status" -eq 0 ]
}

@test "gum_confirm handles prompt with special characters" {
    run bash -c 'echo "y" | gum_confirm "Are you sure? (!@#$%)"'
    [ "$status" -eq 0 ]
}

@test "gum_confirm handles prompt with quotes" {
    run bash -c "echo 'y' | gum_confirm \"Continue with 'special' prompt?\""
    [ "$status" -eq 0 ]
}

@test "gum_confirm handles long prompt" {
    local long_prompt="This is a very long confirmation prompt "
    long_prompt+="that exceeds normal line length and should be handled gracefully "
    long_prompt+="without causing any issues."
    run bash -c "echo 'y' | gum_confirm '$long_prompt'"
    [ "$status" -eq 0 ]
}

@test "gum_confirm handles prompt with newlines" {
    run bash -c 'echo "y" | gum_confirm "Line 1 Line 2"'
    [ "$status" -eq 0 ]
}

@test "gum_confirm handles prompt with international characters" {
    run bash -c 'echo "y" | gum_confirm "¿Continuar?"'
    [ "$status" -eq 0 ]
}

@test "gum_confirm handles prompt with unicode" {
    run bash -c 'echo "y" | gum_confirm "Continue? 🎉"'
    [ "$status" -eq 0 ]
}

# ========================================
# Test Suite: gum_input
# ========================================

@test "gum_input executes without error" {
    run gum_input "Test placeholder"
    [ "$status" -eq 0 ]
}

@test "gum_input handles custom prompt" {
    run gum_input "Name" "Enter > "
    [ "$status" -eq 0 ]
}

@test "gum_input handles default value" {
    run gum_input "Name" "› " "default"
    [ "$status" -eq 0 ]
}

@test "gum_input handles empty placeholder" {
    run gum_input ""
    [ "$status" -eq 0 ]
}

@test "gum_input handles placeholder with special characters" {
    run gum_input "Email (user@domain.com)"
    [ "$status" -eq 0 ]
}

@test "gum_input handles placeholder with quotes" {
    run gum_input "Enter 'username'"
    [ "$status" -eq 0 ]
}

@test "gum_input handles long placeholder" {
    local long_placeholder="This is a very long placeholder text "
    long_placeholder+="that exceeds normal line length and should be handled gracefully "
    long_placeholder+="without causing any issues."
    run gum_input "$long_placeholder"
    [ "$status" -eq 0 ]
}

@test "gum_input handles placeholder with newlines" {
    run gum_input -e "Line 1\nLine 2"
    [ "$status" -eq 0 ]
}

@test "gum_input handles placeholder with international characters" {
    run gum_input "Nombre"
    [ "$status" -eq 0 ]
}

@test "gum_input handles placeholder with unicode" {
    run gum_input "Name 🎉"
    [ "$status" -eq 0 ]
}

# ========================================
# Test Suite: gum_choose
# ========================================

@test "gum_choose executes without error with single option" {
    run gum_choose "Select option" "Option 1"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles multiple options" {
    run gum_choose "Select option" "Option 1" "Option 2" "Option 3"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles empty header" {
    run gum_choose "" "Option 1" "Option 2"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles options with special characters" {
    run gum_choose "Select" "Option 1!@#$%" "Option 2&*()"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles options with spaces" {
    run gum_choose "Select" "Option with spaces" "Another option"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles options with quotes" {
    run gum_choose "Select" "Option 'quoted'" 'Option "double"'
    [ "$status" -eq 0 ]
}

@test "gum_choose handles long options" {
    local long_option="This is a very long option text "
    long_option+="that exceeds normal line length and should be handled gracefully."
    run gum_choose "Select" "$long_option"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles many options" {
    run gum_choose "Select" "Opt 1" "Opt 2" "Opt 3" "Opt 4" "Opt 5" "Opt 6"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles options with international characters" {
    run gum_choose "Seleccionar" "Opción 1" "Opción 2"
    [ "$status" -eq 0 ]
}

@test "gum_choose handles options with unicode" {
    run gum_choose "Select" "Option 🎉" "Option ⭐"
    [ "$status" -eq 0 ]
}

# ========================================
# Test Suite: gum_filter
# ========================================

@test "gum_filter executes without error" {
    run gum_filter "Type to filter"
    [ "$status" -eq 0 ]
}

@test "gum_filter handles multi mode" {
    run gum_filter "Type to filter" "true"
    [ "$status" -eq 0 ]
}

@test "gum_filter handles empty placeholder" {
    run gum_filter ""
    [ "$status" -eq 0 ]
}

@test "gum_filter handles placeholder with special characters" {
    run gum_filter "Search: !@#$%^&*()"
    [ "$status" -eq 0 ]
}

@test "gum_filter handles placeholder with international characters" {
    run gum_filter "Buscar"
    [ "$status" -eq 0 ]
}

# ========================================
# Test Suite: gum_write
# ========================================

@test "gum_write executes without error" {
    run gum_write "Enter text"
    [ "$status" -eq 0 ]
}

@test "gum_write handles empty placeholder" {
    run gum_write ""
    [ "$status" -eq 0 ]
}

@test "gum_write handles placeholder with special characters" {
    run gum_write "Write message: !@#$%^&*()"
    [ "$status" -eq 0 ]
}

@test "gum_write handles placeholder with international characters" {
    run gum_write "Escribir mensaje"
    [ "$status" -eq 0 ]
}

@test "gum_write handles placeholder with unicode" {
    run gum_write "Write message 🎉"
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_main_entry_point.bats">
#!/usr/bin/env bats

load '../test_helper.bash'

# Helper to capture main function output
main_entry() {
    export PATH="${MOCK_DIR}:${PATH}"
    # Source ghtools and call main with provided args
    bash -c "source ${PROJECT_DIR}/ghtools && main \"\$@\"" -- "$@"
}

# Test: --help flag displays usage
@test "main shows usage with --help flag" {
    run main_entry --help
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
    [[ "$output" == *"COMMANDS"* ]]
}

# Test: -h flag displays usage
@test "main shows usage with -h flag" {
    run main_entry -h
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
}

# Test: --version flag displays version
@test "main shows version with --version flag" {
    run main_entry --version
    [ "$status" -eq 0 ]
    [[ "$output" == *"3.2.0"* ]]
}

# Test: -v flag displays version
@test "main shows version with -v flag" {
    run main_entry -v
    [ "$status" -eq 0 ]
    [[ "$output" == *"3.2.0"* ]]
}

# Test: --verbose flag enables verbose mode
@test "main accepts --verbose flag" {
    PATH="${MOCK_DIR}:${PATH}"
    VERBOSE=true
    run main_entry list --refresh
    [ "$status" -eq 0 ]
}

# Test: --quiet flag suppresses output
@test "main accepts --quiet flag" {
    PATH="${MOCK_DIR}:${PATH}"
    QUIET=true
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry list
    [ "$status" -eq 0 ]
}

# Test: list command
@test "main handles list command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry list
    [ "$status" -eq 0 ]
}

# Test: list command with --refresh
@test "main handles list --refresh" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"

    run main_entry list --refresh
    [ "$status" -eq 0 ]
}

# Test: list command with --lang filter
@test "main handles list --lang filter" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry list --lang python
    [ "$status" -eq 0 ]
}

# Test: list command with --org filter
@test "main handles list --org filter" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"

    run main_entry list --org testorg
    [ "$status" -eq 0 ]
}

# Test: clone command
@test "main handles clone command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json
    mkdir -p "$TEST_TMP_DIR/clones"

    run main_entry clone --path "$TEST_TMP_DIR/clones"
    [ "$status" -eq 0 ]
}

# Test: sync command
@test "main handles sync command" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry sync --path "$test_dir" --all
    [ "$status" -eq 0 ]
}

# Test: sync command with dry-run
@test "main handles sync --dry-run" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry sync --path "$test_dir" --dry-run --all
    [ "$status" -eq 0 ]
}

# Test: create command (interactive, may fail without terminal)
@test "main handles create command" {
    PATH="${MOCK_DIR}:${PATH}"
    cd "$TEST_TMP_DIR"

    # Mock user inputs
    export GH_CREATE_NAME="test-repo"
    export GH_CREATE_DESC="Test description"
    export GH_CREATE_VIS="private"
    export GH_CREATE_TPL="none"

    # Interactive command - check it starts correctly (shows header)
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main create 2>&1 || true"
    # Should show CREATE header before waiting for input
    [[ "$output" == *"CREATE"* ]] || [[ "$output" == *"Repository"* ]] || [ "$status" -eq 0 ]
}

# Test: delete command (interactive, may fail without terminal)
@test "main handles delete command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Interactive command - check it passes delete_scope check
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main delete 2>&1 || true"
    # Should NOT show "Missing delete_repo scope" error (mock includes scope)
    [[ "$output" != *"Missing 'delete_repo' scope"* ]] || [ "$status" -eq 0 ]
}

# Test: fork command
@test "main handles fork command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry fork "test query"
    [ "$status" -eq 0 ]
}

# Test: fork command with --clone
@test "main handles fork --clone" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry fork --clone "test query"
    [ "$status" -eq 0 ]
}

# Test: archive command (interactive)
@test "main handles archive command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main archive 2>&1 || true"
    [[ "$output" == *"ARCHIVE"* ]] || [[ "$output" == *"archive"* ]] || [ "$status" -eq 0 ]
}

# Test: archive --unarchive command (interactive)
@test "main handles archive --unarchive" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main archive --unarchive 2>&1 || true"
    [[ "$output" == *"UNARCHIVE"* ]] || [[ "$output" == *"archive"* ]] || [ "$status" -eq 0 ]
}

# Test: visibility command (interactive)
@test "main handles visibility command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main visibility 2>&1 || true"
    [[ "$output" == *"VISIBILITY"* ]] || [[ "$output" == *"visibility"* ]] || [ "$status" -eq 0 ]
}

# Test: visibility --public command (interactive)
@test "main handles visibility --public" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main visibility --public 2>&1 || true"
    [[ "$output" == *"PUBLIC"* ]] || [[ "$output" == *"visibility"* ]] || [ "$status" -eq 0 ]
}

# Test: visibility --private command (interactive)
@test "main handles visibility --private" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main visibility --private 2>&1 || true"
    [[ "$output" == *"PRIVATE"* ]] || [[ "$output" == *"visibility"* ]] || [ "$status" -eq 0 ]
}

# Test: stats command
@test "main handles stats command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Stats should work non-interactively
    run timeout 5 bash -c "source ${PROJECT_DIR}/ghtools && main stats 2>&1"
    [[ "$output" == *"STATISTICS"* ]] || [[ "$output" == *"stats"* ]] || [ "$status" -eq 0 ]
}

# Test: search command (interactive)
@test "main handles search command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main search 2>&1 || true"
    [[ "$output" == *"SEARCH"* ]] || [[ "$output" == *"search"* ]] || [ "$status" -eq 0 ]
}

# Test: browse command
@test "main handles browse command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry browse
    [ "$status" -eq 0 ]
}

# Test: explore command (interactive)
@test "main handles explore command" {
    PATH="${MOCK_DIR}:${PATH}"

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main explore 'test query' 2>&1 || true"
    [[ "$output" == *"EXPLORE"* ]] || [[ "$output" == *"explore"* ]] || [[ "$output" == *"Search"* ]] || [ "$status" -eq 0 ]
}

# Test: explore with --sort and --lang (interactive)
@test "main handles explore with options" {
    PATH="${MOCK_DIR}:${PATH}"

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main explore 'test query' --sort stars --lang python 2>&1 || true"
    [[ "$output" == *"EXPLORE"* ]] || [[ "$output" == *"explore"* ]] || [[ "$output" == *"Search"* ]] || [ "$status" -eq 0 ]
}

# Test: trending command (interactive)
@test "main handles trending command" {
    PATH="${MOCK_DIR}:${PATH}"

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main trending 2>&1 || true"
    [[ "$output" == *"TRENDING"* ]] || [[ "$output" == *"trending"* ]] || [ "$status" -eq 0 ]
}

# Test: trending with language (interactive)
@test "main handles trending --lang" {
    PATH="${MOCK_DIR}:${PATH}"

    # Interactive command - check it starts correctly
    run timeout 2 bash -c "source ${PROJECT_DIR}/ghtools && main trending --lang python 2>&1 || true"
    [[ "$output" == *"TRENDING"* ]] || [[ "$output" == *"trending"* ]] || [ "$status" -eq 0 ]
}

# Test: pr command
@test "main handles pr command" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry pr list
    [ "$status" -eq 0 ]
}

# Test: status command
@test "main handles status command" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry status --path "$test_dir"
    [ "$status" -eq 0 ]
}

# Test: config command
@test "main handles config command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry config
    [ "$status" -eq 0 ]
}

# Test: refresh command
@test "main handles refresh command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry refresh
    [ "$status" -eq 0 ]
}

# Test: help command
@test "main handles help command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry help
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
}

# Test: unknown command
@test "main handles unknown command" {
    PATH="${MOCK_DIR}:${PATH}"

    run main_entry unknown-command
    [ "$status" -eq 1 ]
    [[ "$output" == *"Unknown command"* ]]
}

# Test: multiple global flags
@test "main handles multiple global flags" {
    PATH="${MOCK_DIR}:${PATH}"
    export CACHE_FILE="$TEST_CACHE_FILE"
    create_mock_json

    run main_entry --verbose --quiet list
    [ "$status" -eq 0 ]
}

# Test: command with multiple options
@test "main handles sync with multiple options" {
    PATH="${MOCK_DIR}:${PATH}"
    local test_dir="$TEST_TMP_DIR/test_repos"
    mkdir -p "$test_dir/repo1"
    create_test_git_repo "$test_dir/repo1"

    run main_entry sync --path "$test_dir" --dry-run --all --max-depth 2
    [ "$status" -eq 0 ]
}
</file>
<file path="test/unit/test_printing_functions.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# ========================================
# Test Suite: print_error
# ========================================

@test "print_error executes without error" {
    run print_error "Test error message"
    [ "$status" -eq 0 ]
}

@test "print_error executes successfully" {
    run print_error "Test error message"
    [ "$status" -eq 0 ]
}

@test "print_error respects QUIET mode" {
    export QUIET=true
    run print_error "Should not appear"
    [ "$status" -eq 0 ]
}

@test "print_error handles empty message" {
    run print_error ""
    [ "$status" -eq 0 ]
}

@test "print_error handles message with special characters" {
    run print_error "Error: !@#$%^&*()"
    [ "$status" -eq 0 ]
}

@test "print_error handles very long message" {
    local long_msg="This is a very long error message "
    long_msg+="that exceeds normal line length and should be handled gracefully "
    long_msg+="without causing any issues in the printing function."
    run print_error "$long_msg"
    [ "$status" -eq 0 ]
}

@test "print_error handles message with newlines" {
    run print_error -e "Line 1\nLine 2"
    [ "$status" -eq 0 ]
}

@test "print_error handles international characters" {
    run print_error "Erro em português"
    [ "$status" -eq 0 ]
}

# ========================================
# Test Suite: print_success
# ========================================

@test "print_success executes without error" {
    run print_success "Test success message"
    [ "$status" -eq 0 ]
}

@test "print_success executes successfully" {
    run print_success "Test success message"
    [ "$status" -eq 0 ]
}

@test "print_success respects QUIET mode" {
    export QUIET=true
    run print_success "Should not appear"
    [ "$status" -eq 0 ]
}

@test "print_success handles empty message" {
    run print_success ""
    [ "$status" -eq 0 ]
}

@test "print_success handles message with special characters" {
    run print_success "Success: ✓!@#$%^&*()"
    [ "$status" -eq 0 ]
}

@test "print_success handles message with unicode" {
    run print_success "Success with émojis 🎉"
    [ "$status" -eq 0 ]
}

@test "print_success handles very long message" {
    local long_msg="This is a very long success message "
    long_msg+="that exceeds normal line length and should be handled gracefully "
    long_msg+="without causing any issues in the printing function."
    run print_success "$long_msg"
    [ "$status" -eq 0 ]
}

@test "print_success handles message with multiple sentences" {
    run print_success "First sentence. Second sentence. Third sentence."
    [ "$status" -eq 0 ]
}

# ========================================
# Test Suite: print_info
# ========================================

@test "print_info executes without error" {
    run print_info "Test info message"
    [ "$status" -eq 0 ]
}

@test "print_info executes successfully" {
    run print_info "Test info message"
    [ "$status" -eq 0 ]
}

@test "print_info respects QUIET mode" {
    export QUIET=true
    run print_info "Should not appear"
    [ "$status" -eq 0 ]
}

@test "print_info handles empty message" {
    run print_info ""
    [ "$status" -eq 0 ]
}

@test "print_info handles message with special characters" {
    run print_info "Info: <tag> & special"
    [ "$status" -eq 0 ]
}

@test "print_info handles message with newlines" {
    run print_info -e "Line 1\nLine 2"
    [ "$status" -eq 0 ]
}

@test "print_info handles message with tabs and spaces" {
    run print_info "	Tab	 and   Spaces   "
    [ "$status" -eq 0 ]
}

@test "print_info handles international characters" {
    run print_info "Info en español"
    [ "$status" -eq 0 ]
}

# ========================================
# Test Suite: print_warning
# ========================================

@test "print_warning executes without error" {
    run print_warning "Test warning message"
    [ "$status" -eq 0 ]
}

@test "print_warning executes successfully" {
    run print_warning "Test warning message"
    [ "$status" -eq 0 ]
}

@test "print_warning respects QUIET mode" {
    export QUIET=true
    run print_warning "Should not appear"
    [ "$status" -eq 0 ]
}

@test "print_warning handles empty message" {
    run print_warning ""
    [ "$status" -eq 0 ]
}

@test "print_warning handles message with special characters" {
    run print_warning "Warning: !@#$%^&*()"
    [ "$status" -eq 0 ]
}

@test "print_warning handles very long message" {
    local long_msg="This is a very long warning message "
    long_msg+="that exceeds normal line length and should be handled gracefully "
    long_msg+="without causing any issues in the printing function."
    run print_warning "$long_msg"
    [ "$status" -eq 0 ]
}

@test "print_warning handles message with multiple sentences" {
    run print_warning "First sentence. Second sentence. Third sentence."
    [ "$status" -eq 0 ]
}

@test "print_warning handles international characters" {
    run print_warning "Avertissement en français"
    [ "$status" -eq 0 ]
}

</file>
<file path="test/unit/test_utility_functions.bats">
#!/usr/bin/env bats

# Setup test environment
setup() {
    # Get the project directory (three levels up from this test file)
    local test_file="${BATS_TEST_FILENAME}"
    local project_dir
    project_dir="$(dirname "$(dirname "$(dirname "$test_file")")")"

    # Load test helper (this sets up test environment variables and loads ghtools)
    source "$project_dir/test/test_helper.bash"
}

teardown() {
    teardown_test
}

# Test: use_gum function
# Note: use_gum checks for both 'gum' command AND terminal (-t 1)
# In test environment without terminal, this will fail even with mock
@test "use_gum returns false in non-terminal environment" {
    # In tests, we're not in a terminal, so use_gum should return 1
    run use_gum
    # This is expected to fail in test environment (no terminal)
    [ "$status" -eq 1 ]
}

# Test: truncate_text function
@test "truncate_text returns original text when within limit" {
    result=$(truncate_text "short text" 20)
    [ "$result" = "short text" ]
}

@test "truncate_text truncates text when exceeding limit" {
    result=$(truncate_text "this is a very long text that should be truncated" 20)
    [ ${#result} -le 20 ]
    [[ "$result" == *"..."* ]]
}

@test "truncate_text handles empty input" {
    result=$(truncate_text "" 10)
    [ "$result" = "" ]
}

# Test: truncate_text edge case exactly at limit
@test "truncate_text handles text exactly at limit" {
    result=$(truncate_text "exactly ten" 11)
    [ "$result" = "exactly ten" ]
}

# Test: print_table_row function
@test "print_table_row formats output correctly" {
    run print_table_row "Column1" "Column2"
    [ "$status" -eq 0 ]
    [[ "$output" == *"Column1"* ]]
    [[ "$output" == *"Column2"* ]]
}

# Test: wait_for_jobs function
@test "wait_for_jobs runs without error" {
    run wait_for_jobs
    [ "$status" -eq 0 ]
}

# Test: is_cache_valid function
@test "is_cache_valid returns false when cache file doesn't exist" {
    rm -f "$CACHE_FILE"
    run is_cache_valid
    [ "$status" -eq 1 ]
}

@test "is_cache_valid returns false when cache is expired" {
    # Create cache file with old timestamp (year 2020)
    echo '{}' > "$CACHE_FILE"
    touch -t 202001010000 "$CACHE_FILE"
    run is_cache_valid
    [ "$status" -eq 1 ]
}

@test "is_cache_valid returns true when cache is valid" {
    # Create cache file with current timestamp (just touched = fresh)
    echo '{}' > "$CACHE_FILE"
    # touch without -t uses current time, making it fresh
    touch "$CACHE_FILE"
    run is_cache_valid
    [ "$status" -eq 0 ]
}

# Test: check_dependencies function (mock dependencies)
@test "check_dependencies passes with mocked commands" {
    PATH="${MOCK_DIR}:${PATH}"
    run check_dependencies
    [ "$status" -eq 0 ]
}

# Test: check_gh_auth function (mocked)
@test "check_gh_auth passes with mocked gh auth" {
    PATH="${MOCK_DIR}:${PATH}"
    run check_gh_auth
    [ "$status" -eq 0 ]
}

# Test: load_config function
@test "load_config loads valid config without error" {
    mkdir -p "$CONFIG_DIR"
    # Use a valid config variable
    echo 'CACHE_TTL=300' > "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
    run load_config
    [ "$status" -eq 0 ]
}

@test "load_config handles missing config file" {
    rm -f "$CONFIG_FILE"
    run load_config
    [ "$status" -eq 0 ]
}

# Test: init_config function
@test "init_config creates config directory and file" {
    # Remove the config dir that test_helper creates
    rm -rf "$CONFIG_DIR"
    run init_config
    [ "$status" -eq 0 ]
    [ -d "$CONFIG_DIR" ]
    [ -f "$CONFIG_FILE" ]
}

@test "init_config doesn't overwrite existing config" {
    mkdir -p "$CONFIG_DIR"
    echo 'CACHE_TTL=999' > "$CONFIG_FILE"
    original_content=$(cat "$CONFIG_FILE")
    run init_config
    [ "$status" -eq 0 ]
    [ "$(cat "$CONFIG_FILE")" = "$original_content" ]
}

# Test: show_usage function
@test "show_usage outputs usage information" {
    run show_usage
    [ "$status" -eq 0 ]
    [[ "$output" == *"USAGE"* ]]
    [[ "$output" == *"COMMANDS"* ]]
    [[ "$output" == *"OPTIONS"* ]]
}
</file>
<file path="test/bats.config.bash">
#!/usr/bin/env bash

# Bats configuration file
# This file is automatically loaded by bats

# Set timeout for individual tests
export BATS_TEST_TIMEOUT=60

# Enable parallel execution if supported
if command -v parallel &>/dev/null; then
    export BATS_NO_PARALLELIZE_FOREGROUND=
fi

# Load test helper
setup() {
    # This runs before each test file
    load 'test_helper.bash'
}

# Teardown after each test file
teardown() {
    # Clean up any remaining test artifacts
    :
}
</file>
<file path="test/README.md">
# ghtools Test Suite

Esta pasta contém os testes automatizados para o projeto ghtools usando o framework [Bats](https://github.com/bats-core/bats-core).

## Estrutura dos Testes

```
test/
├── README.md                    # Esta documentação
├── test_helper.bash             # Helper functions para os testes
├── bats.config.bash             # Configuração do Bats
├── unit/                        # Testes unitários
│   ├── test_utility_functions.bats
│   ├── test_cache_and_config.bats
│   ├── test_main_entry_point.bats
│   └── test_error_handling.bats
├── integration/                 # Testes de integração
│   └── test_actions.bats
├── helpers/                     # Funções auxiliares (futuro)
└── mocks/                       # Mocks para comandos externos
    ├── gh
    ├── jq
    ├── git
    ├── fzf
    └── gum
```

## Como Executar os Testes

### Execução Completa
```bash
./run_tests.sh
```

### Execução Individual
```bash
# Executar todos os testes
bats test/**/*.bats

# Executar apenas testes unitários
bats test/unit/*.bats

# Executar apenas testes de integração
bats test/integration/*.bats

# Executar um arquivo específico
bats test/unit/test_utility_functions.bats
```

### Execução com verbose
```bash
bats --verbose test/unit/test_utility_functions.bats
```

## Estatísticas dos Testes

**Total de Testes:** 114
**Testes Passando:** 14 (12%)
**Testes Falhando:** 100 (88%)

### Testes Passando (14)
- ✅ truncate_text (5 testes)
- ✅ print_table_row
- ✅ wait_for_jobs
- ✅ is_cache_valid (cache inválido/inexistente - 3 testes)
- ✅ check_dependencies (mocked)
- ✅ check_gh_auth (mocked)
- ✅ load_config (2 testes)
- ✅ init_config (config não sobrescrito)
- ✅ show_usage

### Testes Falhando (100)
Muitos testes falham porque:
1. **Dependências Externas:** Testes que usam comandos como `gh`, `fzf`, `gum` podem falhar sem mocks adequados
2. **Interatividade:** Funções que requerem input do usuário são difíceis de testar automaticamente
3. **Funções com Efeitos Colaterais:** Algumas funções chamam outras funções internamente (ex: `main()`)
4. **Configuração de Ambiente:** Algumas variáveis não são carregadas corretamente no ambiente de teste

## Funções Testadas

### Funções Utilitárias (Unit Tests)
- `truncate_text()` - 100% pass rate
- `print_table_row()` - 100% pass rate
- `wait_for_jobs()` - 100% pass rate
- `is_cache_valid()` - 75% pass rate (3/4)
- `check_dependencies()` - 100% pass rate
- `check_gh_auth()` - 100% pass rate
- `load_config()` - 100% pass rate
- `init_config()` - 50% pass rate (1/2)
- `show_usage()` - 100% pass rate

### Testes de Integração
- `action_list`
- `action_clone`
- `action_sync`
- `action_status`
- `action_stats`
- `action_browse`
- `action_search`
- `action_fork`
- `action_explore`
- `action_trending`
- `action_archive`
- `action_visibility`
- `action_pr`
- `apply_template`

## Cobertura Estimada

**Funções Identificadas no ghtools:** 45+ funções
**Funções Testadas:** 17+ funções
**Cobertura Estimada:** ~38%

⚠️ **Meta de 80% NÃO ATINGIDA**

## Mocks Utilizados

Para testar sem depender de comandos externos, foram criados mocks para:
- `gh` - GitHub CLI
- `jq` - Processador JSON
- `git` - Sistema de controle de versão
- `fzf` - Fuzzy finder
- `gum` - Ferramenta de styling

## Recomendações para Melhorar Cobertura

### 1. Testes de Unitário (Prioridade Alta)
- Adicionar mais testes para funções de printing (`print_error`, `print_success`, etc.)
- Testar configuração de cores e estilos
- Testar parsing de argumentos
- Testar validação de entrada

### 2. Refatoração para Testabilidade (Prioridade Média)
- Separar lógica de UI da lógica de negócio
- Tornar funções mais pure (sem efeitos colaterais)
- Usar injeção de dependência para comandos externos
- Adicionar flags para modo não-interativo (`--yes`, `--no-input`)

### 3. Testes de Integração (Prioridade Média)
- Testar fluxos completos sem interatividade
- Usar mocks mais sofisticados
- Testar cenários de erro (API failures, network timeouts, etc.)

### 4. Melhorias na Infraestrutura (Prioridade Baixa)
- Configurar CI/CD para executar testes automaticamente
- Adicionar mais mocks e stubs
- Criar fixtures para dados de teste
- Implementar teste de performance

## Melhorias Implementadas

1. ✅ Framework de teste configurado (Bats)
2. ✅ Mocks para comandos externos
3. ✅ Helper functions para setup/teardown
4. ✅ Testes básicos para funções utilitárias
5. ✅ Estrutura modular de testes
6. ✅ Script de execução automatizada

## Limitações Atuais

1. **Testes Interativos:** Funções que esperam input do usuário não são facilmente testáveis
2. **Dependências Externas:** Alguns testes requerem que as ferramentas estejam instaladas
3. **Modo de Teste:** O script ghtools não tem um modo especificamente para testes
4. **Estrutura Monolítica:** Script único dificulta testes isolados

## Próximos Passos

1. Refatorar ghtools para separar funções de main()
2. Adicionar modo de teste (`ghtools --test-mode`)
3. Criar mais mocks sophisticated
4. Escrever testes para cenários de erro
5. Melhorar testes de integração
6. Adicionar testes de performance
7. Implementar cobertura real com инструменты como `shcov`

## Requisitos

- bats >= 1.5.0
- bash >= 4.0
- jq (para alguns testes)
- git (para alguns testes)

## Contribuindo

Ao adicionar novas funcionalidades ao ghtools:
1. Adicione testes соответствующие
2. Mantenha a cobertura >= 80%
3. Use mocks para dependências externas
4. Atualize este README

## Licença

Mesma licença do projeto ghtools.
</file>
<file path="test/test_helper.bash">
#!/usr/bin/env bash

# Test helper for ghtools
# This file sets up the test environment

# Get the directory where this script is located
TEST_DIR="$(cd "$(dirname "${BATS_TEST_FILENAME}")" && pwd)"
PROJECT_DIR="$(cd "${TEST_DIR}/../.." && pwd)"

# Enable test mode to prevent auto-execution and strict mode issues
export GHTOOLS_TEST_MODE=1

# Source the ghtools script directly (it now supports being sourced)
source "${PROJECT_DIR}/ghtools"
export -f load_config 2>/dev/null || true
export -f init_config 2>/dev/null || true
export -f use_gum 2>/dev/null || true
export -f gum_style 2>/dev/null || true
export -f print_error 2>/dev/null || true
export -f print_success 2>/dev/null || true
export -f print_info 2>/dev/null || true
export -f print_warning 2>/dev/null || true
export -f print_verbose 2>/dev/null || true
export -f show_header 2>/dev/null || true
export -f show_divider 2>/dev/null || true
export -f run_with_spinner 2>/dev/null || true
export -f gum_confirm 2>/dev/null || true
export -f gum_input 2>/dev/null || true
export -f gum_choose 2>/dev/null || true
export -f gum_filter 2>/dev/null || true
export -f gum_write 2>/dev/null || true
export -f print_table_row 2>/dev/null || true
export -f show_usage 2>/dev/null || true
export -f check_dependencies 2>/dev/null || true
export -f check_gh_auth 2>/dev/null || true
export -f is_cache_valid 2>/dev/null || true
export -f fetch_repositories_json 2>/dev/null || true
export -f wait_for_jobs 2>/dev/null || true
export -f truncate_text 2>/dev/null || true
export -f action_list 2>/dev/null || true
export -f action_clone 2>/dev/null || true
export -f action_sync 2>/dev/null || true
export -f check_delete_scope 2>/dev/null || true
export -f action_delete 2>/dev/null || true
export -f action_create 2>/dev/null || true
export -f apply_template 2>/dev/null || true
export -f action_fork 2>/dev/null || true
export -f action_explore 2>/dev/null || true
export -f action_trending 2>/dev/null || true
export -f action_archive 2>/dev/null || true
export -f action_stats 2>/dev/null || true
export -f action_search 2>/dev/null || true
export -f action_browse 2>/dev/null || true
export -f action_visibility 2>/dev/null || true
export -f action_pr 2>/dev/null || true
export -f action_pr_list 2>/dev/null || true
export -f action_pr_create 2>/dev/null || true
export -f action_status 2>/dev/null || true
export -f show_menu 2>/dev/null || true

# Set up test environment variables
export TEST_MODE=1
export TEST_TMP_DIR="${BATS_TMPDIR:-/tmp}/ghtools_test_$$"
export TEST_CACHE_FILE="${TEST_TMP_DIR}/test_repos.json"
export TEST_CONFIG_DIR="${TEST_TMP_DIR}/config"
export TEST_CONFIG_FILE="${TEST_CONFIG_DIR}/config"

# Override ghtools global variables to use test paths
export CACHE_FILE="$TEST_CACHE_FILE"
export CONFIG_DIR="$TEST_CONFIG_DIR"
export CONFIG_FILE="$TEST_CONFIG_FILE"
export CACHE_TTL=600
export MAX_JOBS=2
export VERBOSE=false
export QUIET=true

# Create test directory
mkdir -p "$TEST_TMP_DIR"
mkdir -p "$TEST_CONFIG_DIR"

# Mock directory for simulating external commands
export MOCK_DIR="${TEST_DIR}/mocks"
mkdir -p "$MOCK_DIR"

# Make mocks executable (if any exist)
if [ -d "$MOCK_DIR" ] && [ "$(ls -A "$MOCK_DIR" 2>/dev/null)" ]; then
    chmod +x "$MOCK_DIR"/*
fi

# Function to create a temporary git repository for testing
create_test_git_repo() {
    local repo_dir="$1"
    mkdir -p "$repo_dir"
    cd "$repo_dir"
    git init -q
    echo "test" > test.txt
    git add test.txt
    git commit -q -m "Initial commit"
}

# Function to create mock JSON response
create_mock_json() {
    cat > "$TEST_CACHE_FILE" <<'EOF'
[
  {
    "name": "test-repo",
    "nameWithOwner": "user/test-repo",
    "description": "A test repository",
    "visibility": "PUBLIC",
    "primaryLanguage": {
      "name": "bash"
    },
    "stargazerCount": 10,
    "forkCount": 2,
    "diskUsage": 100,
    "updatedAt": "2024-01-01T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/test-repo",
    "sshUrl": "git@github.com:user/test-repo.git"
  },
  {
    "name": "private-repo",
    "nameWithOwner": "user/private-repo",
    "description": "A private test repository",
    "visibility": "PRIVATE",
    "primaryLanguage": {
      "name": "python"
    },
    "stargazerCount": 5,
    "forkCount": 1,
    "diskUsage": 200,
    "updatedAt": "2024-01-02T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/private-repo",
    "sshUrl": "git@github.com:user/private-repo.git"
  }
]
EOF
}

# Function to setup mock gh command
setup_mock_gh() {
    cat > "${MOCK_DIR}/gh" <<'MOCK_SCRIPT'
#!/bin/bash
case "$1" in
    "auth")
        if [ "$2" = "status" ]; then
            echo "github.com
  Logged in to github.com as user (oauth_token)
  Git operations done over the http on api.github.com
  Active user: user
  Token scopes: delete_repo, repo, read:org, gist"
            exit 0
        fi
        if [ "$2" = "refresh" ]; then
            # Mock auth refresh
            echo "Auth refreshed"
            exit 0
        fi
        ;;
    "repo")
        case "$2" in
            "list")
                # Check if --json flag is present
                if [[ "$*" == *"--json"* ]]; then
                    # Output mock JSON data
                    cat <<'JSON_DATA'
[
  {
    "name": "test-repo",
    "nameWithOwner": "user/test-repo",
    "description": "A test repository",
    "visibility": "PUBLIC",
    "primaryLanguage": {"name": "bash"},
    "stargazerCount": 10,
    "forkCount": 2,
    "diskUsage": 100,
    "updatedAt": "2024-01-01T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/test-repo",
    "sshUrl": "git@github.com:user/test-repo.git"
  },
  {
    "name": "private-repo",
    "nameWithOwner": "user/private-repo",
    "description": "A private test repository",
    "visibility": "PRIVATE",
    "primaryLanguage": {"name": "python"},
    "stargazerCount": 5,
    "forkCount": 1,
    "diskUsage": 200,
    "updatedAt": "2024-01-02T00:00:00Z",
    "createdAt": "2024-01-01T00:00:00Z",
    "isArchived": false,
    "url": "https://github.com/user/private-repo",
    "sshUrl": "git@github.com:user/private-repo.git"
  }
]
JSON_DATA
                    exit 0
                elif [ "$3" = "--limit" ]; then
                    # Output mock repository data (non-JSON)
                    echo "user/test-repo"
                    echo "user/private-repo"
                fi
                ;;
            "clone")
                echo "Mock clone of $3"
                exit 0
                ;;
            "create")
                echo "Mock create of $3"
                exit 0
                ;;
            "delete")
                echo "Mock delete of $3"
                exit 0
                ;;
            "edit")
                echo "Mock edit of $3"
                exit 0
                ;;
        esac
        ;;
    "search")
        if [ "$1" = "search" ] && [ "$2" = "repos" ]; then
            # Output mock search results
            echo "example/repo1"
            echo "example/repo2"
        fi
        ;;
    "api")
        # Mock API calls
        if [[ "$*" == *"user/starred"* ]]; then
            echo "Mock starred"
            exit 0
        fi
        ;;
esac
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/gh"
}

# Function to setup mock jq command
setup_mock_jq() {
    cat > "${MOCK_DIR}/jq" <<'MOCK_SCRIPT'
#!/bin/bash
# Simple jq mock - just pass through for basic operations
cat
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/jq"
}

# Function to setup mock git command
setup_mock_git() {
    cat > "${MOCK_DIR}/git" <<'MOCK_SCRIPT'
#!/bin/bash
case "$1" in
    "init")
        # Handle git init with or without -q flag
        # git init -q (init in current dir, quiet)
        # git init <dir> (init in specified dir)
        # git init -q <dir> (init in specified dir, quiet)
        local dir=""
        shift  # skip "init"
        while [[ $# -gt 0 ]]; do
            case "$1" in
                -q|--quiet) shift ;;  # ignore quiet flag
                *) dir="$1"; shift ;;
            esac
        done
        # If no dir specified, use current directory
        if [[ -z "$dir" ]]; then
            mkdir -p ".git"
            echo "Initialized empty Git repository in .git/"
        else
            mkdir -p "$dir/.git"
            echo "Initialized empty Git repository in $dir/.git/"
        fi
        exit 0
        ;;
    "add")
        exit 0
        ;;
    "commit")
        echo "[master (root-commit) 1234567] Test commit"
        exit 0
        ;;
    "branch")
        if [ "$1" = "branch" ] && [ "$2" = "--show-current" ]; then
            echo "main"
            exit 0
        fi
        if [ "$1" = "branch" ]; then
            echo "* main"
            exit 0
        fi
        ;;
    "diff-index")
        # Pretend working tree is clean
        exit 0
        ;;
    "fetch")
        exit 0
        ;;
    "pull")
        echo "Already up to date."
        exit 0
        ;;
    "push")
        echo "Everything up-to-date"
        exit 0
        ;;
    "ls-remote")
        # Pretend remote branch exists
        exit 0
        ;;
    "rev-list")
        echo "0"
        exit 0
        ;;
esac
# Default: succeed
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/git"
}

# Function to setup mock fzf command
setup_mock_fzf() {
    cat > "${MOCK_DIR}/fzf" <<'MOCK_SCRIPT'
#!/bin/bash
# Mock fzf - just select first line or echo input
if [ "$*" == *"--multi"* ]; then
    # Multi-select mode - return all lines
    cat
else
    # Single select - return first line
    head -n 1
fi
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/fzf"
}

# Function to setup mock gum command
setup_mock_gum() {
    cat > "${MOCK_DIR}/gum" <<'MOCK_SCRIPT'
#!/bin/bash
# Mock gum - just echo the text or return first line for choose
case "$1" in
    "style")
        # Just output the text
        shift
        echo "$@"
        ;;
    "choose")
        # Return first option
        head -n 1
        ;;
    "input")
        # Return default or echo input
        if [[ "$*" == *"--value"* ]]; then
            # Get default value
            echo "default"
        else
            read -r input
            echo "${input:-default}"
        fi
        ;;
    "confirm")
        # Always return true
        exit 0
        ;;
    "filter")
        # Return input
        head -n 1
        ;;
    "write")
        # Return default text
        echo "Test commit message"
        ;;
    "spin")
        # Execute command and return
        shift
        "$@"
        ;;
esac
exit 0
MOCK_SCRIPT
    chmod +x "${MOCK_DIR}/gum"
}

# Teardown function to clean up after each test
teardown_test() {
    # Clean up test directory
    rm -rf "$TEST_TMP_DIR"
}

# Add MOCK_DIR to PATH for tests
export PATH="${MOCK_DIR}:${PATH}"

# Setup mocks before each test
setup() {
    # Create fresh test environment
    mkdir -p "$TEST_TMP_DIR"
    setup_mock_gh
    setup_mock_jq
    setup_mock_git
    setup_mock_fzf
    setup_mock_gum
}

# Teardown after each test
teardown() {
    teardown_test
}
</file>
<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Architecture
The project is a **Monolithic Bash CLI script** (`ghtools`) acting as an **Orchestrator** for external tools. It uses a Command Dispatcher pattern to route CLI arguments to `action_*` functions. Core data flow involves: `gh` (API) -> `jq` (Transform) -> `fzf`/`gum` (UI/Select).

**Key Components:**
*   `ghtools`: Main executable, handles routing and core logic.
*   `fetch_repositories_json`: Manages the local repository cache (`$CACHE_FILE`).
*   `run_parallel_jobs`: Utility for concurrent execution (e.g., cloning, syncing).
*   `print_*`: Functions for consistent, styled terminal output.

## Build, Test, and Development Commands
The script requires no compilation. Dependencies: `gh`, `jq`, `fzf`, `git`.

| Task | Command | Notes |
| :--- | :--- | :--- |
| **Install** | `bash install.sh` | Copies `ghtools` to `~/scripts` and updates PATH. |
| **Run** | `./ghtools` | Executes the interactive menu. |
| **Lint** | `shellcheck ghtools` | **Required** before any commit. |
| **Test** | `bats test/` | Runs the BATS test suite. |
| **Dry-Run Sync** | `./ghtools sync --dry-run` | Use for safe validation of sync logic. |

## Coding Style & Naming Conventions
*   **Strict Mode**: All scripts must start with `set -euo pipefail`.
*   **Indentation**: Use **4 spaces**.
*   **Naming**: `snake_case` for functions (`action_clone`), `ALL_CAPS` for constants (`MAX_JOBS`, `CACHE_TTL`).
*   **Output**: Use `print_info`, `print_success`, `print_error` helpers for all user-facing messages.
*   **Data**: Use `jq` for all JSON parsing and manipulation of `gh` output.

## Testing Guidelines
Testing is primarily manual and via the BATS suite.
1.  Verify `gh auth status` is successful before testing.
2.  Always test destructive commands (`delete`, `archive`) in a sandbox environment and ensure the `check_delete_scope` and confirmation prompts are working.
3.  Validate parallel operations (`clone`, `sync`) respect the `MAX_JOBS` limit.
4.  Ensure the cache is correctly invalidated (`rm -f $CACHE_FILE`) after write operations.

## Git Workflows
*   **Commit Format**: `Type: concise summary` (e.g., `Feat: Add --lang filter to list command`). Keep subject under 72 chars.
*   **PR Process**: Squash cosmetic commits. Link related issues. Summarize verification steps, including `shellcheck` results and manual command matrix.

## Security & Configuration Notes
*   **Authentication**: Must be handled by `gh auth login`. Sensitive actions require refreshing scopes: `gh auth refresh -s delete_repo`.
*   **Configuration**: Settings are loaded from `~/.config/ghtools/config`. Variables like `CACHE_TTL` and `MAX_JOBS` control runtime behavior.
*   **Safety**: `action_sync` must use `git pull --ff-only` to prevent non-fast-forward merges.
*   **Cache**: The cache file is secured with `umask 077` (permissions 600).
</file>
<file path="CLAUDE.md">
# CLAUDE.md: ghtools Configuration

This repository contains `ghtools`, a single-file Bash CLI script designed to be a unified, interactive manager for GitHub repositories. It acts as an orchestrator, wrapping and enhancing the functionality of the `gh` (GitHub CLI) tool, `git`, and TUI tools like `fzf` and `gum`.

The primary goal is to provide a fast, interactive, and parallelized way to manage large numbers of repositories (list, clone, sync, delete).

## Development Workflow

The project is a pure Bash script and requires no compilation.

| Task | Command | Notes |
| :--- | :--- | :--- |
| **Run** | `./ghtools` | Runs the interactive TUI menu (requires `gum` or falls back to `fzf`). |
| **Direct Run** | `./ghtools list --lang bash` | Executes a specific command. |
| **Install** | `./install.sh` | Copies `ghtools` to `~/scripts` and updates the shell PATH. |
| **Lint** | `shellcheck ghtools` | Essential for catching Bash errors and style issues. |
| **Test** | `bats test/` | The project uses BATS (Bash Automated Testing System) for unit and integration tests. |
| **Refresh Cache** | `./ghtools refresh` | Explicitly clears the repository cache file. |

## Architecture Overview

The architecture is a **Monolithic Script** using a **Command Dispatcher Pattern**.

1.  **Orchestrator Role**: `ghtools` is a facade that simplifies complex operations by orchestrating external tools (`gh`, `jq`, `git`, `fzf`, `gum`).
2.  **Entry Point**: The `main` function handles argument parsing and routes execution to the appropriate `action_*` function.
3.  **Data Flow**: All repository data is sourced from the GitHub API via `gh repo list --json`, processed by `jq`, and then cached locally.
4.  **Parallelism**: Bulk operations (`clone`, `sync`) use the `run_parallel_jobs` utility, which leverages `xargs -P $MAX_JOBS` to limit concurrent processes (default 5).
5.  **UI Abstraction**: Output is routed through `print_*` functions, which conditionally use the `gum` TUI library for modern styling, falling back to standard ANSI colors if `gum` is unavailable.

## Core Components and Data Management

### 1. Action Handlers (`action_*`)
These functions encapsulate the business logic for each command:
*   `action_list`: Fetches, filters, and formats repository data.
*   `action_clone`: Interactively selects repos and runs `git clone` in parallel.
*   `action_sync`: Scans local repos, checks status, and runs `git pull --ff-only` in parallel.
*   `action_delete`: Requires `delete_repo` scope check and explicit confirmation.

### 2. Data Retrieval and Caching
*   **Function**: `fetch_repositories_json`
*   **Mechanism**: Implements a Cache-Aside pattern. It checks the timestamp of `$CACHE_FILE` (default: `/tmp/ghtools_repos_UID.json`) against `CACHE_TTL` (default: 600s).
*   **Data Contract**: The function ensures the data is a JSON array of repository objects, which is then consumed by `jq` for all subsequent filtering and formatting.
*   **Invalidation**: The cache is explicitly deleted (`rm -f "$CACHE_FILE"`) after any write operation (`create`, `delete`, `archive`) to ensure data freshness.

### 3. Configuration
*   Configuration is loaded from `$CONFIG_FILE` (default: `~/.config/ghtools/config`) via the `source` command.
*   Key variables: `CACHE_TTL`, `MAX_JOBS`, `DEFAULT_ORG`, `DEFAULT_CLONE_PATH`.

## Code Style and Conventions

### Bash Safety
*   **Strict Mode**: Always use `set -euo pipefail` at the top of the script and new functions to ensure robust error handling and prevent use of unset variables.
*   **Indentation**: Use **2 spaces** for indentation.
*   **Naming**: Use `snake_case` for functions (`check_dependencies`) and `ALL_CAPS` for global constants (`CACHE_TTL`, `VERBOSE`).

### Output and Logging
*   All user-facing output must use the provided helper functions for consistent styling:
    *   `print_info`, `print_success`, `print_warning`, `print_error`.
*   Use `print_verbose` for debugging output, which is only shown when the `-V` flag is set.

### Git Safety
*   The `action_sync` function must use `git pull --ff-only` to ensure non-fast-forward merges are prevented, maintaining a clean history.
*   `action_pr_create` includes checks for dirty working directories and detached HEAD state before proceeding.

## Development Gotchas and Warnings

1.  **External Tool Fragility**: The script is highly coupled to the exact command-line interfaces and JSON output formats of `gh` and `jq`. If these tools change their output, core functions like `get_all_repos` will break. Be cautious when updating dependency versions.
2.  **Configuration Security**: The `load_config` function uses `source`. While it includes a `grep` check to prevent arbitrary code execution, this is a potential security risk. **Do not introduce new ways to source external files.**
3.  **Authentication Scopes**: Destructive actions (`action_delete`) require the `delete_repo` OAuth scope. Always verify this using `check_delete_scope` and prompt the user to run `gh auth refresh -s delete_repo` if needed.
4.  **TUI Dependency**: The enhanced user experience relies on `gum`. When debugging UI issues, remember to test the fallback path (without `gum`) which uses `fzf` and standard ANSI colors.
</file>
<file path="ghtools">
#!/bin/bash

# ghtools - Unified GitHub repository management tool (Refactored)
# Version: 3.1.0
# Requires: gh (GitHub CLI), gum, fzf, jq, git

set -euo pipefail

# --- Version ---
VERSION="3.2.0"

# --- Default Configuration ---
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ghtools"
CONFIG_FILE="$CONFIG_DIR/config"
# Include user ID in cache filename for multi-user support
CACHE_FILE="/tmp/ghtools_repos_$(id -u).json"
CACHE_TTL=600     # 10 minutes (in seconds)
MAX_JOBS=5        # Parallel jobs for sync/clone
VERBOSE=false
QUIET=false

# --- Load User Config ---
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Security: Validate config file contains only allowed variable assignments
        local allowed_vars="CACHE_TTL|CACHE_FILE|MAX_JOBS|DEFAULT_ORG|DEFAULT_CLONE_PATH"
        # Check for lines that are not: empty, comments, or allowed variable assignments
        if grep -Evq "^[[:space:]]*(#.*)?$|^[[:space:]]*($allowed_vars)=" "$CONFIG_FILE"; then
            # Config contains potentially dangerous content - show warning and skip
            echo -e "\033[1;33m[WARNING]\033[0m Config file contains invalid lines. Skipping: $CONFIG_FILE" >&2
            echo -e "\033[1;33m[WARNING]\033[0m Allowed variables: CACHE_TTL, CACHE_FILE, MAX_JOBS, DEFAULT_ORG, DEFAULT_CLONE_PATH" >&2
            return 1
        fi
        # Check permissions (should be 600 or 644)
        local perms
        perms=$(stat -c %a "$CONFIG_FILE" 2>/dev/null || stat -f %Lp "$CONFIG_FILE" 2>/dev/null)
        if [[ "$perms" =~ [0-7][2367][0-7] ]]; then
            echo -e "\033[1;33m[WARNING]\033[0m Config file is world/group writable. Fix: chmod 600 $CONFIG_FILE" >&2
        fi
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

# Create default config if not exists
init_config() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" <<'EOF'
# ghtools configuration file
# Uncomment and modify as needed

# Cache settings
#CACHE_TTL=600        # Cache time-to-live in seconds (default: 600)
#CACHE_FILE="/tmp/ghtools_repos_UID.json"  # UID is auto-appended for multi-user support

# Parallel jobs for sync/clone operations
#MAX_JOBS=5

# Default organization filter (leave empty for all)
#DEFAULT_ORG=""

# Default clone path (leave empty for current directory)
#DEFAULT_CLONE_PATH=""
EOF
        print_info "Created default config at $CONFIG_FILE"
    fi
}

load_config

# --- Color Scheme (Modern Purple/Cyan Theme) ---
# Primary colors
COLOR_PRIMARY="99"      # Soft purple
COLOR_SECONDARY="39"    # Cyan
COLOR_ACCENT="212"      # Pink
COLOR_SUCCESS="78"      # Green
COLOR_WARNING="220"     # Yellow/Gold
COLOR_ERROR="196"       # Red
COLOR_INFO="75"         # Light blue
COLOR_MUTED="240"       # Gray

# Legacy colors for compatibility
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Gum Style Helpers ---

# Check if gum is available and terminal supports it
use_gum() {
  command -v gum &>/dev/null && [[ -t 1 ]]
}

# Styled text output
gum_style() {
  local text="$1"
  local fg="${2:-$COLOR_PRIMARY}"
  local bold="${3:-false}"

  if use_gum; then
    if [[ "$bold" == "true" ]]; then
      gum style --foreground "$fg" --bold "$text"
    else
      gum style --foreground "$fg" "$text"
    fi
  else
    echo "$text"
  fi
}

# --- Utility Functions ---

print_error() {
  if use_gum && [[ "$QUIET" != "true" ]]; then
    gum style --foreground "$COLOR_ERROR" --bold "✗ ERROR" | tr -d '\n'
    echo " $1" >&2
  else
    echo -e "${RED}[ERROR]${NC} $1" >&2
  fi
}

print_success() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_SUCCESS" --bold "✓ SUCCESS" | tr -d '\n'
    echo " $1"
  else
    echo -e "${GREEN}[SUCCESS]${NC} $1"
  fi
}

print_info() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_INFO" "ℹ INFO" | tr -d '\n'
    echo " $1"
  else
    echo -e "${BLUE}[INFO]${NC} $1"
  fi
}

print_warning() {
  [[ "$QUIET" == "true" ]] && return
  if use_gum; then
    gum style --foreground "$COLOR_WARNING" --bold "⚠ WARNING" | tr -d '\n'
    echo " $1"
  else
    echo -e "${YELLOW}[WARNING]${NC} $1"
  fi
}

print_verbose() {
  [[ "$VERBOSE" != "true" ]] && return 0
  if use_gum; then
    gum style --foreground "$COLOR_MUTED" "◦ DEBUG" | tr -d '\n'
    echo " $1"
  else
    echo -e "${CYAN}[DEBUG]${NC} $1"
  fi
}

# Beautiful header/banner
show_header() {
  local title="$1"
  local subtitle="${2:-}"

  if use_gum; then
    echo ""
    if [[ -n "$subtitle" ]]; then
      gum style \
        --border rounded \
        --border-foreground "$COLOR_PRIMARY" \
        --foreground "$COLOR_SECONDARY" \
        --align center \
        --width 60 \
        --padding "1 2" \
        --margin "0 2" \
        "$title" "$subtitle"
    else
      gum style \
        --border rounded \
        --border-foreground "$COLOR_PRIMARY" \
        --foreground "$COLOR_SECONDARY" \
        --align center \
        --width 60 \
        --padding "1 2" \
        --margin "0 2" \
        "$title"
    fi
    echo ""
  else
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}                    $title${NC}"
    [[ -n "$subtitle" ]] && echo -e "${CYAN}                    $subtitle${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
  fi
}

# Section divider
show_divider() {
  local title="${1:-}"
  if use_gum; then
    if [[ -n "$title" ]]; then
      gum style --foreground "$COLOR_MUTED" --bold "─── $title ───"
    else
      gum style --foreground "$COLOR_MUTED" "────────────────────────────────────────"
    fi
  else
    if [[ -n "$title" ]]; then
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
      echo -e "${CYAN}                      $title${NC}"
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
    else
      echo -e "${CYAN}─────────────────────────────────────────────────────────────────${NC}"
    fi
  fi
}

# Spinner for long operations
# Usage: run_with_spinner "Title" command arg1 arg2 ...
run_with_spinner() {
  local title="$1"
  shift
  # Execute directly the command passed as separate arguments (no eval)

  if use_gum; then
    gum spin --spinner dot --spinner.foreground "$COLOR_ACCENT" --title "$title" -- "$@"
  else
    echo -n "$title... "
    if "$@"; then
      echo "done"
    else
      echo "failed"
      return 1
    fi
  fi
}

# Interactive confirmation
gum_confirm() {
  local prompt="$1"
  local default="${2:-no}"

  if use_gum; then
    if [[ "$default" == "yes" ]]; then
      gum confirm --affirmative "Yes" --negative "No" --default=true \
        --prompt.foreground "$COLOR_WARNING" "$prompt"
    else
      gum confirm --affirmative "Yes" --negative "No" --default=false \
        --prompt.foreground "$COLOR_WARNING" "$prompt"
    fi
  else
    local response
    read -p "$prompt [y/N]: " response
    [[ "$response" =~ ^[Yy]$ ]]
  fi
}

# Interactive input
gum_input() {
  local placeholder="$1"
  local prompt="${2:-› }"
  local default="${3:-}"

  if use_gum; then
    gum input --placeholder "$placeholder" \
      --prompt "$prompt" \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT" \
      --value "$default"
  else
    local response
    read -p "$prompt$placeholder: " response
    echo "${response:-$default}"
  fi
}

# Interactive choice
gum_choose() {
  local header="$1"
  shift
  local options=("$@")

  if use_gum; then
    printf '%s\n' "${options[@]}" | gum choose \
      --header "$header" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY"
  else
    printf '%s\n' "${options[@]}" | fzf --header="$header" --height=40%
  fi
}

# Interactive filter (fuzzy search)
gum_filter() {
  local placeholder="$1"
  local multi="${2:-false}"

  if use_gum; then
    local args=(
      --placeholder "$placeholder"
      --prompt "› "
      --prompt.foreground "$COLOR_PRIMARY"
      --cursor.foreground "$COLOR_ACCENT"
      --match.foreground "$COLOR_SUCCESS"
      --indicator "›"
      --indicator.foreground "$COLOR_ACCENT"
    )
    [[ "$multi" == "true" ]] && args+=(--no-limit)
    gum filter "${args[@]}"
  else
    local fzf_args=(--height=50% --border)
    [[ "$multi" == "true" ]] && fzf_args+=(--multi)
    fzf "${fzf_args[@]}" --header="$placeholder"
  fi
}

# Write/text area input
gum_write() {
  local placeholder="$1"

  if use_gum; then
    gum write --placeholder "$placeholder" \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --char-limit 0
  else
    local text
    echo "$placeholder (Ctrl+D to finish):"
    text=$(cat)
    echo "$text"
  fi
}

# Table-like output row
print_table_row() {
  local col1="$1"
  local col2="$2"
  local col1_width="${3:-30}"
  local col1_color="${4:-$COLOR_SECONDARY}"

  if use_gum; then
    local styled_col1
    styled_col1=$(gum style --foreground "$col1_color" "$(printf "%-${col1_width}s" "$col1")")
    echo "$styled_col1 $col2"
  else
    printf "%b%-${col1_width}s%b %s\n" "$CYAN" "$col1" "$NC" "$col2"
  fi
}

show_usage() {
    cat <<EOF
${GREEN}ghtools${NC} - Unified GitHub repository management tool

${YELLOW}USAGE:${NC}
    ghtools [OPTIONS] <COMMAND> [ARGS]

${YELLOW}COMMANDS:${NC}
    ${GREEN}Repository Management:${NC}
    list [--refresh] [--lang <lang>] [--org <org>]
                        List repositories with optional filters
    clone [--path <dir>]
                        Clone repositories interactively
    create              Create a new repository
    delete              Delete repositories interactively
    fork [--clone] <query>
                        Fork external repositories
    archive [--unarchive]
                        Archive or unarchive repositories
    visibility [--public|--private]
                        Change repository visibility

    ${GREEN}Local Repository Operations:${NC}
    sync [--path <dir>] [--dry-run] [--all] [--max-depth <n>]
                        Sync local repositories with remote
    status [--path <dir>]
                        Show status of local repositories

    ${GREEN}Discovery & Navigation:${NC}
    search              Interactive fuzzy search with actions
    browse              Open repositories in browser
    stats               Show repository statistics dashboard
    explore [--sort <s>] [--lang <l>] <query>
                        Search external GitHub repositories
    trending [--lang <l>]
                        Show trending repositories

    ${GREEN}Pull Requests:${NC}
    pr list             List PRs for a repository
    pr create           Create PR from current branch

    ${GREEN}Utilities:${NC}
    refresh             Clear the repository cache
    config              Initialize/show config file location
    help                Show this help message

${YELLOW}OPTIONS:${NC}
    -h, --help          Show this help message
    -v, --version       Show version
    -V, --verbose       Enable verbose output
    -q, --quiet         Suppress non-error output

${YELLOW}EXAMPLES:${NC}
    ghtools list --lang python --org myorg
    ghtools clone --path ~/projects
    ghtools sync --dry-run --all
    ghtools fork --clone "react hooks"
    ghtools archive --unarchive
    ghtools visibility --private
    ghtools status --path ~/dev
    ghtools pr create
    ghtools explore "machine learning" --lang python
    ghtools trending --lang rust

${YELLOW}CONFIG:${NC}
    Config file: \$XDG_CONFIG_HOME/ghtools/config (or ~/.config/ghtools/config)

EOF
}

check_dependencies() {
  local missing_deps=()
  local optional_deps=()

  # Required dependencies
  for cmd in gh fzf git jq; do
    if ! command -v "$cmd" &>/dev/null; then
      missing_deps+=("$cmd")
    fi
  done

  # Optional but recommended (gum for beautiful UI)
  if ! command -v gum &>/dev/null; then
    optional_deps+=("gum")
  fi

  if [ ${#missing_deps[@]} -ne 0 ]; then
    print_error "Missing required dependencies:"
    printf "  - %s\n" "${missing_deps[@]}"
    echo ""
    echo "Install via Arch Linux:"
    echo "  sudo pacman -S github-cli fzf git jq gum"
    exit 1
  fi

  if [ ${#optional_deps[@]} -ne 0 ]; then
    print_warning "Optional dependencies missing (for enhanced UI):"
    printf "  - %s\n" "${optional_deps[@]}"
    echo ""
    echo "Install for beautiful UI: sudo pacman -S gum"
    echo ""
  fi
}

check_gh_auth() {
  if ! gh auth status &>/dev/null; then
    print_error "Not authenticated with GitHub CLI. Run: gh auth login"
    exit 1
  fi
}

# --- Caching Mechanism ---

is_cache_valid() {
  if [ -f "$CACHE_FILE" ]; then
    local file_time current_time age
    file_time=$(date -r "$CACHE_FILE" +%s)
    current_time=$(date +%s)
    age=$((current_time - file_time))
    if [ "$age" -lt "$CACHE_TTL" ]; then
      return 0
    fi
  fi
  return 1
}

fetch_repositories_json() {
  local force_refresh="${1:-false}"
  local limit="${2:-1000}"
  local org_filter="${3:-${DEFAULT_ORG:-}}"
  local fields="name,nameWithOwner,description,visibility,primaryLanguage,stargazerCount,forkCount,diskUsage,updatedAt,createdAt,isArchived,url,sshUrl"

  # Build command as array (avoid eval/word splitting issues)
  local cmd_args=("gh" "repo" "list")
  if [ -n "$org_filter" ]; then
    cmd_args+=("$org_filter")
    print_verbose "Filtering by organization: $org_filter"
  fi

  if [ "$force_refresh" = "true" ] || ! is_cache_valid; then
    print_info "Fetching repositories from GitHub API..." >&2
    local error_output
    error_output=$(mktemp)

    # Use umask 077 to ensure cache file has secure permissions (600)
    if ! (umask 077 && "${cmd_args[@]}" --limit "$limit" --json "$fields" >"$CACHE_FILE") 2>"$error_output"; then
      print_error "Failed to fetch repositories."
      if [ -s "$error_output" ]; then
        print_error "Details: $(cat "$error_output")"
      fi
      rm -f "$error_output"
      exit 1
    fi
    rm -f "$error_output"
    print_verbose "Fetched $(jq length "$CACHE_FILE") repositories"
  else
    print_info "Using cached repository list ($(date -r "$CACHE_FILE" '+%H:%M:%S'))" >&2
  fi

  cat "$CACHE_FILE"
}

# --- Helper Functions ---

# Job control for parallelism
wait_for_jobs() {
  local current_jobs
  current_jobs=$(jobs -p | wc -l)
  if [ "$current_jobs" -ge "$MAX_JOBS" ]; then
    # Use wait -n (Bash 4.3+), fallback to wait for older versions
    wait -n 2>/dev/null || wait
  fi
}

truncate_text() {
  local input="$1"
  local max="$2"
  if [ "${#input}" -gt "$max" ]; then
    echo "${input:0:$((max - 3))}..."
  else
    echo "$input"
  fi
}

# --- Action: List ---

action_list() {
  local refresh="false"
  local filter_lang=""
  local filter_org=""

  # Simple args parsing for list
  while [[ $# -gt 0 ]]; do
    case $1 in
    --refresh)
      refresh="true"
      shift
      ;;
    --lang)
      filter_lang="$2"
      shift 2
      ;;
    --org)
      filter_org="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "$refresh" "1000" "$filter_org")

  # Filter by language if requested
  if [ -n "$filter_lang" ]; then
    json=$(echo "$json" | jq --arg lang "$filter_lang" '[.[] | select(.primaryLanguage.name != null and (.primaryLanguage.name | ascii_downcase) == ($lang | ascii_downcase))]')
  fi

  # Output Table using pure JQ + printf (Faster/Cleaner)
  echo ""
  printf "%b%-30s %-40s %-10s %-10s %-15s%b\n" "$CYAN" "NAME" "DESCRIPTION" "VISIBILITY" "LANG" "UPDATED" "$NC"
  printf "%b%s%b\n" "$CYAN" "$(printf '%*s' 110 '' | tr ' ' '-')" "$NC"

  echo "$json" | jq -r '.[] | [.nameWithOwner, (.description // "No description"), .visibility, (.primaryLanguage.name // "-"), .updatedAt] | @tsv' |
    while IFS=$'\t' read -r name desc vis lang updated; do
      local d_name=$(truncate_text "$name" 30)
      local d_desc=$(truncate_text "$desc" 40)
      local d_updated=$(date -d "$updated" '+%Y-%m-%d' 2>/dev/null || echo "$updated")

      local color="$NC"
      [[ "$vis" == "PUBLIC" ]] && color="$GREEN"
      [[ "$vis" == "PRIVATE" ]] && color="$YELLOW"

      printf "%b%-30s%b %-40s %b%-10s%b %-10s %-15s\n" \
        "$BLUE" "$d_name" "$NC" "$d_desc" "$color" "$vis" "$NC" "$lang" "$d_updated"
    done
  echo ""
}

# --- Action: Clone ---

action_clone() {
  local clone_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      clone_path="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  # Validate clone path
  if [ ! -d "$clone_path" ]; then
    print_error "Clone path does not exist: $clone_path"
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  print_info "Select repositories to CLONE (TAB to multi-select):"
  print_info "Clone destination: $clone_path"

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="TAB: select | ENTER: confirm | Dest: $clone_path" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  echo ""
  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  local total=${#repos[@]}
  local current=0
  print_info "Cloning $total repositories in parallel ($MAX_JOBS threads)..."

  for repo in "${repos[@]}"; do
    wait_for_jobs
    (
      local repo_name
      repo_name=$(basename "$repo")
      local target_dir="$clone_path/$repo_name"
      
      if [ -d "$target_dir" ]; then
        print_warning "Skipped $repo (Directory exists)"
      else
        print_verbose "Cloning $repo to $target_dir"
        if gh repo clone "$repo" "$target_dir" &>/dev/null; then
          print_success "Cloned: $repo"
        else
          print_error "Failed: $repo"
        fi
      fi
    ) &
    ((current++)) || true
    # Progress indicator
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories queued..." "$current" "$total" >&2
  done
  wait
  echo "" >&2
  print_success "All clone operations completed."
}

# --- Action: Sync ---

action_sync() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local dry_run=false
  local sync_all=false
  local max_depth=3

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    --all)
      sync_all=true
      shift
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *)
      # Legacy: first positional arg is path
      if [ -d "$1" ]; then
        base_path="$1"
      fi
      shift
      ;;
    esac
  done

  print_info "Scanning for git repositories in $base_path..."
  print_verbose "Max depth: $max_depth, Dry run: $dry_run, Sync all: $sync_all"

  # Find git dirs
  local git_dirs
  # Use -print0 and xargs -0 to handle paths with spaces correctly
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune -print0 2>/dev/null | xargs -0 -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found."
    return
  fi

  print_info "Found ${#git_dirs[@]} repositories"

  local selected_paths
  if [ "$sync_all" = "true" ]; then
    # Non-interactive: sync all found repos
    selected_paths=$(printf "%s\n" "${git_dirs[@]}")
  else
    # Interactive selection
    selected_paths=$(printf "%s\n" "${git_dirs[@]}" |
      fzf --multi --height=40% --border --header="Select repos to SYNC (--all to skip)" --prompt="Repos > ")
  fi

  [ -z "$selected_paths" ] && return

  local total
  total=$(echo "$selected_paths" | wc -l)
  local current=0

  print_info "Syncing $total repositories in parallel..."
  [ "$dry_run" = "true" ] && print_warning "DRY-RUN mode: no changes will be made"

  while IFS= read -r repo_path; do
    wait_for_jobs
    (
      repo_name=$(basename "$repo_path")
      
      # Check for dirty state
      if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "Skipped $repo_name (Dirty state)"
        exit 0
      fi

      if [ "$dry_run" = "true" ]; then
        # Dry run: just fetch and show what would happen
        git -C "$repo_path" fetch --quiet 2>/dev/null || true
        local behind
        behind=$(git -C "$repo_path" rev-list HEAD..@{u} --count 2>/dev/null || echo "0")
        if [ "$behind" -gt 0 ]; then
          print_info "[DRY-RUN] Would pull $behind commits: $repo_name"
        else
          echo -e "${CYAN}[DRY-RUN]${NC} Already up to date: $repo_name"
        fi
      else
        # Actual sync
        if output=$(git -C "$repo_path" pull --ff-only 2>&1); then
          if [[ "$output" == *"Already up to date"* ]]; then
            echo -e "${CYAN}[NO CHANGE]${NC} $repo_name"
          else
            print_success "Synced: $repo_name"
          fi
        else
          print_error "Failed: $repo_name (Conflict or Diverged)"
        fi
      fi
    ) &
    ((current++)) || true
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories processing..." "$current" "$total" >&2
  done <<<"$selected_paths"

  wait
  echo "" >&2
  print_success "Sync completed."
}

# --- Action: Delete ---

check_delete_scope() {
  if ! gh auth status 2>&1 | grep -q "delete_repo"; then
    print_error "Missing 'delete_repo' scope required for repository deletion."
    echo ""
    read -p "Would you like to refresh auth with delete_repo scope? [y/N]: " response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      print_info "Running: gh auth refresh -s delete_repo"
      if gh auth refresh -s delete_repo; then
        print_success "Auth scope updated successfully."
        return 0
      else
        print_error "Failed to update auth scope."
        return 1
      fi
    else
      print_warning "Cannot proceed without delete_repo scope."
      return 1
    fi
  fi
  return 0
}

action_delete() {
  check_dependencies

  # Check delete scope - block if not available
  if ! check_delete_scope; then
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --multi --height=40% --border --header="SELECT REPOS TO DELETE (NO UNDO)" --color='pointer:red,marker:red,header:red')

  [ -z "$selected" ] && return

  local repos=()
  while read -r repo; do repos+=("$repo"); done <<<"$selected"

  echo ""
  print_warning "You are about to delete ${#repos[@]} repositories:"
  printf "  - ${RED}%s${NC}\n" "${repos[@]}"
  echo ""

  read -p "Type 'DELETE' to confirm, or anything else for Dry Run: " confirm
  local dry_run=true
  if [ "$confirm" == "DELETE" ]; then
    dry_run=false
  fi

  for repo in "${repos[@]}"; do
    if [ "$dry_run" = "true" ]; then
      print_info "[DRY-RUN] Would delete: $repo"
    else
      echo -e "${RED}[DELETING]${NC} $repo"
      if gh repo delete "$repo" --yes; then
        print_success "Deleted: $repo"
      else
        print_error "Failed to delete: $repo"
      fi
    fi
  done

  if [ "$dry_run" != "true" ]; then
    rm -f "$CACHE_FILE"
    print_info "Cache cleared (repo deleted)"
  fi
}

# --- Action: Create (Simplified) ---

action_create() {
  show_header "CREATE REPOSITORY" "Set up a new GitHub repository"

  # Get repository name
  local name
  if use_gum; then
    name=$(gum input --placeholder "Repository name" \
      --prompt "› " \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT")
  else
    read -p "Repository Name: " name
  fi

  if [ -z "$name" ]; then
    print_error "Name required"
    return
  fi

  # Get description
  local desc
  if use_gum; then
    desc=$(gum input --placeholder "Description (optional)" \
      --prompt "› " \
      --prompt.foreground "$COLOR_PRIMARY" \
      --cursor.foreground "$COLOR_ACCENT")
  else
    read -p "Description: " desc
  fi

  # Select visibility
  local vis
  if use_gum; then
    vis=$(gum choose --header "Visibility:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      "public" "private")
  else
    vis=$(echo -e "public\nprivate" | fzf --height=10% --prompt="Visibility > ")
  fi
  [ -z "$vis" ] && vis="private"

  # Select template
  local tpl
  if use_gum; then
    tpl=$(gum choose --header "Template:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      "none" "python" "node" "go")
  else
    tpl=$(echo -e "none\npython\nnode\ngo" | fzf --height=15% --prompt="Template > ")
  fi

  # Confirm creation
  echo ""
  if use_gum; then
    gum style --border rounded --border-foreground "$COLOR_SECONDARY" --padding "1 2" \
      "Repository: $name" "Visibility: $vis" "Template: ${tpl:-none}"
    echo ""
  fi

  local cmd_args=("gh" "repo" "create" "$name" "--$vis")
  if [ -n "$desc" ]; then
    cmd_args+=("--description" "$desc")
  fi

  # Create with clone
  print_info "Creating repository..."
  if "${cmd_args[@]}" --clone; then
    print_success "Repository created: $name"
    if [ "$tpl" != "none" ] && [ -d "$name" ]; then
      print_info "Applying template: $tpl"
      apply_template "$name" "$tpl"
      # Commit template locally
      (cd "$name" && git add . && git commit -m "Initial commit (Template: $tpl)") &>/dev/null
      # Ask before pushing
      if gum_confirm "Push initial commit to origin?" "yes"; then
        (cd "$name" && git push origin HEAD) &>/dev/null
        print_success "Template applied and pushed"
      else
        print_success "Template applied (not pushed). Push manually with: cd $name && git push"
      fi
    fi
  else
    print_error "Failed to create repository."
  fi
}

# --- Templates Logic ---

apply_template() {
  local dir="$1"
  local lang="$2"

  case "$lang" in
  python)
    echo "# $dir" >"$dir/README.md"
    touch "$dir/__init__.py"
    echo -e "def main():\n    print('Hello Python')\n\nif __name__ == '__main__':\n    main()" >"$dir/main.py"
    echo "git filtering..."
    cat <<EOT >"$dir/.gitignore"
__pycache__/
*.py[cod]
.venv/
EOT
    ;;
  node)
    echo "# $dir" >"$dir/README.md"
    echo "console.log('Hello Node');" >"$dir/index.js"
    cat <<EOT >"$dir/package.json"
{
  "name": "$dir",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT"
}
EOT
    cat <<EOT >"$dir/.gitignore"
node_modules/
.env
EOT
    ;;
  go)
    echo "# $dir" >"$dir/README.md"
    cat <<EOT >"$dir/main.go"
package main
import "fmt"
func main() {
    fmt.Println("Hello Go")
}
EOT
    (cd "$dir" && go mod init "github.com/$(gh api user -q .login)/$dir" 2>/dev/null || true)
    ;;
  esac
  print_info "Applied $lang template."
}

# --- Action: Fork ---

action_fork() {
  local search_query=""
  local clone_after=false

  while [[ $# -gt 0 ]]; do
    case $1 in
    --clone)
      clone_after=true
      shift
      ;;
    *)
      search_query="$1"
      shift
      ;;
    esac
  done

  if [ -z "$search_query" ]; then
    read -p "Search for repository to fork: " search_query
    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi
  fi

  print_info "Searching GitHub for '$search_query'..."

  local results
  results=$(gh search repos "$search_query" --limit 50 --json fullName,description,stargazersCount,language \
    2>/dev/null | jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=50% --border \
    --header="Select repository to FORK (TAB for multi)" \
    --delimiter='\t' --with-nth=1,2,3 --multi \
    --preview="echo {4}" --preview-window=down:2:wrap)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _ _ _; do
    print_info "Forking $repo..."
    if gh repo fork "$repo" --clone="$clone_after" 2>/dev/null; then
      print_success "Forked: $repo"
      if [ "$clone_after" = "true" ]; then
        print_success "Cloned to: $(basename "$repo")"
      fi
    else
      print_error "Failed to fork: $repo"
    fi
  done <<<"$selected"
}

# --- Action: Explore (External Search) ---

action_explore() {
  local search_query=""
  local sort_by="stars"
  local language=""
  local limit=100

  while [[ $# -gt 0 ]]; do
    case $1 in
    --sort)
      sort_by="$2"
      shift 2
      ;;
    --lang)
      language="$2"
      shift 2
      ;;
    --limit)
      limit="$2"
      shift 2
      ;;
    *)
      search_query="$search_query $1"
      shift
      ;;
    esac
  done

  search_query=$(echo "$search_query" | xargs) # trim

  if [ -z "$search_query" ]; then
    show_header "EXPLORE GITHUB" "Search repositories worldwide"

    # Get search query
    if use_gum; then
      search_query=$(gum input --placeholder "Search query (e.g., 'machine learning')" \
        --prompt "› " \
        --prompt.foreground "$COLOR_PRIMARY" \
        --cursor.foreground "$COLOR_ACCENT")
    else
      read -p "Search query: " search_query
    fi

    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi

    # Get sort option
    if use_gum; then
      local sort_choice
      sort_choice=$(gum choose --header "Sort by:" \
        --cursor "› " \
        --cursor.foreground "$COLOR_ACCENT" \
        --header.foreground "$COLOR_PRIMARY" \
        "stars" "forks" "updated" "help-wanted-issues")
      sort_by="${sort_choice:-stars}"
    else
      echo ""
      echo "Sort by: (s)tars | (f)orks | (u)pdated | (h)elp-wanted"
      read -p "Sort [stars]: " sort_choice
      case "$sort_choice" in
      f) sort_by="forks" ;;
      u) sort_by="updated" ;;
      h) sort_by="help-wanted-issues" ;;
      *) sort_by="stars" ;;
      esac
    fi

    # Get language filter
    if use_gum; then
      language=$(gum input --placeholder "Filter by language (leave empty for all)" \
        --prompt "› " \
        --prompt.foreground "$COLOR_PRIMARY" \
        --cursor.foreground "$COLOR_ACCENT")
    else
      read -p "Filter by language (leave empty for all): " language
    fi
  fi

  print_info "Searching GitHub for '$search_query' (sorted by $sort_by)..."

  local cmd_args=("gh" "search" "repos" "$search_query" "--limit" "$limit" "--sort" "$sort_by")
  [ -n "$language" ] && cmd_args+=("--language" "$language")

  local results
  results=$("${cmd_args[@]}" --json fullName,description,stargazersCount,forksCount,language,updatedAt,license 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.forksCount)🍴\t\(.language // "-")\t\(.updatedAt[:10])\t\(.description // "No description")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local count
  count=$(echo "$results" | wc -l)
  print_info "Found $count repositories"

  local selected
  selected=$(echo "$results" | fzf --height=70% --border \
    --header="🔭 Explore: $search_query | Actions: Enter=select, TAB=multi" \
    --delimiter='\t' --with-nth=1,2,3,4,5 \
    --preview="echo -e 'Repository: {1}\nStars: {2} | Forks: {3}\nLanguage: {4} | Updated: {5}\n\nDescription:\n{6}'" \
    --preview-window=down:6:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  if use_gum; then
    gum style --foreground "$COLOR_SECONDARY" "Selected ${#repos[@]} repositories:"
    for r in "${repos[@]}"; do
      gum style --foreground "$COLOR_INFO" "  $r"
    done
  else
    echo -e "${CYAN}Selected ${#repos[@]} repositories:${NC}"
    printf "  - ${BLUE}%s${NC}\n" "${repos[@]}"
  fi
  echo ""

  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Fork - Fork to your account" \
      "Fork + Clone - Fork and clone" \
      "Browse - Open in browser" \
      "Star - Star the repository" \
      "Info - Show detailed info" \
      "Cancel")
  else
    echo -e "${YELLOW}Actions:${NC}"
    echo "  (c) Clone          - Clone to local machine"
    echo "  (f) Fork           - Fork to your account"
    echo "  (F) Fork + Clone   - Fork and clone"
    echo "  (b) Browse         - Open in browser"
    echo "  (s) Star           - Star the repository"
    echo "  (i) Info           - Show detailed info"
    echo "  (q) Quit           - Cancel"
    echo ""
    read -p "Action: " action
  fi

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      print_info "Cloning $repo..."
      if gh repo clone "$repo" 2>/dev/null; then
        print_success "Cloned: $repo"
      else
        print_error "Failed to clone: $repo"
      fi
    done
    ;;
  f|"Fork - Fork"*)
    for repo in "${repos[@]}"; do
      print_info "Forking $repo..."
      if gh repo fork "$repo" --clone=false 2>/dev/null; then
        print_success "Forked: $repo"
      else
        print_error "Failed to fork: $repo"
      fi
    done
    ;;
  F|"Fork + Clone"*)
    for repo in "${repos[@]}"; do
      print_info "Forking and cloning $repo..."
      if gh repo fork "$repo" --clone=true 2>/dev/null; then
        print_success "Forked and cloned: $repo"
      else
        print_error "Failed: $repo"
      fi
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      print_info "Opening $repo in browser..."
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  s|"Star"*)
    for repo in "${repos[@]}"; do
      print_info "Starring $repo..."
      if gh api -X PUT "user/starred/$repo" 2>/dev/null; then
        print_success "Starred: $repo"
      else
        print_error "Failed to star: $repo"
      fi
    done
    ;;
  i|"Info"*)
    for repo in "${repos[@]}"; do
      show_header "$repo" "Repository Details"
      gh repo view "$repo" 2>/dev/null || print_error "Failed to fetch info"
      echo ""
      if use_gum; then
        gum confirm "Continue?" --affirmative "OK" --negative "" --default=true || true
      else
        read -p "Press Enter to continue..."
      fi
    done
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Trending ---

action_trending() {
  local language="${1:-}"
  local since="daily"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --lang)
      language="$2"
      shift 2
      ;;
    --since)
      since="$2"
      shift 2
      ;;
    *)
      [ -z "$language" ] && language="$1"
      shift
      ;;
    esac
  done

  show_header "TRENDING REPOSITORIES" "Hot projects this week"

  local query="stars:>100 pushed:>$(date -d '7 days ago' '+%Y-%m-%d' 2>/dev/null || date -v-7d '+%Y-%m-%d')"
  [ -n "$language" ] && query="$query language:$language"

  print_info "Fetching trending repositories${language:+ for $language}..."

  local results
  results=$(gh search repos "$query" --sort stars --order desc --limit 30 \
    --json fullName,description,stargazersCount,language,updatedAt 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)⭐\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No trending repositories found"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=60% --border \
    --header="🔥 Trending${language:+ ($language)} | TAB=multi-select" \
    --delimiter='\t' --with-nth=1,2,3 \
    --preview="echo {4}" --preview-window=down:3:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Fork - Fork to your account" \
      "Browse - Open in browser" \
      "Star - Star the repository" \
      "Cancel")
  else
    echo "Actions: (c)lone | (f)ork | (b)rowse | (s)tar | (q)uit"
    read -p "Action: " action
  fi

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" 2>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  f|"Fork"*)
    for repo in "${repos[@]}"; do
      gh repo fork "$repo" --clone=false 2>/dev/null && print_success "Forked: $repo" || print_error "Failed: $repo"
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  s|"Star"*)
    for repo in "${repos[@]}"; do
      gh api -X PUT "user/starred/$repo" 2>/dev/null && print_success "Starred: $repo" || print_error "Failed: $repo"
    done
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Archive ---

action_archive() {
  local mode="archive"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --unarchive)
      mode="unarchive"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filter_jq
  local header_text
  if [ "$mode" = "archive" ]; then
    filter_jq='[.[] | select(.isArchived == false)]'
    header_text="Select repos to ARCHIVE"
  else
    filter_jq='[.[] | select(.isArchived == true)]'
    header_text="Select repos to UNARCHIVE"
  fi

  local filtered
  filtered=$(echo "$json" | jq "$filter_jq")

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories available to $mode"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  print_warning "You are about to $mode ${#repos[@]} repositories:"
  printf "  - %s\n" "${repos[@]}"
  echo ""
  read -p "Continue? [y/N]: " confirm

  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    print_info "Cancelled."
    return
  fi

  for repo in "${repos[@]}"; do
    print_info "${mode^}ing $repo..."
    if [ "$mode" = "archive" ]; then
      if gh repo archive "$repo" --yes 2>/dev/null; then
        print_success "Archived: $repo"
      else
        print_error "Failed to archive: $repo"
      fi
    else
      if gh repo unarchive "$repo" --yes 2>/dev/null; then
        print_success "Unarchived: $repo"
      else
        print_error "Failed to unarchive: $repo"
      fi
    fi
  done

  rm -f "$CACHE_FILE"
  print_info "Cache cleared (repo states changed)"
}

# --- Action: Stats ---

action_stats() {
  local json
  json=$(fetch_repositories_json "true")

  show_header "REPOSITORY STATISTICS" "Your GitHub Overview"

  local total public private archived
  total=$(echo "$json" | jq 'length')
  public=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")] | length')
  private=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")] | length')
  archived=$(echo "$json" | jq '[.[] | select(.isArchived == true)] | length')

  if use_gum; then
    # Build stats box with gum
    local stats_content
    stats_content=$(printf "Total Repositories:  %s\nPublic:              %s\nPrivate:             %s\nArchived:            %s" "$total" "$public" "$private" "$archived")
    gum style --border rounded --border-foreground "$COLOR_SECONDARY" --padding "1 2" --margin "0 2" "$stats_content"
  else
    echo -e "  ${GREEN}Total Repositories:${NC}  $total"
    echo -e "  ${GREEN}Public:${NC}              $public"
    echo -e "  ${YELLOW}Private:${NC}             $private"
    echo -e "  ${CYAN}Archived:${NC}            $archived"
  fi
  echo ""

  local total_stars total_forks total_size
  total_stars=$(echo "$json" | jq '[.[].stargazerCount] | add // 0')
  total_forks=$(echo "$json" | jq '[.[].forkCount] | add // 0')
  total_size=$(echo "$json" | jq '[.[].diskUsage] | add // 0')
  local size_mb=$((total_size / 1024))

  if use_gum; then
    local metrics_content
    metrics_content=$(printf "Total Stars:   %s\nTotal Forks:   %s\nTotal Size:    %s MB" "$total_stars" "$total_forks" "$size_mb")
    gum style --border rounded --border-foreground "$COLOR_ACCENT" --padding "1 2" --margin "0 2" "$metrics_content"
  else
    echo -e "  ${YELLOW}⭐ Total Stars:${NC}       $total_stars"
    echo -e "  ${BLUE}🍴 Total Forks:${NC}       $total_forks"
    echo -e "  ${CYAN}💾 Total Size:${NC}        ${size_mb} MB"
  fi
  echo ""

  show_divider "Languages Breakdown"
  echo ""

  local lang_data
  lang_data=$(echo "$json" | jq -r '
    [.[] | .primaryLanguage.name // "Unknown"] |
    group_by(.) |
    map({lang: .[0], count: length}) |
    sort_by(-.count) |
    .[:10] |
    .[] |
    "\(.lang): \(.count)"
  ')

  if use_gum; then
    echo "$lang_data" | while read -r line; do
      gum style --foreground "$COLOR_SECONDARY" "  $line"
    done
  else
    echo "$lang_data" | sed 's/^/  /'
  fi
  echo ""

  show_divider "Top Repositories (by Stars)"
  echo ""

  echo "$json" | jq -r '
    sort_by(-.stargazerCount) |
    .[:5] |
    .[] |
    "  \(.stargazerCount)\t\(.nameWithOwner)"
  ' | while IFS=$'\t' read -r stars name; do
    if use_gum; then
      local star_styled
      star_styled=$(gum style --foreground "$COLOR_WARNING" "$stars")
      local name_styled
      name_styled=$(gum style --foreground "$COLOR_SECONDARY" "$name")
      echo "$star_styled $name_styled"
    else
      printf "  %-6s %s\n" "$stars" "$name"
    fi
  done
  echo ""

  show_divider "Recently Updated (last 5)"
  echo ""

  echo "$json" | jq -r '
    sort_by(.updatedAt) | reverse |
    .[:5] |
    .[] |
    "\(.updatedAt[:10])\t\(.nameWithOwner)"
  ' | while IFS=$'\t' read -r date name; do
    if use_gum; then
      local date_styled
      date_styled=$(gum style --foreground "$COLOR_MUTED" "$date")
      local name_styled
      name_styled=$(gum style --foreground "$COLOR_SECONDARY" "$name")
      echo "  $date_styled $name_styled"
    else
      printf "  %-12s %s\n" "$date" "$name"
    fi
  done
  echo ""
}

# --- Action: Search ---

action_search() {
  local json
  json=$(fetch_repositories_json "false")

  print_info "Type to search (fuzzy matching on name and description)..."

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "No description")\t\(.visibility)\t\(.primaryLanguage.name // "-")"' |
    fzf --height=60% --border \
      --header="Search repositories (ESC to cancel)" \
      --delimiter='\t' \
      --with-nth=1,3,4 \
      --preview="echo -e 'Description:\n{2}'" \
      --preview-window=down:3:wrap \
      --multi)

  [ -z "$selected" ] && return

  echo ""
  if use_gum; then
    gum style --foreground "$COLOR_SECONDARY" "Selected repositories:"
    while IFS=$'\t' read -r repo desc vis lang; do
      gum style --foreground "$COLOR_INFO" "  $repo [$vis] ($lang)"
    done <<<"$selected"
  else
    echo -e "${CYAN}Selected repositories:${NC}"
    while IFS=$'\t' read -r repo desc vis lang; do
      echo -e "  ${BLUE}$repo${NC} [$vis] ($lang)"
    done <<<"$selected"
  fi

  echo ""
  local action
  if use_gum; then
    action=$(gum choose \
      --header "Select action:" \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      "Clone - Clone to local machine" \
      "Browse - Open in browser" \
      "Delete - Delete repositories" \
      "Cancel")
  else
    echo "Actions: (c)lone | (b)rowse | (d)elete | (q)uit"
    read -p "Action: " action
  fi

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  case "$action" in
  c|"Clone"*)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" &>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  b|"Browse"*)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  d|"Delete"*)
    print_warning "Delete selected repos? This is NOT reversible!"
    local confirm
    if use_gum; then
      confirm=$(gum input --placeholder "Type DELETE to confirm" \
        --prompt "› " \
        --prompt.foreground "$COLOR_ERROR" \
        --cursor.foreground "$COLOR_ERROR")
    else
      read -p "Type 'DELETE' to confirm: " confirm
    fi
    if [ "$confirm" = "DELETE" ]; then
      for repo in "${repos[@]}"; do
        gh repo delete "$repo" --yes 2>/dev/null && print_success "Deleted: $repo" || print_error "Failed: $repo"
      done
      rm -f "$CACHE_FILE"
      print_info "Cache cleared (repo deleted)"
    else
      print_info "Cancelled"
    fi
    ;;
  q|"Cancel"*|*)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Browse ---

action_browse() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="Select repos to open in browser" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _; do
    print_info "Opening $repo in browser..."
    gh browse -R "$repo" 2>/dev/null &
  done <<<"$selected"

  print_success "Opened selected repositories in browser"
}

# --- Action: Visibility ---

action_visibility() {
  local target_visibility=""

  while [[ $# -gt 0 ]]; do
    case $1 in
    --public)
      target_visibility="public"
      shift
      ;;
    --private)
      target_visibility="private"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filtered header_text
  if [ "$target_visibility" = "public" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")]')
    header_text="Select PRIVATE repos to make PUBLIC"
  elif [ "$target_visibility" = "private" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")]')
    header_text="Select PUBLIC repos to make PRIVATE"
  else
    filtered="$json"
    header_text="Select repos to toggle visibility"
  fi

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories match the criteria"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.visibility)"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t')

  [ -z "$selected" ] && return

  local repos=()
  local visibilities=()
  while IFS=$'\t' read -r repo vis; do
    repos+=("$repo")
    visibilities+=("$vis")
  done <<<"$selected"

  print_warning "Visibility changes:"
  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi
    echo -e "  ${repos[$i]}: ${visibilities[$i]} → ${new_vis^^}"
  done

  echo ""
  read -p "Continue? [y/N]: " confirm
  [[ ! "$confirm" =~ ^[Yy]$ ]] && return

  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi

    print_info "Changing ${repos[$i]} to $new_vis..."
    if gh repo edit "${repos[$i]}" --visibility "$new_vis" 2>/dev/null; then
      print_success "Updated: ${repos[$i]}"
    else
      print_error "Failed: ${repos[$i]}"
    fi
  done

  rm -f "$CACHE_FILE"
}

# --- Action: PR (Pull Requests) ---

action_pr() {
  local subcommand="${1:-list}"
  shift 2>/dev/null || true

  case "$subcommand" in
  list)
    action_pr_list "$@"
    ;;
  create)
    action_pr_create "$@"
    ;;
  *)
    print_error "Unknown PR subcommand: $subcommand"
    echo "Usage: ghtools pr {list|create}"
    ;;
  esac
}

action_pr_list() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --height=40% --border --header="Select repository to list PRs")

  [ -z "$selected" ] && return

  print_info "Fetching PRs for $selected..."
  echo ""

  gh pr list -R "$selected" --limit 20 --json number,title,state,author,createdAt \
    --template '{{range .}}#{{.number}} [{{.state}}] {{.title}} (by {{.author.login}}, {{timeago .createdAt}})
{{end}}'
}

action_pr_create() {
  if [ ! -d ".git" ]; then
    print_error "Not in a git repository"
    return 1
  fi

  local current_branch
  current_branch=$(git branch --show-current)

  # Handle detached HEAD state
  if [ -z "$current_branch" ]; then
    print_error "You are in 'detached HEAD' state. Please checkout a branch first."
    print_info "Tip: Use 'git checkout -b branch-name' to create a new branch from current state."
    return 1
  fi

  if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
    print_warning "You're on $current_branch branch. Create a feature branch first."
    return 1
  fi

  print_info "Creating PR from branch: $current_branch"

  read -p "PR Title: " title
  [ -z "$title" ] && title="$current_branch"

  local draft=""
  read -p "Create as draft? [y/N]: " is_draft
  [[ "$is_draft" =~ ^[Yy]$ ]] && draft="--draft"

  # Push branch if needed
  if ! git ls-remote --exit-code --heads origin "$current_branch" &>/dev/null; then
    print_info "Pushing branch to origin..."
    git push -u origin "$current_branch"
  fi

  # shellcheck disable=SC2086
  if gh pr create --title "$title" --body "" $draft; then
    print_success "PR created successfully"
  else
    print_error "Failed to create PR"
  fi
}

# --- Action: Status ---

action_status() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local max_depth=3

  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  print_info "Scanning repositories in $base_path..."

  local git_dirs
  # Use -print0 and xargs -0 to handle paths with spaces correctly
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune -print0 2>/dev/null | xargs -0 -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found"
    return
  fi

  echo ""
  printf "${CYAN}%-35s %-12s %-10s %-10s %s${NC}\n" "REPOSITORY" "BRANCH" "STATUS" "AHEAD" "BEHIND"
  printf "${CYAN}%s${NC}\n" "$(printf '%*s' 85 '' | tr ' ' '-')"

  for repo_path in "${git_dirs[@]}"; do
    local repo_name branch status_icon ahead behind
    repo_name=$(basename "$repo_path")
    branch=$(git -C "$repo_path" branch --show-current 2>/dev/null || echo "detached")

    # Check dirty state
    local dirty=false
    if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
      dirty=true
    fi

    # Check untracked files
    local untracked=false
    if [ -n "$(git -C "$repo_path" ls-files --others --exclude-standard 2>/dev/null)" ]; then
      untracked=true
    fi

    # Determine status
    if [ "$dirty" = "true" ] && [ "$untracked" = "true" ]; then
      status_icon="${RED}dirty+untrk${NC}"
    elif [ "$dirty" = "true" ]; then
      status_icon="${YELLOW}dirty${NC}"
    elif [ "$untracked" = "true" ]; then
      status_icon="${YELLOW}untracked${NC}"
    else
      status_icon="${GREEN}clean${NC}"
    fi

    # Check ahead/behind
    ahead=$(git -C "$repo_path" rev-list --count @{u}..HEAD 2>/dev/null || echo "?")
    behind=$(git -C "$repo_path" rev-list --count HEAD..@{u} 2>/dev/null || echo "?")

    local ahead_color="$NC" behind_color="$NC"
    [ "$ahead" != "0" ] && [ "$ahead" != "?" ] && ahead_color="$GREEN"
    [ "$behind" != "0" ] && [ "$behind" != "?" ] && behind_color="$RED"

    printf "%-35s %-12s ${status_icon}%-10s ${ahead_color}%-10s${NC} ${behind_color}%s${NC}\n" \
      "$(truncate_text "$repo_name" 35)" "$branch" "" "$ahead" "$behind"
  done

  echo ""
  print_info "Legend: ${GREEN}clean${NC} | ${YELLOW}dirty/untracked${NC} | ${GREEN}ahead${NC} (unpushed) | ${RED}behind${NC} (needs pull)"
}

# --- Main Menu ---

show_menu() {
  # Show beautiful header
  if use_gum; then
    clear
    gum style \
      --border rounded \
      --border-foreground "$COLOR_PRIMARY" \
      --foreground "$COLOR_SECONDARY" \
      --align center \
      --width 50 \
      --padding "1 2" \
      --margin "1 0" \
      "GHTOOLS" "GitHub Repository Manager v$VERSION"
    echo ""
  fi

  local options=(
    "List Repositories"
    "Search My Repos"
    "Explore GitHub"
    "Trending Repos"
    "Statistics Dashboard"
    "Clone Repositories"
    "Sync Local Repos"
    "Local Repo Status"
    "Fork Repository"
    "Create Repository"
    "Delete Repositories"
    "Archive/Unarchive"
    "Change Visibility"
    "Browse in Browser"
    "Pull Requests"
    "Config"
    "Refresh Cache"
    "Exit"
  )

  local choice
  if use_gum; then
    choice=$(printf '%s\n' "${options[@]}" | gum choose \
      --cursor "› " \
      --cursor.foreground "$COLOR_ACCENT" \
      --header "Select an action:" \
      --header.foreground "$COLOR_PRIMARY" \
      --selected.foreground "$COLOR_SECONDARY" \
      --height 20)
  else
    local options_legacy="📋 List Repositories
🔍 Search My Repos
🔭 Explore GitHub
🔥 Trending Repos
📊 Statistics Dashboard
📦 Clone Repositories
🔄 Sync Local Repos
📁 Local Repo Status
🍴 Fork Repository
➕ Create Repository
🗑️  Delete Repositories
📦 Archive/Unarchive
🔒 Change Visibility
🌐 Browse in Browser
📝 Pull Requests
⚙️  Config
🔄 Refresh Cache
🚪 Exit"
    choice=$(echo "$options_legacy" | fzf --height=55% --border --header="GitHub Tools v$VERSION" --layout=reverse)
  fi

  case "$choice" in
  *"List"*) action_list ;;
  *"Search My"*) action_search ;;
  *"Explore"*) action_explore ;;
  *"Trending"*) action_trending ;;
  *"Statistics"*) action_stats ;;
  *"Clone"*) action_clone ;;
  *"Sync"*) action_sync ;;
  *"Local Repo Status"*) action_status ;;
  *"Fork"*) action_fork ;;
  *"Create"*) action_create ;;
  *"Delete"*) action_delete ;;
  *"Archive"*) action_archive ;;
  *"Visibility"*) action_visibility ;;
  *"Browse"*) action_browse ;;
  *"Pull Requests"*) action_pr ;;
  *"Config"*)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;
  *"Refresh"*)
    rm -f "$CACHE_FILE"
    print_success "Cache cleared."
    show_menu
    ;;
  *"Exit"*) exit 0 ;;
  *) exit 0 ;;
  esac
}

# --- Entry Point ---

main() {
  # Parse global options first
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_usage
      exit 0
      ;;
    -v | --version)
      echo "ghtools $VERSION"
      exit 0
      ;;
    -V | --verbose)
      VERBOSE=true
      shift
      ;;
    -q | --quiet)
      QUIET=true
      shift
      ;;
    *)
      # Stop parsing global options, pass to command handler
      break
      ;;
    esac
  done

  check_dependencies
  check_gh_auth

  if [ $# -eq 0 ]; then
    while true; do
      show_menu
      echo ""
      read -p "Press Enter to continue..."
    done
  fi

  case "$1" in
  list)
    shift
    action_list "$@"
    ;;
  clone)
    shift
    action_clone "$@"
    ;;
  sync)
    shift
    action_sync "$@"
    ;;
  create) action_create ;;
  delete) action_delete ;;
  fork)
    shift
    action_fork "$@"
    ;;
  archive)
    shift
    action_archive "$@"
    ;;
  stats) action_stats ;;
  search) action_search ;;
  browse) action_browse ;;
  explore)
    shift
    action_explore "$@"
    ;;
  trending)
    shift
    action_trending "$@"
    ;;
  visibility)
    shift
    action_visibility "$@"
    ;;
  pr)
    shift
    action_pr "$@"
    ;;
  status)
    shift
    action_status "$@"
    ;;
  config)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;
  refresh)
    rm -f "$CACHE_FILE"
    print_success "Cache cleared."
    ;;
  help)
    show_usage
    ;;
  *)
    print_error "Unknown command: $1"
    show_usage
    exit 1
    ;;
  esac
}

# Only execute main if this script is being run directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
</file>
<file path="install.sh">
#!/bin/bash

# GitHub Tools Installation Script
# This script installs ghtools to ~/scripts

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

echo -e "${BLUE}╔════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║     GitHub Tools Installation Script      ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════╝${NC}"
echo ""

# Check if running as root
if [ "$EUID" -eq 0 ]; then
    print_warning "Please do not run this script as root (with sudo)"
    echo "The script will ask for sudo password when needed."
    exit 1
fi

# Get the directory where the install script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GHTOOLS_SCRIPT="$SCRIPT_DIR/ghtools"

# Check if script exists
if [ ! -f "$GHTOOLS_SCRIPT" ]; then
    print_error "ghtools script not found at: $GHTOOLS_SCRIPT"
    exit 1
fi

print_info "Found ghtools script at: $GHTOOLS_SCRIPT"

# Check dependencies
print_info "Checking dependencies..."

missing_deps=()

if ! command -v gh &> /dev/null; then
    missing_deps+=("gh (GitHub CLI)")
fi

if ! command -v fzf &> /dev/null; then
    missing_deps+=("fzf")
fi

if ! command -v git &> /dev/null; then
    missing_deps+=("git")
fi

if ! command -v jq &> /dev/null; then
    missing_deps+=("jq")
fi

# Check for optional but recommended dependencies
optional_deps=()
if ! command -v gum &> /dev/null; then
    optional_deps+=("gum")
fi

if [ ${#missing_deps[@]} -ne 0 ]; then
    print_error "Missing required dependencies:"
    for dep in "${missing_deps[@]}"; do
        echo "  - $dep"
    done
    echo ""
    echo "Install them using:"
    echo -e "  ${BLUE}sudo pacman -S github-cli fzf git jq gum${NC}"
    echo "  or"
    echo -e "  ${BLUE}yay -S github-cli fzf git jq gum${NC}"
    exit 1
fi

print_success "All required dependencies are installed"

# Notify about optional dependencies
if [ ${#optional_deps[@]} -ne 0 ]; then
    echo ""
    print_warning "Optional dependencies for enhanced UI:"
    for dep in "${optional_deps[@]}"; do
        echo -e "  ${YELLOW}•${NC} $dep - Beautiful terminal UI components"
    done
    echo ""
    echo -e "Install for best experience: ${CYAN}sudo pacman -S gum${NC}"
    echo ""
fi

# Create ~/scripts directory if it doesn't exist
INSTALL_DIR="$HOME/scripts"
mkdir -p "$INSTALL_DIR"

# Install script to ~/scripts
print_info "Installing script to $INSTALL_DIR..."

cp "$GHTOOLS_SCRIPT" "$INSTALL_DIR/ghtools"
chmod +x "$INSTALL_DIR/ghtools"

print_success "ghtools installed successfully!"

# ============================================================================
# PATH Configuration Functions
# ============================================================================

# Get all possible zsh config files
get_zsh_config_files() {
    local files=()

    # Main zsh config files
    [ -f "$HOME/.zshrc" ] && files+=("$HOME/.zshrc")
    [ -f "$HOME/.zshrc_custom" ] && files+=("$HOME/.zshrc_custom")
    [ -f "$HOME/.zshenv" ] && files+=("$HOME/.zshenv")
    [ -f "$HOME/.zprofile" ] && files+=("$HOME/.zprofile")
    [ -f "$HOME/.zlogin" ] && files+=("$HOME/.zlogin")

    # Modular config files
    if [ -d "$HOME/.config/zshrc" ]; then
        for config in "$HOME/.config/zshrc/"*; do
            [ -f "$config" ] && files+=("$config")
        done
    fi

    printf '%s\n' "${files[@]}"
}

# Check if scripts directory is already in PATH configuration files
# Returns: array of files containing the PATH
check_scripts_in_config_files() {
    local files_with_path=()
    local pattern="(export PATH=.*scripts|PATH=.*scripts)"

    while IFS= read -r file; do
        if grep -qE "$pattern" "$file" 2>/dev/null; then
            files_with_path+=("$file")
        fi
    done < <(get_zsh_config_files)

    printf '%s\n' "${files_with_path[@]}"
}

# Remove PATH configuration from a file
remove_path_from_file() {
    local file=$1
    local backup="${file}.backup_$(date +%s)"

    # Create backup
    cp "$file" "$backup"

    # Remove lines with scripts PATH
    sed -i '/export PATH=.*scripts/d' "$file"
    sed -i '/PATH=.*scripts/d' "$file"

    # Also remove the comment line if it exists
    sed -i '/# Add ~\/scripts to PATH/d' "$file"

    print_success "Removed PATH configuration from: $file"
    print_info "Backup created at: $backup"
}

# Add PATH to selected file
add_path_to_file() {
    local file=$1

    echo "" >> "$file"
    echo "# Add ~/scripts to PATH for custom scripts" >> "$file"
    echo "export PATH=\"\$HOME/scripts:\$PATH\"" >> "$file"

    print_success "Added PATH to: $file"
}

# ============================================================================
# PATH Configuration Management
# ============================================================================

echo ""
echo -e "${BLUE}═══════════════════════════════════════════${NC}"
echo -e "${BLUE}PATH Configuration Check${NC}"
echo -e "${BLUE}═══════════════════════════════════════════${NC}"
echo ""

# Check if scripts directory is in any config files
files_with_path=()
mapfile -t files_with_path < <(check_scripts_in_config_files)

# Check if currently in PATH
if [[ ":$PATH:" == *":$INSTALL_DIR:"* ]]; then
    print_success "$INSTALL_DIR is already in your PATH"

    # Check for duplicates in config files
    if [ ${#files_with_path[@]} -gt 1 ]; then
        echo ""
        print_warning "DUPLICATE DETECTED! PATH is configured in multiple files:"
        echo ""
        for file in "${files_with_path[@]}"; do
            line_info=$(grep -n "PATH=.*scripts" "$file" 2>/dev/null | head -1)
            echo -e "  ${YELLOW}→${NC} $file"
            echo -e "    Line: ${CYAN}$line_info${NC}"
        done
        echo ""
        echo "Having duplicates can cause PATH pollution and unexpected behavior."
        echo ""

        read -p "Would you like to remove duplicates? (y/N): " -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Select which file to KEEP the PATH configuration:"
            echo ""
            i=1
            for file in "${files_with_path[@]}"; do
                echo -e "  ${GREEN}$i${NC}) $file"
                ((i++))
            done
            echo -e "  ${RED}0${NC}) Cancel"
            echo ""

            read -p "Enter number: " -r file_choice

            if [[ "$file_choice" =~ ^[0-9]+$ ]] && [ "$file_choice" -ge 1 ] && [ "$file_choice" -le ${#files_with_path[@]} ]; then
                keep_file="${files_with_path[$((file_choice-1))]}"
                echo ""
                print_info "Keeping PATH configuration in: $keep_file"
                echo ""

                # Remove from all other files
                for file in "${files_with_path[@]}"; do
                    if [ "$file" != "$keep_file" ]; then
                        remove_path_from_file "$file"
                    fi
                done

                echo ""
                print_success "Duplicates removed successfully!"
                print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
            else
                print_info "Cancelled. No changes made."
            fi
        fi
    elif [ ${#files_with_path[@]} -eq 1 ]; then
        print_info "PATH is configured in: ${files_with_path[0]}"
    fi
else
    # Not in current PATH
    if [ ${#files_with_path[@]} -gt 0 ]; then
        print_warning "$INSTALL_DIR is configured but not in current PATH"
        echo ""
        echo "PATH is configured in the following file(s):"
        for file in "${files_with_path[@]}"; do
            echo "  → $file"
        done
        echo ""
        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"

        # Check for duplicates
        if [ ${#files_with_path[@]} -gt 1 ]; then
            echo ""
            print_warning "Multiple PATH configurations detected (duplicates)"
            read -p "Would you like to remove duplicates? (y/N): " -r
            echo ""

            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "Select which file to KEEP:"
                echo ""
                i=1
                for file in "${files_with_path[@]}"; do
                    echo -e "  ${GREEN}$i${NC}) $file"
                    ((i++))
                done
                echo ""

                read -p "Enter number: " -r file_choice

                if [[ "$file_choice" =~ ^[0-9]+$ ]] && [ "$file_choice" -ge 1 ] && [ "$file_choice" -le ${#files_with_path[@]} ]; then
                    keep_file="${files_with_path[$((file_choice-1))]}"
                    echo ""

                    for file in "${files_with_path[@]}"; do
                        if [ "$file" != "$keep_file" ]; then
                            remove_path_from_file "$file"
                        fi
                    done

                    print_success "Duplicates removed!"
                fi
            fi
        fi
    else
        # Not configured anywhere
        print_warning "$INSTALL_DIR is not in your PATH"
        echo ""
        echo "To use ghtools from anywhere, add it to your PATH."
        echo ""

        read -p "Would you like to add it now? (y/N): " -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # Offer file selection
            echo "Where would you like to add the PATH?"
            echo ""
            echo -e "  ${GREEN}1${NC}) ~/.zshrc ${CYAN}(recommended for general use)${NC}"
            echo -e "  ${GREEN}2${NC}) ~/.zshrc_custom ${CYAN}(for user customizations)${NC}"

            if [ -d "$HOME/.config/zshrc" ]; then
                echo -e "  ${GREEN}3${NC}) ~/.config/zshrc/00-init ${CYAN}(modular config)${NC}"
            fi

            echo -e "  ${RED}0${NC}) Skip"
            echo ""

            read -p "Enter number: " -r choice
            echo ""

            case "$choice" in
                1)
                    if [ -f "$HOME/.zshrc" ]; then
                        add_path_to_file "$HOME/.zshrc"
                        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
                    else
                        print_error "~/.zshrc not found"
                    fi
                    ;;
                2)
                    if [ -f "$HOME/.zshrc_custom" ]; then
                        add_path_to_file "$HOME/.zshrc_custom"
                        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
                    else
                        print_error "~/.zshrc_custom not found"
                    fi
                    ;;
                3)
                    if [ -d "$HOME/.config/zshrc" ]; then
                        add_path_to_file "$HOME/.config/zshrc/00-init"
                        print_info "Reload your shell: ${GREEN}source ~/.zshrc${NC}"
                    else
                        print_error "~/.config/zshrc not found"
                    fi
                    ;;
                *)
                    print_info "Skipped. You can add it manually later."
                    echo ""
                    echo "Add this line to your preferred zsh config file:"
                    echo -e "  ${BLUE}export PATH=\"\$HOME/scripts:\$PATH\"${NC}"
                    ;;
            esac
        else
            print_info "Skipped. Add this line to your zsh config:"
            echo -e "  ${BLUE}export PATH=\"\$HOME/scripts:\$PATH\"${NC}"
        fi
    fi
fi

echo ""
print_success "Installation complete!"
echo ""
echo -e "Run ${GREEN}ghtools${NC} to start using the interactive menu!"

echo ""
echo -e "${CYAN}═══════════════════════════════════════════${NC}"
print_info "Usage:"
echo ""
echo -e "  ${GREEN}ghtools${NC}        - Interactive menu (recommended)"
echo -e "  ${GREEN}ghtools clone${NC}  - Clone repositories"
echo -e "  ${GREEN}ghtools delete${NC} - Delete repositories"
echo -e "  ${GREEN}ghtools help${NC}   - Show help message"
echo ""
print_info "To uninstall, run: rm ~/scripts/ghtools"
</file>
<file path="README.md">
# ghtools - Unified GitHub Repository Management Tool

## Project Overview

The `ghtools` project is a powerful, single-file **Bash script** designed to simplify and accelerate the management of GitHub repositories directly from the command line. It acts as an interactive, feature-rich wrapper and orchestrator for essential command-line tools like the GitHub CLI (`gh`), `git`, `fzf`, and `jq`.

### Purpose and Main Functionality

The primary purpose of `ghtools` is to provide a unified, interactive terminal user interface (TUI) for common and bulk GitHub operations, abstracting away complex API calls and repetitive command sequences.

### Key Features and Capabilities

*   **Interactive TUI:** Utilizes `gum` or `fzf` for fuzzy-finding, selection, and interactive prompts across all major commands.
*   **Bulk Operations:** Supports parallel execution for cloning (`clone`) and synchronizing (`sync`) multiple repositories, limited by a configurable `MAX_JOBS` setting.
*   **Performance Caching:** Implements a time-to-live (TTL) file-based cache for the repository list, significantly reducing repeated calls to the GitHub API.
*   **Comprehensive Actions:** Provides dedicated commands for listing, cloning, syncing, creating, deleting, archiving, and changing the visibility of repositories.
*   **Local Status Checks:** The `sync` and `status` commands provide detailed information on the local state of repositories (e.g., dirty working directory, ahead/behind remote).

### Likely Intended Use Cases

*   **Developer Onboarding:** Quickly clone a large set of required repositories for a new project or team.
*   **Daily Workflow:** Rapidly check the status and pull updates for all local repositories with a single command (`ghtools sync`).
*   **Repository Administration:** Securely and interactively delete or archive multiple repositories.
*   **Discovery:** Search, explore, and view trending repositories directly in the terminal.

## Table of Contents

1.  [Project Overview](#project-overview)
2.  [Architecture](#architecture)
3.  [C4 Model Architecture](#c4-model-architecture)
4.  [Repository Structure](#repository-structure)
5.  [Dependencies and Integration](#dependencies-and-integration)
6.  [API Documentation](#api-documentation)
7.  [Development Notes](#development-notes)
8.  [Known Issues and Limitations](#known-issues-and-limitations)
9.  [Additional Documentation](#additional-documentation)

## Architecture

### High-level Architecture Overview

The `ghtools` project employs a **Monolithic Script Architecture** written entirely in Bash. It functions as an **Orchestrator** or **Facade** layer, providing a simplified, unified interface over several powerful external command-line tools.

The core design follows a **Command Dispatcher Pattern**, where the main script parses the user's command and delegates execution to a specific, modular `action_*` function.

### Technology Stack and Frameworks

| Component | Technology | Role |
| :--- | :--- | :--- |
| **Core Logic** | Bash | Scripting language for control flow, configuration, and orchestration. |
| **GitHub Interaction** | GitHub CLI (`gh`) | Primary tool for all GitHub API calls (data retrieval, creation, deletion). |
| **Data Processing** | `jq` | JSON parser used for filtering and transforming data from `gh` output. |
| **User Interface** | `gum` (Optional) / `fzf` (Required) | Provides styled TUI components, interactive prompts, and fuzzy-finding selection. |
| **Local Git Operations** | `git` | Standard tool for cloning, pulling, and checking local repository status. |

### Component Relationships (with mermaid diagrams)

The script's internal structure is highly coupled, with core actions relying on a centralized set of data retrieval and UI utilities.

```mermaid
graph TD
    A[Main Entry Point] --> B(Configuration Loading);
    B --> C(Dependency/Auth Checks);
    C --> D{Command Dispatcher};

    D --> E[Action Functions (clone, sync, delete)];
    D --> F[Interactive Menu];

    E --> G[get_repo_list (Cache Manager)];
    E --> H[run_parallel_jobs (Template Method)];
    E --> I[UI/Printing Functions];

    G --> J[gh CLI];
    G --> K[jq CLI];

    E --> L[git CLI];
    F --> M[fzf/gum CLI];
    I --> M;

    style J fill:#f9f,stroke:#333,stroke-width:2px
    style K fill:#f9f,stroke:#333,stroke-width:2px
    style L fill:#f9f,stroke:#333,stroke-width:2px
    style M fill:#f9f,stroke:#333,stroke-width:2px
```

### Key Design Patterns

| Pattern | Description | Context |
| :--- | :--- | :--- |
| **Facade** | The entire script provides a simplified, unified interface for complex operations involving multiple underlying tools (`gh`, `git`, `fzf`). | The user only interacts with `ghtools`. |
| **Command Dispatcher** | Uses a `case` statement to route the command-line verb to the appropriate `action_*` handler function. | Main execution block of the script. |
| **Template Method** | The `run_parallel_jobs` function provides a reusable structure for concurrent execution, used by `action_clone` and `action_sync`. | Bulk operations. |
| **Cache-Aside** | The `fetch_repositories_json` function manages a file-based cache, checking its validity before calling the external GitHub API. | Repository data retrieval. |

## C4 Model Architecture

### <details>
<summary>Context Diagram</summary>

```mermaid
C4Context
    title Context Diagram for ghtools
    Person(user, "Developer", "Manages GitHub repositories via the command line.")
    System(ghtools, "ghtools CLI", "A Bash script that orchestrates repository management.")
    System_Ext(github, "GitHub API", "Provides repository data and handles all persistence (create, delete, update).")
    System_Ext(cli_tools, "External CLI Tools", "Required tools: gh, git, jq, fzf. Optional: gum.")

    user -- Executes commands --> ghtools
    ghtools -- Calls --> github : Fetches data, performs actions (via gh CLI)
    ghtools -- Orchestrates --> cli_tools : For data processing, TUI, and Git operations
```
</details>

### <details>
<summary>Container Diagram</summary>

```mermaid
C4Container
    title Container Diagram for ghtools
    System_Boundary(ghtools_system, "ghtools Repository Management Tool")
        Container(script, "ghtools Bash Script", "Bash", "The monolithic script containing all application logic, command dispatch, and orchestration.")
        Container(config, "Configuration File", "Plain Text (~/.config/ghtools/config)", "Stores user-defined settings like CACHE_TTL, MAX_JOBS, and DEFAULT_ORG.")
        Container(cache, "Repository Cache", "JSON File (/tmp/ghtools_repos_UID.json)", "Stores a time-to-live (TTL) copy of the GitHub repository list for performance.")
    System_Ext(gh_cli, "GitHub CLI (gh)", "Go Executable", "Primary interface for all GitHub API interactions.")
    System_Ext(jq, "jq CLI", "C Executable", "Used for parsing, filtering, and transforming JSON output.")
    System_Ext(fzf_gum, "TUI Tools (fzf/gum)", "Go Executable", "Provides interactive fuzzy-finding and styled terminal UI.")
    System_Ext(git, "Git CLI", "C Executable", "Used for local repository operations (clone, pull, status checks).")

    script --> config : Reads configuration on startup
    script --> cache : Reads/Writes cached repository data (securely)
    script --> gh_cli : Executes commands for API interaction
    script --> jq : Pipes gh output for JSON processing
    script --> fzf_gum : Pipes data for interactive selection/display
    script --> git : Executes local repository operations (sync, clone)
```
</details>

## Repository Structure

The project is characterized by its simplicity, being primarily a single executable file.

| Directory/File | Purpose |
| :--- | :--- |
| `ghtools` | The single, monolithic Bash script containing all application logic and functions. |
| `install.sh` | Script for checking dependencies and installing the `ghtools` executable. |
| `test/` | Contains the BATS (Bash Automated Testing System) test suite for unit and integration testing. |
| `~/.config/ghtools/` | User configuration directory (created on first run). |

## Dependencies and Integration

The application's core functionality is achieved by integrating with external services and relying on a set of internal utility functions.

### Internal Dependencies

The single-file structure results in **High Coupling** between functions. Core action functions (`action_clone`, `action_sync`, etc.) are tightly dependent on:

*   **Data Retrieval:** `get_repo_list` (which manages caching and calls `gh`/`jq`).
*   **Parallelism:** `run_parallel_jobs` (which manages concurrent execution).
*   **UI/Logging:** `print_error`, `print_success`, `print_info` (which manage styled output based on global flags).

### External Service Dependencies

The tool's primary integration is with the GitHub platform, mediated entirely through the `gh` CLI.

| Service | Integration Point | Protocol/Tool | Details |
| :--- | :--- | :--- | :--- |
| **GitHub** | Repository Management | `gh` CLI | All core actions (list, create, delete, archive) are executed by wrapping the `gh` command. Requires the user to be authenticated via `gh auth login`. |
| **Local Filesystem** | Configuration & Cache | Bash Utilities | Used to read configuration from `$CONFIG_FILE` and manage the temporary, secure repository cache at `$CACHE_FILE`. |

## API Documentation

The `ghtools` application does not expose an HTTP API; its "API" is the set of command-line interface (CLI) commands it provides.

### API Endpoints (CLI Commands)

The tool provides a comprehensive set of commands for repository management:

| Command | Description | Core Functionality |
| :--- | :--- | :--- |
| `list` | Lists repositories, supporting filtering by language or organization. | Data Retrieval, Filtering, Caching |
| `clone` | Interactively selects and clones repositories in parallel. | Interactive Selection, Parallel Execution |
| `sync` | Synchronizes local repositories (performs `git pull --ff-only`). | Local Operations, Parallel Execution |
| `create` | Interactively creates a new GitHub repository. | Remote Write Operation |
| `delete` | Securely and interactively deletes selected repositories. | Remote Write Operation, Authorization Check |
| `status` | Shows the git status (dirty, ahead/behind) of local repositories. | Local Operations, Status Reporting |
| `search` | Interactive fuzzy search across local and remote repositories. | Interactive Selection, Data Filtering |
| `refresh` | Clears the local repository cache, forcing a fresh API call. | Cache Invalidation |

### Request/Response Formats: `ghtools list`

The `list` command is the primary data retrieval endpoint, demonstrating the tool's caching and transformation capabilities.

| Detail | Description |
| :--- | :--- |
| **Method/Path** | `ghtools list [--refresh] [--lang <lang>] [--org <org>]` |
| **Request Parameters** | `--refresh` (Flag): Bypasses the `CACHE_TTL`. `--lang <lang>` (String): Filters by primary language. `--org <org>` (String): Filters by organization. |
| **Authentication** | Inherited from `gh CLI` (requires `gh auth login`). |
| **Response (Success)** | A formatted table printed to standard output, including columns like `NAME`, `DESCRIPTION`, `VISIBILITY`, `LANG`, and `UPDATED` date. |
| **Response (Error)** | An error message printed to `stderr` if the GitHub API call fails (e.g., rate limit exceeded, authentication failure). |
| **Data Flow** | `gh repo list --json` -> `jq` transformation -> Cache File -> `jq` filtering -> Console Output. |

## Development Notes

### Project-specific Conventions

*   **Strict Shell Mode:** The script uses `set -euo pipefail` to ensure robust error handling, immediately exiting on command failure or use of an unset variable.
*   **Function Naming:** Core commands are prefixed with `action_` (e.g., `action_clone`), while utility functions are descriptive (e.g., `print_error`, `check_dependencies`).
*   **Output Abstraction:** All user-facing output must pass through the `print_*` utility functions to respect the global `VERBOSE` and `QUIET` flags and ensure consistent styling.

### Testing Requirements

*   The project uses **BATS (Bash Automated Testing System)** for testing.
*   Tests cover both unit-level logic (e.g., configuration parsing, cache validation) and integration tests that verify the orchestration of external tools (`gh`, `git`).

### Performance Considerations

*   **Caching:** The `CACHE_TTL` (default 600 seconds) minimizes API calls for the repository list, which is the most expensive read operation.
*   **Parallelism:** The `action_clone` and `action_sync` handlers utilize `xargs -P $MAX_JOBS` to execute tasks concurrently, significantly improving performance for bulk operations.
*   **Data Transformation:** Extensive use of `jq` ensures efficient, in-memory JSON processing, avoiding slow shell string manipulation where possible.

## Known Issues and Limitations

| Issue/Limitation | Description | Technical Debt/Risk |
| :--- | :--- | :--- |
| **Fragility to External CLI Changes** | The script is tightly coupled to the specific command-line arguments and JSON output format of `gh` and `jq`. Changes to these external tools could break core functionality. | High Risk |
| **Monolithic Structure** | The single-file architecture and heavy reliance on global variables lead to high coupling, making it difficult to isolate functions for unit testing or refactoring. | Technical Debt |
| **Configuration Security** | The `load_config` function uses `source`, which is inherently risky. While a `grep` check is implemented to validate contents, a sophisticated bypass could lead to arbitrary code execution. | Security Risk |
| **UX Degradation** | The enhanced Terminal UI (TUI) is dependent on the optional `gum` tool. Users without `gum` will experience a functional but less visually appealing interface. | Limitation |
| **No Explicit Retry Logic** | The script relies on the underlying resilience of the `gh` CLI. There is no explicit retry or circuit breaker logic implemented in Bash for handling transient API failures. | Limitation |

## Additional Documentation

*   [Testing Documentation](./test/README.md): Details on the BATS test suite setup and execution.
*   [AI Agent Documentation](./AGENTS.md): Documentation related to the AI agents used in the development workflow.
*   [Claude AI Documentation](./CLAUDE.md): Specific documentation regarding the use of the Claude AI model.
*   [AI Command Definitions](./.claude/commands/): A collection of markdown files defining specific commands/prompts for the AI assistant. (Note: This directory is for development context.)
</file>
<file path="run_tests.sh">
#!/bin/bash

# ghtools Test Runner
# This script runs all tests and generates coverage reports

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEST_DIR="$SCRIPT_DIR/test"

echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║           ghtools - Test Runner                           ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Check if bats is installed
if ! command -v bats &>/dev/null; then
    echo -e "${RED}Error: bats is not installed${NC}"
    echo "Please install bats: git clone https://github.com/bats-core/bats-core.git && cd bats-core && sudo ./install.sh /usr/local"
    exit 1
fi

# Check if required tools are available
echo -e "${YELLOW}Checking dependencies...${NC}"
for cmd in jq git; do
    if ! command -v "$cmd" &>/dev/null; then
        echo -e "${RED}Missing dependency: $cmd${NC}"
        exit 1
    fi
done
echo -e "${GREEN}✓ All dependencies found${NC}"
echo ""

# Find all test files
TEST_FILES=()
while IFS= read -r -d '' file; do
    TEST_FILES+=("$file")
done < <(find "$TEST_DIR" -name "*.bats" -type f -print0 | sort -z)

if [ ${#TEST_FILES[@]} -eq 0 ]; then
    echo -e "${RED}No test files found in $TEST_DIR${NC}"
    exit 1
fi

echo -e "${YELLOW}Found ${#TEST_FILES[@]} test file(s)${NC}"
for file in "${TEST_FILES[@]}"; do
    echo "  - $(basename "$file")"
done
echo ""

# Check coverage tool availability
COVERAGE_TOOL=""
if command -v shfmt &>/dev/null; then
    COVERAGE_TOOL="shfmt"
elif command -v awk &>/dev/null; then
    COVERAGE_TOOL="awk"
fi

# Run tests
echo -e "${YELLOW}Running tests...${NC}"
echo ""

# Count total tests
TOTAL_TESTS=0
for file in "${TEST_FILES[@]}"; do
    count=$(grep -c "^@" "$file" 2>/dev/null || echo 0)
    TOTAL_TESTS=$((TOTAL_TESTS + count))
done

# Run bats with formatter
BATS_OUTPUT=$(bats --formatter tap "${TEST_FILES[@]}" 2>&1)
BATS_EXIT_CODE=$?

echo "$BATS_OUTPUT"

# Calculate results
PASSED_TESTS=$(echo "$BATS_OUTPUT" | grep -c "^ok " || echo 0)
FAILED_TESTS=$(echo "$BATS_OUTPUT" | grep -c "^not ok " || echo 0)
SKIPPED_TESTS=$(echo "$BATS_OUTPUT" | grep -c "^skip " || echo 0)

# Calculate coverage
if [ $BATS_EXIT_CODE -eq 0 ]; then
    echo ""
    echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║                    Test Summary                           ║${NC}"
    echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "  ${GREEN}Total Tests:${NC}    $TOTAL_TESTS"
    echo -e "  ${GREEN}Passed:${NC}        $PASSED_TESTS"
    echo -e "  ${YELLOW}Failed:${NC}        $FAILED_TESTS"
    echo -e "  ${YELLOW}Skipped:${NC}       $SKIPPED_TESTS"
    echo ""

    # Estimate coverage based on tested functions
    FUNCTIONS_TESTED=0
    FUNCTIONS_TOTAL=45  # Approximate number of functions in ghtools

    for file in "${TEST_FILES[@]}"; do
        test_count=$(grep -c "^@" "$file" 2>/dev/null || echo 0)
        FUNCTIONS_TESTED=$((FUNCTIONS_TESTED + test_count))
    done

    COVERAGE=$((FUNCTIONS_TESTED * 100 / FUNCTIONS_TOTAL))

    echo -e "  ${BLUE}Coverage:${NC}       ~${COVERAGE}% (estimated)"
    echo ""

    if [ $COVERAGE -ge 80 ]; then
        echo -e "  ${GREEN}✓ Coverage target achieved (≥80%)${NC}"
    else
        echo -e "  ${YELLOW}⚠ Coverage below target (${COVERAGE}% < 80%)${NC}"
    fi
    echo ""

    echo -e "${GREEN}All tests passed!${NC}"
    exit 0
else
    echo ""
    echo -e "${RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║                    Test Summary                           ║${NC}"
    echo -e "${RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "  ${GREEN}Total Tests:${NC}    $TOTAL_TESTS"
    echo -e "  ${GREEN}Passed:${NC}        $PASSED_TESTS"
    echo -e "  ${RED}Failed:${NC}        $FAILED_TESTS"
    echo -e "  ${YELLOW}Skipped:${NC}       $SKIPPED_TESTS"
    echo ""
    echo -e "${RED}Some tests failed. Please review the output above.${NC}"
    exit 1
fi
</file>


---

## Instructions

Please analyze the provided information and:

1. Understand the task requirements
2. Review the project structure
3. Consider the specified rules and constraints
4. Provide a detailed solution
