#!/bin/bash

# ghtools - Unified GitHub repository management tool (Refactored)
# Version: 3.0.0
# Requires: gh (GitHub CLI), fzf, jq, git

set -euo pipefail

# --- Version ---
VERSION="3.0.0"

# --- Default Configuration ---
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ghtools"
CONFIG_FILE="$CONFIG_DIR/config"
CACHE_FILE="/tmp/ghtools_repos.json"
CACHE_TTL=600     # 10 minutes (in seconds)
MAX_JOBS=5        # Parallel jobs for sync/clone
VERBOSE=false
QUIET=false

# --- Load User Config ---
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

# Create default config if not exists
init_config() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi
    if [ ! -f "$CONFIG_FILE" ]; then
        cat > "$CONFIG_FILE" <<'EOF'
# ghtools configuration file
# Uncomment and modify as needed

# Cache settings
#CACHE_TTL=600        # Cache time-to-live in seconds (default: 600)
#CACHE_FILE="/tmp/ghtools_repos.json"

# Parallel jobs for sync/clone operations
#MAX_JOBS=5

# Default organization filter (leave empty for all)
#DEFAULT_ORG=""

# Default clone path (leave empty for current directory)
#DEFAULT_CLONE_PATH=""
EOF
        print_info "Created default config at $CONFIG_FILE"
    fi
}

load_config

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Utility Functions ---

print_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
print_success() { [[ "$QUIET" == "true" ]] || echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_info() { [[ "$QUIET" == "true" ]] || echo -e "${BLUE}[INFO]${NC} $1"; }
print_warning() { [[ "$QUIET" == "true" ]] || echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_verbose() { [[ "$VERBOSE" == "true" ]] && echo -e "${CYAN}[DEBUG]${NC} $1" || true; }

show_usage() {
    cat <<EOF
${GREEN}ghtools${NC} - Unified GitHub repository management tool

${YELLOW}USAGE:${NC}
    ghtools [OPTIONS] <COMMAND> [ARGS]

${YELLOW}COMMANDS:${NC}
    ${GREEN}Repository Management:${NC}
    list [--refresh] [--lang <lang>] [--org <org>]
                        List repositories with optional filters
    clone [--path <dir>]
                        Clone repositories interactively
    create              Create a new repository
    delete              Delete repositories interactively
    fork [--clone] <query>
                        Fork external repositories
    archive [--unarchive]
                        Archive or unarchive repositories
    visibility [--public|--private]
                        Change repository visibility

    ${GREEN}Local Repository Operations:${NC}
    sync [--path <dir>] [--dry-run] [--all] [--max-depth <n>]
                        Sync local repositories with remote
    status [--path <dir>]
                        Show status of local repositories

    ${GREEN}Discovery & Navigation:${NC}
    search              Interactive fuzzy search with actions
    browse              Open repositories in browser
    stats               Show repository statistics dashboard
    explore [--sort <s>] [--lang <l>] <query>
                        Search external GitHub repositories
    trending [--lang <l>]
                        Show trending repositories

    ${GREEN}Pull Requests:${NC}
    pr list             List PRs for a repository
    pr create           Create PR from current branch

    ${GREEN}Utilities:${NC}
    refresh             Clear the repository cache
    config              Initialize/show config file location
    help                Show this help message

${YELLOW}OPTIONS:${NC}
    -h, --help          Show this help message
    -v, --version       Show version
    -V, --verbose       Enable verbose output
    -q, --quiet         Suppress non-error output

${YELLOW}EXAMPLES:${NC}
    ghtools list --lang python --org myorg
    ghtools clone --path ~/projects
    ghtools sync --dry-run --all
    ghtools fork --clone "react hooks"
    ghtools archive --unarchive
    ghtools visibility --private
    ghtools status --path ~/dev
    ghtools pr create
    ghtools explore "machine learning" --lang python
    ghtools trending --lang rust

${YELLOW}CONFIG:${NC}
    Config file: \$XDG_CONFIG_HOME/ghtools/config (or ~/.config/ghtools/config)

EOF
}

check_dependencies() {
  local missing_deps=()
  for cmd in gh fzf git jq; do
    if ! command -v "$cmd" &>/dev/null; then
      missing_deps+=("$cmd")
    fi
  done

  if [ ${#missing_deps[@]} -ne 0 ]; then
    print_error "Missing required dependencies:"
    printf "  - %s\n" "${missing_deps[@]}"
    echo ""
    echo "Install via Arch Linux:"
    echo "  sudo pacman -S github-cli fzf git jq"
    exit 1
  fi
}

check_gh_auth() {
  if ! gh auth status &>/dev/null; then
    print_error "Not authenticated with GitHub CLI. Run: gh auth login"
    exit 1
  fi
}

# --- Caching Mechanism ---

is_cache_valid() {
  if [ -f "$CACHE_FILE" ]; then
    local file_time current_time age
    file_time=$(date -r "$CACHE_FILE" +%s)
    current_time=$(date +%s)
    age=$((current_time - file_time))
    if [ "$age" -lt "$CACHE_TTL" ]; then
      return 0
    fi
  fi
  return 1
}

fetch_repositories_json() {
  local force_refresh="${1:-false}"
  local limit="${2:-1000}"
  local org_filter="${3:-${DEFAULT_ORG:-}}"
  local fields="name,nameWithOwner,description,visibility,primaryLanguage,stargazerCount,forkCount,diskUsage,updatedAt,createdAt,isArchived,url,sshUrl"
  local gh_cmd="gh repo list"

  # Add org filter if specified
  if [ -n "$org_filter" ]; then
    gh_cmd="gh repo list $org_filter"
    print_verbose "Filtering by organization: $org_filter"
  fi

  if [ "$force_refresh" = "true" ] || ! is_cache_valid; then
    print_info "Fetching repositories from GitHub API..." >&2
    local error_output
    error_output=$(mktemp)
    
    if ! $gh_cmd --limit "$limit" --json "$fields" >"$CACHE_FILE" 2>"$error_output"; then
      print_error "Failed to fetch repositories."
      if [ -s "$error_output" ]; then
        print_error "Details: $(cat "$error_output")"
      fi
      rm -f "$error_output"
      exit 1
    fi
    rm -f "$error_output"
    print_verbose "Fetched $(jq length "$CACHE_FILE") repositories"
  else
    print_info "Using cached repository list ($(date -r "$CACHE_FILE" '+%H:%M:%S'))" >&2
  fi

  cat "$CACHE_FILE"
}

# --- Helper Functions ---

# Job control for parallelism
wait_for_jobs() {
  local current_jobs
  current_jobs=$(jobs -p | wc -l)
  if [ "$current_jobs" -ge "$MAX_JOBS" ]; then
    wait -n
  fi
}

truncate_text() {
  local input="$1"
  local max="$2"
  if [ "${#input}" -gt "$max" ]; then
    echo "${input:0:$((max - 3))}..."
  else
    echo "$input"
  fi
}

# --- Action: List ---

action_list() {
  local refresh="false"
  local filter_lang=""
  local filter_org=""

  # Simple args parsing for list
  while [[ $# -gt 0 ]]; do
    case $1 in
    --refresh)
      refresh="true"
      shift
      ;;
    --lang)
      filter_lang="$2"
      shift 2
      ;;
    --org)
      filter_org="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "$refresh" "1000" "$filter_org")

  # Filter by language if requested
  if [ -n "$filter_lang" ]; then
    json=$(echo "$json" | jq --arg lang "$filter_lang" '[.[] | select(.primaryLanguage.name != null and (.primaryLanguage.name | ascii_downcase) == ($lang | ascii_downcase))]')
  fi

  # Output Table using pure JQ + printf (Faster/Cleaner)
  echo ""
  printf "%b%-30s %-40s %-10s %-10s %-15s%b\n" "$CYAN" "NAME" "DESCRIPTION" "VISIBILITY" "LANG" "UPDATED" "$NC"
  printf "%b%s%b\n" "$CYAN" "$(printf '%*s' 110 '' | tr ' ' '-')" "$NC"

  echo "$json" | jq -r '.[] | [.nameWithOwner, (.description // "No description"), .visibility, (.primaryLanguage.name // "-"), .updatedAt] | @tsv' |
    while IFS=$'\t' read -r name desc vis lang updated; do
      local d_name=$(truncate_text "$name" 30)
      local d_desc=$(truncate_text "$desc" 40)
      local d_updated=$(date -d "$updated" '+%Y-%m-%d' 2>/dev/null || echo "$updated")

      local color="$NC"
      [[ "$vis" == "PUBLIC" ]] && color="$GREEN"
      [[ "$vis" == "PRIVATE" ]] && color="$YELLOW"

      printf "%b%-30s%b %-40s %b%-10s%b %-10s %-15s\n" \
        "$BLUE" "$d_name" "$NC" "$d_desc" "$color" "$vis" "$NC" "$lang" "$d_updated"
    done
  echo ""
}

# --- Action: Clone ---

action_clone() {
  local clone_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      clone_path="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  # Validate clone path
  if [ ! -d "$clone_path" ]; then
    print_error "Clone path does not exist: $clone_path"
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  print_info "Select repositories to CLONE (TAB to multi-select):"
  print_info "Clone destination: $clone_path"

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="TAB: select | ENTER: confirm | Dest: $clone_path" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  echo ""
  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  local total=${#repos[@]}
  local current=0
  print_info "Cloning $total repositories in parallel ($MAX_JOBS threads)..."

  for repo in "${repos[@]}"; do
    wait_for_jobs
    (
      local repo_name
      repo_name=$(basename "$repo")
      local target_dir="$clone_path/$repo_name"
      
      if [ -d "$target_dir" ]; then
        print_warning "Skipped $repo (Directory exists)"
      else
        print_verbose "Cloning $repo to $target_dir"
        if gh repo clone "$repo" "$target_dir" &>/dev/null; then
          print_success "Cloned: $repo"
        else
          print_error "Failed: $repo"
        fi
      fi
    ) &
    ((current++)) || true
    # Progress indicator
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories queued..." "$current" "$total" >&2
  done
  wait
  echo "" >&2
  print_success "All clone operations completed."
}

# --- Action: Sync ---

action_sync() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local dry_run=false
  local sync_all=false
  local max_depth=3

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    --all)
      sync_all=true
      shift
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *)
      # Legacy: first positional arg is path
      if [ -d "$1" ]; then
        base_path="$1"
      fi
      shift
      ;;
    esac
  done

  print_info "Scanning for git repositories in $base_path..."
  print_verbose "Max depth: $max_depth, Dry run: $dry_run, Sync all: $sync_all"

  # Find git dirs
  local git_dirs
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune 2>/dev/null | xargs -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found."
    return
  fi

  print_info "Found ${#git_dirs[@]} repositories"

  local selected_paths
  if [ "$sync_all" = "true" ]; then
    # Non-interactive: sync all found repos
    selected_paths=$(printf "%s\n" "${git_dirs[@]}")
  else
    # Interactive selection
    selected_paths=$(printf "%s\n" "${git_dirs[@]}" |
      fzf --multi --height=40% --border --header="Select repos to SYNC (--all to skip)" --prompt="Repos > ")
  fi

  [ -z "$selected_paths" ] && return

  local total
  total=$(echo "$selected_paths" | wc -l)
  local current=0

  print_info "Syncing $total repositories in parallel..."
  [ "$dry_run" = "true" ] && print_warning "DRY-RUN mode: no changes will be made"

  while IFS= read -r repo_path; do
    wait_for_jobs
    (
      repo_name=$(basename "$repo_path")
      
      # Check for dirty state
      if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "Skipped $repo_name (Dirty state)"
        exit 0
      fi

      if [ "$dry_run" = "true" ]; then
        # Dry run: just fetch and show what would happen
        git -C "$repo_path" fetch --quiet 2>/dev/null || true
        local behind
        behind=$(git -C "$repo_path" rev-list HEAD..@{u} --count 2>/dev/null || echo "0")
        if [ "$behind" -gt 0 ]; then
          print_info "[DRY-RUN] Would pull $behind commits: $repo_name"
        else
          echo -e "${CYAN}[DRY-RUN]${NC} Already up to date: $repo_name"
        fi
      else
        # Actual sync
        if output=$(git -C "$repo_path" pull --ff-only 2>&1); then
          if [[ "$output" == *"Already up to date"* ]]; then
            echo -e "${CYAN}[NO CHANGE]${NC} $repo_name"
          else
            print_success "Synced: $repo_name"
          fi
        else
          print_error "Failed: $repo_name (Conflict or Diverged)"
        fi
      fi
    ) &
    ((current++)) || true
    printf "\r${CYAN}[PROGRESS]${NC} %d/%d repositories processing..." "$current" "$total" >&2
  done <<<"$selected_paths"

  wait
  echo "" >&2
  print_success "Sync completed."
}

# --- Action: Delete ---

check_delete_scope() {
  if ! gh auth status 2>&1 | grep -q "delete_repo"; then
    print_error "Missing 'delete_repo' scope required for repository deletion."
    echo ""
    read -p "Would you like to refresh auth with delete_repo scope? [y/N]: " response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      print_info "Running: gh auth refresh -s delete_repo"
      if gh auth refresh -s delete_repo; then
        print_success "Auth scope updated successfully."
        return 0
      else
        print_error "Failed to update auth scope."
        return 1
      fi
    else
      print_warning "Cannot proceed without delete_repo scope."
      return 1
    fi
  fi
  return 0
}

action_delete() {
  check_dependencies

  # Check delete scope - block if not available
  if ! check_delete_scope; then
    return 1
  fi

  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --multi --height=40% --border --header="SELECT REPOS TO DELETE (NO UNDO)" --color='pointer:red,marker:red,header:red')

  [ -z "$selected" ] && return

  local repos=()
  while read -r repo; do repos+=("$repo"); done <<<"$selected"

  echo ""
  print_warning "You are about to delete ${#repos[@]} repositories:"
  printf "  - ${RED}%s${NC}\n" "${repos[@]}"
  echo ""

  read -p "Type 'DELETE' to confirm, or anything else for Dry Run: " confirm
  local dry_run=true
  if [ "$confirm" == "DELETE" ]; then
    dry_run=false
  fi

  for repo in "${repos[@]}"; do
    if [ "$dry_run" = "true" ]; then
      print_info "[DRY-RUN] Would delete: $repo"
    else
      echo -e "${RED}[DELETING]${NC} $repo"
      if gh repo delete "$repo" --yes; then
        print_success "Deleted: $repo"
      else
        print_error "Failed to delete: $repo"
      fi
    fi
  done
}

# --- Action: Create (Simplified) ---

action_create() {
  # Simplificado para brevidade, mas mantendo a lÃ³gica core
  echo -e "${GREEN}Creating new repository${NC}"

  read -p "Repository Name: " name
  if [ -z "$name" ]; then
    print_error "Name required"
    return
  fi

  read -p "Description: " desc

  local vis
  vis=$(echo -e "public\nprivate" | fzf --height=10% --prompt="Visibility > ")
  [ -z "$vis" ] && vis="private"

  local tpl
  tpl=$(echo -e "none\npython\nnode\ngo" | fzf --height=15% --prompt="Template > ")

  local cmd="gh repo create $name --$vis"
  [ -n "$desc" ] && cmd="$cmd --description \"$desc\""

  # Create with clone
  if eval "$cmd --clone"; then
    print_success "Repository created."
    if [ "$tpl" != "none" ] && [ -d "$name" ]; then
      apply_template "$name" "$tpl"
      # Auto commit template
      (cd "$name" && git add . && git commit -m "Initial commit (Template: $tpl)" && git push origin HEAD)
    fi
  else
    print_error "Failed to create repository."
  fi
}

# --- Templates Logic ---

apply_template() {
  local dir="$1"
  local lang="$2"

  case "$lang" in
  python)
    echo "# $dir" >"$dir/README.md"
    touch "$dir/__init__.py"
    echo -e "def main():\n    print('Hello Python')\n\nif __name__ == '__main__':\n    main()" >"$dir/main.py"
    echo "git filtering..."
    cat <<EOT >"$dir/.gitignore"
__pycache__/
*.py[cod]
.venv/
EOT
    ;;
  node)
    echo "# $dir" >"$dir/README.md"
    echo "console.log('Hello Node');" >"$dir/index.js"
    cat <<EOT >"$dir/package.json"
{
  "name": "$dir",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT"
}
EOT
    cat <<EOT >"$dir/.gitignore"
node_modules/
.env
EOT
    ;;
  go)
    echo "# $dir" >"$dir/README.md"
    cat <<EOT >"$dir/main.go"
package main
import "fmt"
func main() {
    fmt.Println("Hello Go")
}
EOT
    (cd "$dir" && go mod init "github.com/$(gh api user -q .login)/$dir" 2>/dev/null || true)
    ;;
  esac
  print_info "Applied $lang template."
}

# --- Action: Fork ---

action_fork() {
  local search_query=""
  local clone_after=false

  while [[ $# -gt 0 ]]; do
    case $1 in
    --clone)
      clone_after=true
      shift
      ;;
    *)
      search_query="$1"
      shift
      ;;
    esac
  done

  if [ -z "$search_query" ]; then
    read -p "Search for repository to fork: " search_query
    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi
  fi

  print_info "Searching GitHub for '$search_query'..."

  local results
  results=$(gh search repos "$search_query" --limit 50 --json fullName,description,stargazersCount,language \
    2>/dev/null | jq -r '.[] | "\(.fullName)\t\(.stargazersCount)â­\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=50% --border \
    --header="Select repository to FORK (TAB for multi)" \
    --delimiter='\t' --with-nth=1,2,3 --multi \
    --preview="echo {4}" --preview-window=down:2:wrap)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _ _ _; do
    print_info "Forking $repo..."
    if gh repo fork "$repo" --clone="$clone_after" 2>/dev/null; then
      print_success "Forked: $repo"
      if [ "$clone_after" = "true" ]; then
        print_success "Cloned to: $(basename "$repo")"
      fi
    else
      print_error "Failed to fork: $repo"
    fi
  done <<<"$selected"
}

# --- Action: Explore (External Search) ---

action_explore() {
  local search_query=""
  local sort_by="stars"
  local language=""
  local limit=100

  while [[ $# -gt 0 ]]; do
    case $1 in
    --sort)
      sort_by="$2"
      shift 2
      ;;
    --lang)
      language="$2"
      shift 2
      ;;
    --limit)
      limit="$2"
      shift 2
      ;;
    *)
      search_query="$search_query $1"
      shift
      ;;
    esac
  done

  search_query=$(echo "$search_query" | xargs) # trim

  if [ -z "$search_query" ]; then
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}                    ğŸ”­ EXPLORE GITHUB                           ${NC}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    read -p "Search query: " search_query
    if [ -z "$search_query" ]; then
      print_error "Search query required"
      return 1
    fi

    echo ""
    echo "Sort by: (s)tars | (f)orks | (u)pdated | (h)elp-wanted"
    read -p "Sort [stars]: " sort_choice
    case "$sort_choice" in
    f) sort_by="forks" ;;
    u) sort_by="updated" ;;
    h) sort_by="help-wanted-issues" ;;
    *) sort_by="stars" ;;
    esac

    read -p "Filter by language (leave empty for all): " language
  fi

  print_info "Searching GitHub for '$search_query' (sorted by $sort_by)..."

  local gh_cmd="gh search repos \"$search_query\" --limit $limit --sort $sort_by"
  [ -n "$language" ] && gh_cmd="$gh_cmd --language \"$language\""

  local results
  results=$(eval "$gh_cmd" --json fullName,description,stargazersCount,forksCount,language,updatedAt,license 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)â­\t\(.forksCount)ğŸ´\t\(.language // "-")\t\(.updatedAt[:10])\t\(.description // "No description")"')

  if [ -z "$results" ]; then
    print_warning "No repositories found for '$search_query'"
    return 1
  fi

  local count
  count=$(echo "$results" | wc -l)
  print_info "Found $count repositories"

  local selected
  selected=$(echo "$results" | fzf --height=70% --border \
    --header="ğŸ”­ Explore: $search_query | Actions: Enter=select, TAB=multi" \
    --delimiter='\t' --with-nth=1,2,3,4,5 \
    --preview="echo -e 'Repository: {1}\nStars: {2} | Forks: {3}\nLanguage: {4} | Updated: {5}\n\nDescription:\n{6}'" \
    --preview-window=down:6:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  echo -e "${CYAN}Selected ${#repos[@]} repositories:${NC}"
  printf "  - ${BLUE}%s${NC}\n" "${repos[@]}"
  echo ""
  echo -e "${YELLOW}Actions:${NC}"
  echo "  (c) Clone          - Clone to local machine"
  echo "  (f) Fork           - Fork to your account"
  echo "  (F) Fork + Clone   - Fork and clone"
  echo "  (b) Browse         - Open in browser"
  echo "  (s) Star           - Star the repository"
  echo "  (i) Info           - Show detailed info"
  echo "  (q) Quit           - Cancel"
  echo ""
  read -p "Action: " action

  case "$action" in
  c)
    for repo in "${repos[@]}"; do
      print_info "Cloning $repo..."
      if gh repo clone "$repo" 2>/dev/null; then
        print_success "Cloned: $repo"
      else
        print_error "Failed to clone: $repo"
      fi
    done
    ;;
  f)
    for repo in "${repos[@]}"; do
      print_info "Forking $repo..."
      if gh repo fork "$repo" --clone=false 2>/dev/null; then
        print_success "Forked: $repo"
      else
        print_error "Failed to fork: $repo"
      fi
    done
    ;;
  F)
    for repo in "${repos[@]}"; do
      print_info "Forking and cloning $repo..."
      if gh repo fork "$repo" --clone=true 2>/dev/null; then
        print_success "Forked and cloned: $repo"
      else
        print_error "Failed: $repo"
      fi
    done
    ;;
  b)
    for repo in "${repos[@]}"; do
      print_info "Opening $repo in browser..."
      gh browse -R "$repo" 2>/dev/null &
    done
    print_success "Opened in browser"
    ;;
  s)
    for repo in "${repos[@]}"; do
      print_info "Starring $repo..."
      if gh api -X PUT "user/starred/$repo" 2>/dev/null; then
        print_success "Starred: $repo"
      else
        print_error "Failed to star: $repo"
      fi
    done
    ;;
  i)
    for repo in "${repos[@]}"; do
      echo ""
      echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
      echo -e "${GREEN}$repo${NC}"
      echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
      gh repo view "$repo" 2>/dev/null || print_error "Failed to fetch info"
      echo ""
      read -p "Press Enter to continue..."
    done
    ;;
  q | *)
    print_info "Cancelled"
    ;;
  esac
}

# --- Action: Trending ---

action_trending() {
  local language="${1:-}"
  local since="daily"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --lang)
      language="$2"
      shift 2
      ;;
    --since)
      since="$2"
      shift 2
      ;;
    *)
      [ -z "$language" ] && language="$1"
      shift
      ;;
    esac
  done

  echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo -e "${CYAN}                    ğŸ”¥ TRENDING REPOSITORIES                    ${NC}"
  echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo ""

  local query="stars:>100 pushed:>$(date -d '7 days ago' '+%Y-%m-%d' 2>/dev/null || date -v-7d '+%Y-%m-%d')"
  [ -n "$language" ] && query="$query language:$language"

  print_info "Fetching trending repositories${language:+ for $language}..."

  local results
  results=$(gh search repos "$query" --sort stars --order desc --limit 30 \
    --json fullName,description,stargazersCount,language,updatedAt 2>/dev/null | \
    jq -r '.[] | "\(.fullName)\t\(.stargazersCount)â­\t\(.language // "-")\t\(.description // "")"')

  if [ -z "$results" ]; then
    print_warning "No trending repositories found"
    return 1
  fi

  local selected
  selected=$(echo "$results" | fzf --height=60% --border \
    --header="ğŸ”¥ Trending${language:+ ($language)} | TAB=multi-select" \
    --delimiter='\t' --with-nth=1,2,3 \
    --preview="echo {4}" --preview-window=down:3:wrap \
    --multi)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  echo ""
  echo "Actions: (c)lone | (f)ork | (b)rowse | (s)tar | (q)uit"
  read -p "Action: " action

  case "$action" in
  c)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" 2>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  f)
    for repo in "${repos[@]}"; do
      gh repo fork "$repo" --clone=false 2>/dev/null && print_success "Forked: $repo" || print_error "Failed: $repo"
    done
    ;;
  b)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    ;;
  s)
    for repo in "${repos[@]}"; do
      gh api -X PUT "user/starred/$repo" 2>/dev/null && print_success "Starred: $repo" || print_error "Failed: $repo"
    done
    ;;
  esac
}

# --- Action: Archive ---

action_archive() {
  local mode="archive"

  while [[ $# -gt 0 ]]; do
    case $1 in
    --unarchive)
      mode="unarchive"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filter_jq
  local header_text
  if [ "$mode" = "archive" ]; then
    filter_jq='[.[] | select(.isArchived == false)]'
    header_text="Select repos to ARCHIVE"
  else
    filter_jq='[.[] | select(.isArchived == true)]'
    header_text="Select repos to UNARCHIVE"
  fi

  local filtered
  filtered=$(echo "$json" | jq "$filter_jq")

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories available to $mode"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  local repos=()
  while IFS=$'\t' read -r repo _; do
    repos+=("$repo")
  done <<<"$selected"

  print_warning "You are about to $mode ${#repos[@]} repositories:"
  printf "  - %s\n" "${repos[@]}"
  echo ""
  read -p "Continue? [y/N]: " confirm

  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    print_info "Cancelled."
    return
  fi

  for repo in "${repos[@]}"; do
    print_info "${mode^}ing $repo..."
    if [ "$mode" = "archive" ]; then
      if gh repo archive "$repo" --yes 2>/dev/null; then
        print_success "Archived: $repo"
      else
        print_error "Failed to archive: $repo"
      fi
    else
      if gh repo unarchive "$repo" --yes 2>/dev/null; then
        print_success "Unarchived: $repo"
      else
        print_error "Failed to unarchive: $repo"
      fi
    fi
  done

  rm -f "$CACHE_FILE"
  print_info "Cache cleared (repo states changed)"
}

# --- Action: Stats ---

action_stats() {
  local json
  json=$(fetch_repositories_json "true")

  echo ""
  echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo -e "${CYAN}                    ğŸ“Š REPOSITORY STATISTICS                    ${NC}"
  echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo ""

  local total public private archived
  total=$(echo "$json" | jq 'length')
  public=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")] | length')
  private=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")] | length')
  archived=$(echo "$json" | jq '[.[] | select(.isArchived == true)] | length')

  echo -e "  ${GREEN}Total Repositories:${NC}  $total"
  echo -e "  ${GREEN}Public:${NC}              $public"
  echo -e "  ${YELLOW}Private:${NC}             $private"
  echo -e "  ${CYAN}Archived:${NC}            $archived"
  echo ""

  local total_stars total_forks total_size
  total_stars=$(echo "$json" | jq '[.[].stargazerCount] | add // 0')
  total_forks=$(echo "$json" | jq '[.[].forkCount] | add // 0')
  total_size=$(echo "$json" | jq '[.[].diskUsage] | add // 0')
  local size_mb=$((total_size / 1024))

  echo -e "  ${YELLOW}â­ Total Stars:${NC}       $total_stars"
  echo -e "  ${BLUE}ğŸ´ Total Forks:${NC}       $total_forks"
  echo -e "  ${CYAN}ğŸ’¾ Total Size:${NC}        ${size_mb} MB"
  echo ""

  echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e "${CYAN}                      Languages Breakdown                        ${NC}"
  echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo ""

  echo "$json" | jq -r '
    [.[] | .primaryLanguage.name // "Unknown"] | 
    group_by(.) | 
    map({lang: .[0], count: length}) | 
    sort_by(-.count) | 
    .[:10] | 
    .[] | 
    "  \(.lang): \(.count)"
  '
  echo ""

  echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e "${CYAN}                      Top Repositories (by â­)                   ${NC}"
  echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo ""

  echo "$json" | jq -r '
    sort_by(-.stargazerCount) | 
    .[:5] | 
    .[] | 
    "  â­ \(.stargazerCount)\t\(.nameWithOwner)"
  ' | column -t -s $'\t'
  echo ""

  echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e "${CYAN}                   Recently Updated (last 5)                     ${NC}"
  echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo ""

  echo "$json" | jq -r '
    sort_by(.updatedAt) | reverse |
    .[:5] | 
    .[] | 
    "  \(.updatedAt[:10])\t\(.nameWithOwner)"
  ' | column -t -s $'\t'
  echo ""
}

# --- Action: Search ---

action_search() {
  local json
  json=$(fetch_repositories_json "false")

  print_info "Type to search (fuzzy matching on name and description)..."

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "No description")\t\(.visibility)\t\(.primaryLanguage.name // "-")"' |
    fzf --height=60% --border \
      --header="Search repositories (ESC to cancel)" \
      --delimiter='\t' \
      --with-nth=1,3,4 \
      --preview="echo -e 'Description:\n{2}'" \
      --preview-window=down:3:wrap \
      --multi)

  [ -z "$selected" ] && return

  echo ""
  echo -e "${CYAN}Selected repositories:${NC}"
  while IFS=$'\t' read -r repo desc vis lang; do
    echo -e "  ${BLUE}$repo${NC} [$vis] ($lang)"
  done <<<"$selected"

  echo ""
  echo "Actions: (c)lone | (b)rowse | (d)elete | (q)uit"
  read -p "Action: " action

  local repos=()
  while IFS=$'\t' read -r repo _ _ _; do
    repos+=("$repo")
  done <<<"$selected"

  case "$action" in
  c)
    for repo in "${repos[@]}"; do
      gh repo clone "$repo" &>/dev/null && print_success "Cloned: $repo" || print_error "Failed: $repo"
    done
    ;;
  b)
    for repo in "${repos[@]}"; do
      gh browse -R "$repo" 2>/dev/null &
    done
    ;;
  d)
    print_warning "Delete selected repos? This is NOT reversible!"
    read -p "Type 'DELETE' to confirm: " confirm
    if [ "$confirm" = "DELETE" ]; then
      for repo in "${repos[@]}"; do
        gh repo delete "$repo" --yes 2>/dev/null && print_success "Deleted: $repo" || print_error "Failed: $repo"
      done
    fi
    ;;
  esac
}

# --- Action: Browse ---

action_browse() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)\t\(.description // "")"' |
    fzf --multi --height=40% --border --header="Select repos to open in browser" --delimiter='\t' --with-nth=1)

  [ -z "$selected" ] && return

  while IFS=$'\t' read -r repo _; do
    print_info "Opening $repo in browser..."
    gh browse -R "$repo" 2>/dev/null &
  done <<<"$selected"

  print_success "Opened selected repositories in browser"
}

# --- Action: Visibility ---

action_visibility() {
  local target_visibility=""

  while [[ $# -gt 0 ]]; do
    case $1 in
    --public)
      target_visibility="public"
      shift
      ;;
    --private)
      target_visibility="private"
      shift
      ;;
    *) shift ;;
    esac
  done

  local json
  json=$(fetch_repositories_json "false")

  local filtered header_text
  if [ "$target_visibility" = "public" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PRIVATE")]')
    header_text="Select PRIVATE repos to make PUBLIC"
  elif [ "$target_visibility" = "private" ]; then
    filtered=$(echo "$json" | jq '[.[] | select(.visibility == "PUBLIC")]')
    header_text="Select PUBLIC repos to make PRIVATE"
  else
    filtered="$json"
    header_text="Select repos to toggle visibility"
  fi

  local count
  count=$(echo "$filtered" | jq 'length')
  if [ "$count" -eq 0 ]; then
    print_warning "No repositories match the criteria"
    return
  fi

  local selected
  selected=$(echo "$filtered" | jq -r '.[] | "\(.nameWithOwner)\t\(.visibility)"' |
    fzf --multi --height=40% --border --header="$header_text" --delimiter='\t')

  [ -z "$selected" ] && return

  local repos=()
  local visibilities=()
  while IFS=$'\t' read -r repo vis; do
    repos+=("$repo")
    visibilities+=("$vis")
  done <<<"$selected"

  print_warning "Visibility changes:"
  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi
    echo -e "  ${repos[$i]}: ${visibilities[$i]} â†’ ${new_vis^^}"
  done

  echo ""
  read -p "Continue? [y/N]: " confirm
  [[ ! "$confirm" =~ ^[Yy]$ ]] && return

  for i in "${!repos[@]}"; do
    local new_vis
    if [ -n "$target_visibility" ]; then
      new_vis="$target_visibility"
    elif [ "${visibilities[$i]}" = "PUBLIC" ]; then
      new_vis="private"
    else
      new_vis="public"
    fi

    print_info "Changing ${repos[$i]} to $new_vis..."
    if gh repo edit "${repos[$i]}" --visibility "$new_vis" 2>/dev/null; then
      print_success "Updated: ${repos[$i]}"
    else
      print_error "Failed: ${repos[$i]}"
    fi
  done

  rm -f "$CACHE_FILE"
}

# --- Action: PR (Pull Requests) ---

action_pr() {
  local subcommand="${1:-list}"
  shift 2>/dev/null || true

  case "$subcommand" in
  list)
    action_pr_list "$@"
    ;;
  create)
    action_pr_create "$@"
    ;;
  *)
    print_error "Unknown PR subcommand: $subcommand"
    echo "Usage: ghtools pr {list|create}"
    ;;
  esac
}

action_pr_list() {
  local json
  json=$(fetch_repositories_json "false")

  local selected
  selected=$(echo "$json" | jq -r '.[] | "\(.nameWithOwner)"' |
    fzf --height=40% --border --header="Select repository to list PRs")

  [ -z "$selected" ] && return

  print_info "Fetching PRs for $selected..."
  echo ""

  gh pr list -R "$selected" --limit 20 --json number,title,state,author,createdAt \
    --template '{{range .}}#{{.number}} [{{.state}}] {{.title}} (by {{.author.login}}, {{timeago .createdAt}})
{{end}}'
}

action_pr_create() {
  if [ ! -d ".git" ]; then
    print_error "Not in a git repository"
    return 1
  fi

  local current_branch
  current_branch=$(git branch --show-current)

  if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
    print_warning "You're on $current_branch branch. Create a feature branch first."
    return 1
  fi

  print_info "Creating PR from branch: $current_branch"

  read -p "PR Title: " title
  [ -z "$title" ] && title="$current_branch"

  local draft=""
  read -p "Create as draft? [y/N]: " is_draft
  [[ "$is_draft" =~ ^[Yy]$ ]] && draft="--draft"

  # Push branch if needed
  if ! git ls-remote --exit-code --heads origin "$current_branch" &>/dev/null; then
    print_info "Pushing branch to origin..."
    git push -u origin "$current_branch"
  fi

  # shellcheck disable=SC2086
  if gh pr create --title "$title" --body "" $draft; then
    print_success "PR created successfully"
  else
    print_error "Failed to create PR"
  fi
}

# --- Action: Status ---

action_status() {
  local base_path="${DEFAULT_CLONE_PATH:-$(pwd)}"
  local max_depth=3

  while [[ $# -gt 0 ]]; do
    case $1 in
    --path)
      base_path="$2"
      shift 2
      ;;
    --max-depth)
      max_depth="$2"
      shift 2
      ;;
    *) shift ;;
    esac
  done

  print_info "Scanning repositories in $base_path..."

  local git_dirs
  mapfile -t git_dirs < <(find "$base_path" -maxdepth "$max_depth" -name ".git" -type d -prune 2>/dev/null | xargs -n1 dirname)

  if [ ${#git_dirs[@]} -eq 0 ]; then
    print_warning "No git repositories found"
    return
  fi

  echo ""
  printf "${CYAN}%-35s %-12s %-10s %-10s %s${NC}\n" "REPOSITORY" "BRANCH" "STATUS" "AHEAD" "BEHIND"
  printf "${CYAN}%s${NC}\n" "$(printf '%*s' 85 '' | tr ' ' '-')"

  for repo_path in "${git_dirs[@]}"; do
    local repo_name branch status_icon ahead behind
    repo_name=$(basename "$repo_path")
    branch=$(git -C "$repo_path" branch --show-current 2>/dev/null || echo "detached")

    # Check dirty state
    local dirty=false
    if ! git -C "$repo_path" diff-index --quiet HEAD -- 2>/dev/null; then
      dirty=true
    fi

    # Check untracked files
    local untracked=false
    if [ -n "$(git -C "$repo_path" ls-files --others --exclude-standard 2>/dev/null)" ]; then
      untracked=true
    fi

    # Determine status
    if [ "$dirty" = "true" ] && [ "$untracked" = "true" ]; then
      status_icon="${RED}dirty+untrk${NC}"
    elif [ "$dirty" = "true" ]; then
      status_icon="${YELLOW}dirty${NC}"
    elif [ "$untracked" = "true" ]; then
      status_icon="${YELLOW}untracked${NC}"
    else
      status_icon="${GREEN}clean${NC}"
    fi

    # Check ahead/behind
    ahead=$(git -C "$repo_path" rev-list --count @{u}..HEAD 2>/dev/null || echo "?")
    behind=$(git -C "$repo_path" rev-list --count HEAD..@{u} 2>/dev/null || echo "?")

    local ahead_color="$NC" behind_color="$NC"
    [ "$ahead" != "0" ] && [ "$ahead" != "?" ] && ahead_color="$GREEN"
    [ "$behind" != "0" ] && [ "$behind" != "?" ] && behind_color="$RED"

    printf "%-35s %-12s ${status_icon}%-10s ${ahead_color}%-10s${NC} ${behind_color}%s${NC}\n" \
      "$(truncate_text "$repo_name" 35)" "$branch" "" "$ahead" "$behind"
  done

  echo ""
  print_info "Legend: ${GREEN}clean${NC} | ${YELLOW}dirty/untracked${NC} | ${GREEN}ahead${NC} (unpushed) | ${RED}behind${NC} (needs pull)"
}

# --- Main Menu ---

show_menu() {
  local options="ğŸ“‹ List Repositories
ğŸ” Search My Repos
ğŸ”­ Explore GitHub
ğŸ”¥ Trending Repos
ğŸ“Š Statistics Dashboard
ğŸ“¦ Clone Repositories
ğŸ”„ Sync Local Repos
ğŸ“ Local Repo Status
ğŸ´ Fork Repository
â• Create Repository
ğŸ—‘ï¸  Delete Repositories
ğŸ“¦ Archive/Unarchive
ğŸ”’ Change Visibility
ğŸŒ Browse in Browser
ğŸ“ Pull Requests
âš™ï¸  Config
ğŸ”„ Refresh Cache
ğŸšª Exit"

  local choice
  choice=$(echo "$options" | fzf --height=55% --border --header="GitHub Tools v$VERSION" --layout=reverse)

  case "$choice" in
  *"List"*) action_list ;;
  *"Search My"*) action_search ;;
  *"Explore"*) action_explore ;;
  *"Trending"*) action_trending ;;
  *"Statistics"*) action_stats ;;
  *"Clone"*) action_clone ;;
  *"Sync"*) action_sync ;;
  *"Local Repo Status"*) action_status ;;
  *"Fork"*) action_fork ;;
  *"Create"*) action_create ;;
  *"Delete"*) action_delete ;;
  *"Archive"*) action_archive ;;
  *"Visibility"*) action_visibility ;;
  *"Browse"*) action_browse ;;
  *"Pull Requests"*) action_pr ;;
  *"Config"*)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;
  *"Refresh"*)
    rm -f "$CACHE_FILE"
    print_success "Cache cleared."
    show_menu
    ;;
  *"Exit"*) exit 0 ;;
  *) exit 0 ;;
  esac
}

# --- Entry Point ---

main() {
  # Parse global options first
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_usage
      exit 0
      ;;
    -v | --version)
      echo "ghtools $VERSION"
      exit 0
      ;;
    -V | --verbose)
      VERBOSE=true
      shift
      ;;
    -q | --quiet)
      QUIET=true
      shift
      ;;
    *)
      # Stop parsing global options, pass to command handler
      break
      ;;
    esac
  done

  check_dependencies
  check_gh_auth

  if [ $# -eq 0 ]; then
    while true; do
      show_menu
      echo ""
      read -p "Press Enter to continue..."
    done
  fi

  case "$1" in
  list)
    shift
    action_list "$@"
    ;;
  clone)
    shift
    action_clone "$@"
    ;;
  sync)
    shift
    action_sync "$@"
    ;;
  create) action_create ;;
  delete) action_delete ;;
  fork)
    shift
    action_fork "$@"
    ;;
  archive)
    shift
    action_archive "$@"
    ;;
  stats) action_stats ;;
  search) action_search ;;
  browse) action_browse ;;
  explore)
    shift
    action_explore "$@"
    ;;
  trending)
    shift
    action_trending "$@"
    ;;
  visibility)
    shift
    action_visibility "$@"
    ;;
  pr)
    shift
    action_pr "$@"
    ;;
  status)
    shift
    action_status "$@"
    ;;
  config)
    init_config
    print_info "Config file: $CONFIG_FILE"
    ;;
  refresh)
    rm -f "$CACHE_FILE"
    print_success "Cache cleared."
    ;;
  help)
    show_usage
    ;;
  *)
    print_error "Unknown command: $1"
    show_usage
    exit 1
    ;;
  esac
}

main "$@"
